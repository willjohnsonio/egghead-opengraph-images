window["playwrightweb"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/web.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/accessibility.ts":
/*!******************************!*\
  !*** ./src/accessibility.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Accessibility {
    constructor(getAXTree) {
        this._getAXTree = getAXTree;
    }
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null, } = options;
        const { tree, needle } = await this._getAXTree(root || undefined);
        if (!interestingOnly) {
            if (root)
                return needle && serializeTree(needle)[0];
            return serializeTree(tree)[0];
        }
        const interestingNodes = new Set();
        collectInterestingNodes(interestingNodes, tree, false);
        if (root && (!needle || !interestingNodes.has(needle)))
            return null;
        return serializeTree(needle || tree, interestingNodes)[0];
    }
}
exports.Accessibility = Accessibility;
function collectInterestingNodes(collection, node, insideControl) {
    if (node.isInteresting(insideControl))
        collection.add(node);
    if (node.isLeafNode())
        return;
    insideControl = insideControl || node.isControl();
    for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
}
function serializeTree(node, whitelistedNodes) {
    const children = [];
    for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
    if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
    const serializedNode = node.serialize();
    if (children.length)
        serializedNode.children = children;
    return [serializedNode];
}


/***/ }),

/***/ "./src/browser.ts":
/*!************************!*\
  !*** ./src/browser.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
async function createPageInNewContext(browser, options) {
    const context = await browser.newContext(options);
    const page = await context.newPage();
    page._ownedContext = context;
    return page;
}
exports.createPageInNewContext = createPageInNewContext;


/***/ }),

/***/ "./src/browserContext.ts":
/*!*******************************!*\
  !*** ./src/browserContext.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const network = __webpack_require__(/*! ./network */ "./src/network.ts");
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
const timeoutSettings_1 = __webpack_require__(/*! ./timeoutSettings */ "./src/timeoutSettings.ts");
class BrowserContext extends platform.EventEmitter {
    constructor(delegate, options) {
        super();
        this._closed = false;
        this._delegate = delegate;
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings();
        this._options = { ...options };
        if (!this._options.viewport && this._options.viewport !== null)
            this._options.viewport = { width: 800, height: 600 };
        if (this._options.viewport)
            this._options.viewport = { ...this._options.viewport };
        if (this._options.geolocation)
            this._options.geolocation = verifyGeolocation(this._options.geolocation);
    }
    async _initialize() {
        const entries = Object.entries(this._options.permissions || {});
        await Promise.all(entries.map(entry => this.setPermissions(entry[0], entry[1])));
        if (this._options.geolocation)
            await this.setGeolocation(this._options.geolocation);
    }
    _existingPages() {
        return this._delegate.existingPages();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async pages() {
        return this._delegate.pages();
    }
    async newPage() {
        const pages = this._delegate.existingPages();
        for (const page of pages) {
            if (page._ownedContext)
                throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
        }
        return this._delegate.newPage();
    }
    async cookies(...urls) {
        return network.filterCookies(await this._delegate.cookies(), urls);
    }
    async setCookies(cookies) {
        await this._delegate.setCookies(network.rewriteCookies(cookies));
    }
    async clearCookies() {
        await this._delegate.clearCookies();
    }
    async setPermissions(origin, permissions) {
        await this._delegate.setPermissions(origin, permissions);
    }
    async clearPermissions() {
        await this._delegate.clearPermissions();
    }
    async setGeolocation(geolocation) {
        if (geolocation)
            geolocation = verifyGeolocation(geolocation);
        this._options.geolocation = geolocation || undefined;
        await this._delegate.setGeolocation(geolocation);
    }
    async close() {
        if (this._closed)
            return;
        await this._delegate.close();
        this._closed = true;
        this.emit(events_1.Events.BrowserContext.Close);
    }
    static validateOptions(options) {
        if (options.geolocation)
            verifyGeolocation(options.geolocation);
    }
    _browserClosed() {
        this._closed = true;
        for (const page of this._delegate.existingPages())
            page._didClose();
        this.emit(events_1.Events.BrowserContext.Close);
    }
}
exports.BrowserContext = BrowserContext;
function verifyGeolocation(geolocation) {
    const result = { ...geolocation };
    result.accuracy = result.accuracy || 0;
    const { longitude, latitude, accuracy } = result;
    if (!helper_1.helper.isNumber(longitude) || longitude < -180 || longitude > 180)
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
    if (!helper_1.helper.isNumber(latitude) || latitude < -90 || latitude > 90)
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
    if (!helper_1.helper.isNumber(accuracy) || accuracy < 0)
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
    return result;
}


/***/ }),

/***/ "./src/chromium/crAccessibility.ts":
/*!*****************************************!*\
  !*** ./src/chromium/crAccessibility.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
async function getAccessibilityTree(client, needle) {
    const { nodes } = await client.send('Accessibility.getFullAXTree');
    const tree = CRAXNode.createTree(client, nodes);
    return {
        tree,
        needle: needle ? await tree._findElement(needle) : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
class CRAXNode {
    constructor(client, payload) {
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : '';
        this._role = this._payload.role ? this._payload.role.value : 'Unknown';
        for (const property of this._payload.properties || []) {
            if (property.name === 'editable') {
                this._richlyEditable = property.value.value === 'richtext';
                this._editable = true;
            }
            if (property.name === 'focusable')
                this._focusable = property.value.value;
            if (property.name === 'expanded')
                this._expanded = property.value.value;
            if (property.name === 'hidden')
                this._hidden = property.value.value;
        }
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return (role === 'LineBreak' || role === 'text' ||
            role === 'InlineTextBox');
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this._children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    children() {
        return this._children;
    }
    async _findElement(element) {
        const remoteObject = element._remoteObject;
        const { node: { backendNodeId } } = await this._client.send('DOM.describeNode', { objectId: remoteObject.objectId });
        const needle = this.find(node => node._payload.backendDOMNodeId === backendNodeId);
        return needle || null;
    }
    find(predicate) {
        if (predicate(this))
            return this;
        for (const child of this._children) {
            const result = child.find(predicate);
            if (result)
                return result;
        }
        return null;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this._role;
        if (role === 'Ignored' || this._hidden)
            return false;
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name;
    }
    serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
            properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.name)
            properties.set('name', this._payload.name.value);
        if (this._payload.value)
            properties.set('value', this._payload.value.value);
        if (this._payload.description)
            properties.set('description', this._payload.description.value);
        const node = {
            role: this._role,
            name: this._payload.name ? (this._payload.name.value || '') : ''
        };
        const userStringProperties = [
            'value',
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty))
                continue;
            node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,
            // not whether focus is specifically on the root node.
            if (booleanProperty === 'focused' && this._role === 'WebArea')
                continue;
            const value = properties.get(booleanProperty);
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const tristateProperties = [
            'checked',
            'pressed',
        ];
        for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty))
                continue;
            const value = properties.get(tristateProperty);
            node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty))
                continue;
            node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = properties.get(tokenProperty);
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        return node;
    }
    static createTree(client, payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
            nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
            for (const childId of node._payload.childIds || [])
                node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
    }
}


/***/ }),

/***/ "./src/chromium/crBrowser.ts":
/*!***********************************!*\
  !*** ./src/chromium/crBrowser.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __webpack_require__(/*! ./events */ "./src/chromium/events.ts");
const events_2 = __webpack_require__(/*! ../events */ "./src/events.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const browserContext_1 = __webpack_require__(/*! ../browserContext */ "./src/browserContext.ts");
const crConnection_1 = __webpack_require__(/*! ./crConnection */ "./src/chromium/crConnection.ts");
const crTarget_1 = __webpack_require__(/*! ./crTarget */ "./src/chromium/crTarget.ts");
const browser_1 = __webpack_require__(/*! ../browser */ "./src/browser.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const crProtocolHelper_1 = __webpack_require__(/*! ./crProtocolHelper */ "./src/chromium/crProtocolHelper.ts");
const transport_1 = __webpack_require__(/*! ../transport */ "./src/transport.ts");
class CRBrowser extends platform.EventEmitter {
    constructor(connection) {
        super();
        this._contexts = new Map();
        this._targets = new Map();
        this._tracingRecording = false;
        this._tracingPath = '';
        this._connection = connection;
        this._client = connection.rootSession;
        this._defaultContext = this._createBrowserContext(null, {});
        this._connection.on(crConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this.contexts())
                context._browserClosed();
            this.emit(events_2.Events.Browser.Disconnected);
        });
        this._client.on('Target.targetCreated', this._targetCreated.bind(this));
        this._client.on('Target.targetDestroyed', this._targetDestroyed.bind(this));
        this._client.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));
    }
    static async connect(transport, slowMo) {
        const connection = new crConnection_1.CRConnection(transport_1.SlowMoTransport.wrap(transport, slowMo));
        const browser = new CRBrowser(connection);
        await connection.rootSession.send('Target.setDiscoverTargets', { discover: true });
        return browser;
    }
    _createBrowserContext(contextId, options) {
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const targets = this._allTargets().filter(target => target.context() === context && target.type() === 'page');
                const pages = await Promise.all(targets.map(target => target.page()));
                return pages.filter(page => !!page);
            },
            existingPages: () => {
                const pages = [];
                for (const target of this._allTargets()) {
                    if (target.context() === context && target._crPage)
                        pages.push(target._crPage.page());
                }
                return pages;
            },
            newPage: async () => {
                const { targetId } = await this._client.send('Target.createTarget', { url: 'about:blank', browserContextId: contextId || undefined });
                const target = this._targets.get(targetId);
                helper_1.assert(await target._initializedPromise, 'Failed to create target for page');
                const page = await target.page();
                return page;
            },
            close: async () => {
                helper_1.assert(contextId, 'Non-incognito profiles cannot be closed!');
                await this._client.send('Target.disposeBrowserContext', { browserContextId: contextId });
                this._contexts.delete(contextId);
            },
            cookies: async () => {
                const { cookies } = await this._client.send('Storage.getCookies', { browserContextId: contextId || undefined });
                return cookies.map(c => {
                    const copy = { sameSite: 'None', ...c };
                    delete copy.size;
                    delete copy.priority;
                    return copy;
                });
            },
            clearCookies: async () => {
                await this._client.send('Storage.clearCookies', { browserContextId: contextId || undefined });
            },
            setCookies: async (cookies) => {
                await this._client.send('Storage.setCookies', { cookies, browserContextId: contextId || undefined });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geolocation'],
                    ['midi', 'midi'],
                    ['notifications', 'notifications'],
                    ['camera', 'videoCapture'],
                    ['microphone', 'audioCapture'],
                    ['background-sync', 'backgroundSync'],
                    ['ambient-light-sensor', 'sensors'],
                    ['accelerometer', 'sensors'],
                    ['gyroscope', 'sensors'],
                    ['magnetometer', 'sensors'],
                    ['accessibility-events', 'accessibilityEvents'],
                    ['clipboard-read', 'clipboardReadWrite'],
                    ['clipboard-write', 'clipboardSanitizedWrite'],
                    ['payment-handler', 'paymentHandler'],
                    // chrome-specific permissions we have.
                    ['midi-sysex', 'midiSysex'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._client.send('Browser.grantPermissions', { origin, browserContextId: contextId || undefined, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._client.send('Browser.resetPermissions', { browserContextId: contextId || undefined });
            },
            setGeolocation: async (geolocation) => {
                for (const page of await context.pages())
                    await page._delegate._client.send('Emulation.setGeolocationOverride', geolocation || {});
            }
        }, options);
        return context;
    }
    async newContext(options = {}) {
        browserContext_1.BrowserContext.validateOptions(options);
        const { browserContextId } = await this._client.send('Target.createBrowserContext');
        const context = this._createBrowserContext(browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _targetCreated(event) {
        const targetInfo = event.targetInfo;
        const { browserContextId } = targetInfo;
        const context = (browserContextId && this._contexts.has(browserContextId)) ? this._contexts.get(browserContextId) : this._defaultContext;
        const target = new crTarget_1.CRTarget(this, targetInfo, context, () => this._connection.createSession(targetInfo));
        helper_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');
        this._targets.set(event.targetInfo.targetId, target);
        if (target._isInitialized || await target._initializedPromise)
            this.emit(events_1.Events.CRBrowser.TargetCreated, target);
    }
    async _targetDestroyed(event) {
        const target = this._targets.get(event.targetId);
        target._initializedCallback(false);
        this._targets.delete(event.targetId);
        target._didClose();
        if (await target._initializedPromise)
            this.emit(events_1.Events.CRBrowser.TargetDestroyed, target);
    }
    _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        helper_1.assert(target, 'target should exist before targetInfoChanged');
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url())
            this.emit(events_1.Events.CRBrowser.TargetChanged, target);
    }
    async _closePage(page) {
        await this._client.send('Target.closeTarget', { targetId: crTarget_1.CRTarget.fromPage(page)._targetId });
    }
    _allTargets() {
        return Array.from(this._targets.values()).filter(target => target._isInitialized);
    }
    async waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this._allTargets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise(x => resolve = x);
        this.on(events_1.Events.CRBrowser.TargetCreated, check);
        this.on(events_1.Events.CRBrowser.TargetChanged, check);
        try {
            if (!timeout)
                return await targetPromise;
            return await helper_1.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener(events_1.Events.CRBrowser.TargetCreated, check);
            this.removeListener(events_1.Events.CRBrowser.TargetChanged, check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    async close() {
        const disconnected = new Promise(f => this._connection.once(crConnection_1.ConnectionEvents.Disconnected, f));
        await Promise.all(this.contexts().map(context => context.close()));
        this._connection.close();
        await disconnected;
    }
    browserTarget() {
        return [...this._targets.values()].find(t => t.type() === 'browser');
    }
    serviceWorker(target) {
        return target._worker();
    }
    async startTracing(page, options = {}) {
        helper_1.assert(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');
        this._tracingClient = page ? page._delegate._client : this._client;
        const defaultCategories = [
            '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame', 'toplevel',
            'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(',')
        });
    }
    async stopTracing() {
        helper_1.assert(this._tracingClient, 'Tracing was not started.');
        let fulfill;
        const contentPromise = new Promise(x => fulfill = x);
        this._tracingClient.once('Tracing.tracingComplete', event => {
            crProtocolHelper_1.readProtocolStream(this._tracingClient, event.stream, this._tracingPath).then(fulfill);
        });
        await this._tracingClient.send('Tracing.end');
        this._tracingRecording = false;
        return contentPromise;
    }
    targets(context) {
        const targets = this._allTargets();
        return context ? targets.filter(t => t.context() === context) : targets;
    }
    pageTarget(page) {
        return crTarget_1.CRTarget.fromPage(page);
    }
    isConnected() {
        return !this._connection._closed;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugProtocol = debugFunction;
    }
}
exports.CRBrowser = CRBrowser;


/***/ }),

/***/ "./src/chromium/crConnection.ts":
/*!**************************************!*\
  !*** ./src/chromium/crConnection.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
exports.ConnectionEvents = {
    Disconnected: Symbol('ConnectionEvents.Disconnected')
};
// CRPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
class CRConnection extends platform.EventEmitter {
    constructor(transport) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, 'browser', '');
        this._sessions.set('', this.rootSession);
        this._debugProtocol = platform.debug('pw:protocol');
    }
    static fromSession(session) {
        return session._connection;
    }
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    _rawSend(sessionId, message) {
        const id = ++this._lastId;
        message.id = id;
        if (sessionId)
            message.sessionId = sessionId;
        const data = JSON.stringify(message);
        this._debugProtocol('SEND ► ' + data);
        this._transport.send(data);
        return id;
    }
    async _onMessage(message) {
        this._debugProtocol('◀ RECV ' + message);
        const object = JSON.parse(message);
        if (object.id === exports.kBrowserCloseMessageId)
            return;
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new CRSession(this, object.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
                session._onClosed();
                this._sessions.delete(object.params.sessionId);
            }
        }
        const session = this._sessions.get(object.sessionId || '');
        if (session)
            session._onMessage(object);
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        for (const session of this._sessions.values())
            session._onClosed();
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(exports.ConnectionEvents.Disconnected));
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
    async createSession(targetInfo) {
        const { sessionId } = await this.rootSession.send('Target.attachToTarget', { targetId: targetInfo.targetId, flatten: true });
        return this._sessions.get(sessionId);
    }
    async createBrowserSession() {
        const { sessionId } = await this.rootSession.send('Target.attachToBrowserTarget');
        return this._sessions.get(sessionId);
    }
}
exports.CRConnection = CRConnection;
exports.CRSessionEvents = {
    Disconnected: Symbol('Events.CDPSession.Disconnected')
};
class CRSession extends platform.EventEmitter {
    constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    send(method, params) {
        if (!this._connection)
            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        const id = this._connection._rawSend(this._sessionId, { method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else {
            helper_1.assert(!object.id);
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
    async detach() {
        if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        await this._connection.rootSession.send('Target.detachFromTarget', { sessionId: this._sessionId });
    }
    _onClosed() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(exports.CRSessionEvents.Disconnected));
    }
}
exports.CRSession = CRSession;
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${object.error.data}`;
    return rewriteError(error, message);
}
function rewriteError(error, message) {
    error.message = message;
    return error;
}


/***/ }),

/***/ "./src/chromium/crCoverage.ts":
/*!************************************!*\
  !*** ./src/chromium/crCoverage.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const crExecutionContext_1 = __webpack_require__(/*! ./crExecutionContext */ "./src/chromium/crExecutionContext.ts");
class CRCoverage {
    constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
    }
    async startJSCoverage(options) {
        return await this._jsCoverage.start(options);
    }
    async stopJSCoverage() {
        return await this._jsCoverage.stop();
    }
    async startCSSCoverage(options) {
        return await this._cssCoverage.start(options);
    }
    async stopCSSCoverage() {
        return await this._cssCoverage.stop();
    }
}
exports.CRCoverage = CRCoverage;
class JSCoverage {
    constructor(client) {
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = new Set();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
    }
    async start(options = {}) {
        helper_1.assert(!this._enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptIds.clear();
        this._scriptSources.clear();
        this._eventListeners = [
            helper_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        this._client.on('Debugger.paused', () => this._client.send('Debugger.resume'));
        await Promise.all([
            this._client.send('Profiler.enable'),
            this._client.send('Profiler.startPreciseCoverage', { callCount: true, detailed: true }),
            this._client.send('Debugger.enable'),
            this._client.send('Debugger.setSkipAllPauses', { skip: true })
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._scriptIds.clear();
        this._scriptSources.clear();
    }
    async _onScriptParsed(event) {
        // Ignore playwright-injected scripts
        if (event.url === crExecutionContext_1.EVALUATION_SCRIPT_URL)
            return;
        this._scriptIds.add(event.scriptId);
        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.
        if (!event.url && !this._reportAnonymousScripts)
            return;
        try {
            const response = await this._client.send('Debugger.getScriptSource', { scriptId: event.scriptId });
            this._scriptSources.set(event.scriptId, response.scriptSource);
        }
        catch (e) {
            // This might happen if the page has already navigated away.
            helper_1.debugError(e);
        }
    }
    async stop() {
        helper_1.assert(this._enabled, 'JSCoverage is not enabled');
        this._enabled = false;
        const [profileResponse] = await Promise.all([
            this._client.send('Profiler.takePreciseCoverage'),
            this._client.send('Profiler.stopPreciseCoverage'),
            this._client.send('Profiler.disable'),
            this._client.send('Debugger.disable'),
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        for (const entry of profileResponse.result) {
            if (!this._scriptIds.has(entry.scriptId))
                continue;
            if (!entry.url && !this._reportAnonymousScripts)
                continue;
            const source = this._scriptSources.get(entry.scriptId);
            if (source)
                coverage.push({ ...entry, source });
            else
                coverage.push(entry);
        }
        return coverage;
    }
}
class CSSCoverage {
    constructor(client) {
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
    }
    async start(options = {}) {
        helper_1.assert(!this._enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
            helper_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),
            helper_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this._client.send('DOM.enable'),
            this._client.send('CSS.enable'),
            this._client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
            return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
    }
    async _onStyleSheet(event) {
        const header = event.header;
        // Ignore anonymous scripts
        if (!header.sourceURL)
            return;
        try {
            const response = await this._client.send('CSS.getStyleSheetText', { styleSheetId: header.styleSheetId });
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
        }
        catch (e) {
            // This might happen if the page has already navigated away.
            helper_1.debugError(e);
        }
    }
    async stop() {
        helper_1.assert(this._enabled, 'CSSCoverage is not enabled');
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this._client.send('CSS.disable'),
            this._client.send('DOM.disable'),
        ]);
        helper_1.helper.removeEventListeners(this._eventListeners);
        // aggregate by styleSheetId
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    // Sort points to form a valid parenthesis sequence.
    points.sort((a, b) => {
        // Sort with increasing offsets.
        if (a.offset !== b.offset)
            return a.offset - b.offset;
        // All "end" points should go before "start" points.
        if (a.type !== b.type)
            return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        // For two "start" points, the one with longer range goes first.
        if (a.type === 0)
            return bLength - aLength;
        // For two "end" points, the one with shorter range goes first.
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    // Run scanning line to intersect all ranges.
    for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results.length ? results[results.length - 1] : null;
            if (lastResult && lastResult.end === lastOffset)
                lastResult.end = point.offset;
            else
                results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
            hitCountStack.push(point.range.count);
        else
            hitCountStack.pop();
    }
    // Filter out empty ranges.
    return results.filter(range => range.end - range.start > 1);
}


/***/ }),

/***/ "./src/chromium/crExecutionContext.ts":
/*!********************************************!*\
  !*** ./src/chromium/crExecutionContext.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const crProtocolHelper_1 = __webpack_require__(/*! ./crProtocolHelper */ "./src/chromium/crProtocolHelper.ts");
const js = __webpack_require__(/*! ../javascript */ "./src/javascript.ts");
exports.EVALUATION_SCRIPT_URL = '__playwright_evaluation_script__';
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
class CRExecutionContext {
    constructor(client, contextPayload) {
        this._client = client;
        this._contextId = contextPayload.id;
    }
    async evaluate(context, returnByValue, pageFunction, ...args) {
        const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;
        if (helper_1.helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + '\n' + suffix;
            const { exceptionDetails, result: remoteObject } = await this._client.send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue,
                awaitPromise: true,
                userGesture: true
            }).catch(rewriteError);
            if (exceptionDetails)
                throw new Error('Evaluation failed: ' + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
            return returnByValue ? crProtocolHelper_1.valueFromRemoteObject(remoteObject) : context._createHandle(remoteObject);
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (e1) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText = 'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (e2) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        let callFunctionOnPromise;
        try {
            callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: functionText + '\n' + suffix + '\n',
                executionContextId: this._contextId,
                arguments: args.map(convertArgument.bind(this)),
                returnByValue,
                awaitPromise: true,
                userGesture: true
            });
        }
        catch (err) {
            if (err instanceof TypeError && err.message.startsWith('Converting circular structure to JSON'))
                err.message += ' Are you passing a nested JSHandle?';
            throw err;
        }
        const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails)
            throw new Error('Evaluation failed: ' + crProtocolHelper_1.getExceptionMessage(exceptionDetails));
        return returnByValue ? crProtocolHelper_1.valueFromRemoteObject(remoteObject) : context._createHandle(remoteObject);
        function convertArgument(arg) {
            if (typeof arg === 'bigint') // eslint-disable-line valid-typeof
                return { unserializableValue: `${arg.toString()}n` };
            if (Object.is(arg, -0))
                return { unserializableValue: '-0' };
            if (Object.is(arg, Infinity))
                return { unserializableValue: 'Infinity' };
            if (Object.is(arg, -Infinity))
                return { unserializableValue: '-Infinity' };
            if (Object.is(arg, NaN))
                return { unserializableValue: 'NaN' };
            const objectHandle = arg && (arg instanceof js.JSHandle) ? arg : null;
            if (objectHandle) {
                if (objectHandle._context !== context)
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                if (objectHandle._disposed)
                    throw new Error('JSHandle is disposed!');
                const remoteObject = toRemoteObject(objectHandle);
                if (remoteObject.unserializableValue)
                    return { unserializableValue: remoteObject.unserializableValue };
                if (!remoteObject.objectId)
                    return { value: remoteObject.value };
                return { objectId: remoteObject.objectId };
            }
            return { value: arg };
        }
        function rewriteError(error) {
            if (error.message.includes('Object reference chain is too long'))
                return { result: { type: 'undefined' } };
            if (error.message.includes('Object couldn\'t be returned by value'))
                return { result: { type: 'undefined' } };
            if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed') || error.message.endsWith('Execution context was destroyed.'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    async getProperties(handle) {
        const objectId = toRemoteObject(handle).objectId;
        if (!objectId)
            return new Map();
        const response = await this._client.send('Runtime.getProperties', {
            objectId,
            ownProperties: true
        });
        const result = new Map();
        for (const property of response.result) {
            if (!property.enumerable)
                continue;
            result.set(property.name, handle._context._createHandle(property.value));
        }
        return result;
    }
    async releaseHandle(handle) {
        await crProtocolHelper_1.releaseObject(this._client, toRemoteObject(handle));
    }
    async handleJSONValue(handle) {
        const remoteObject = toRemoteObject(handle);
        if (remoteObject.objectId) {
            const response = await this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: 'function() { return this; }',
                objectId: remoteObject.objectId,
                returnByValue: true,
                awaitPromise: true,
            });
            return crProtocolHelper_1.valueFromRemoteObject(response.result);
        }
        return crProtocolHelper_1.valueFromRemoteObject(remoteObject);
    }
    handleToString(handle, includeType) {
        const object = toRemoteObject(handle);
        if (object.objectId) {
            const type = object.subtype || object.type;
            return 'JSHandle@' + type;
        }
        return (includeType ? 'JSHandle:' : '') + crProtocolHelper_1.valueFromRemoteObject(object);
    }
}
exports.CRExecutionContext = CRExecutionContext;
function toRemoteObject(handle) {
    return handle._remoteObject;
}


/***/ }),

/***/ "./src/chromium/crInput.ts":
/*!*********************************!*\
  !*** ./src/chromium/crInput.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const input = __webpack_require__(/*! ../input */ "./src/input.ts");
function toModifiersMask(modifiers) {
    let mask = 0;
    if (modifiers.has('Alt'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Meta'))
        mask |= 4;
    if (modifiers.has('Shift'))
        mask |= 8;
    return mask;
}
class RawKeyboardImpl {
    constructor(client) {
        this._client = client;
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        await this._client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location,
            isKeypad: location === input.keypadLocation
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        await this._client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            location
        });
    }
    async sendText(text) {
        await this._client.send('Input.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(client) {
        this._client = client;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseMoved',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers)
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mousePressed',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Input.dispatchMouseEvent', {
            type: 'mouseReleased',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;


/***/ }),

/***/ "./src/chromium/crNetworkManager.ts":
/*!******************************************!*\
  !*** ./src/chromium/crNetworkManager.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const network = __webpack_require__(/*! ../network */ "./src/network.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
class CRNetworkManager {
    constructor(client, page) {
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._offline = false;
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._userCacheDisabled = false;
        this._requestIdToInterceptionId = new Map();
        this._client = client;
        this._page = page;
        this._eventListeners = this.instrumentNetworkEvents(client);
    }
    instrumentNetworkEvents(session) {
        return [
            helper_1.helper.addEventListener(session, 'Fetch.requestPaused', this._onRequestPaused.bind(this)),
            helper_1.helper.addEventListener(session, 'Fetch.authRequired', this._onAuthRequired.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.loadingFinished', this._onLoadingFinished.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.loadingFailed', this._onLoadingFailed.bind(this)),
        ];
    }
    async initialize() {
        await this._client.send('Network.enable');
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
    }
    async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
    }
    async setOfflineMode(value) {
        this._offline = value;
        await this._client.send('Network.emulateNetworkConditions', {
            offline: this._offline,
            // values of 0 remove any active throttling. crbug.com/456324#c9
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
        });
    }
    async setCacheEnabled(enabled) {
        this._userCacheDisabled = !enabled;
        await this._updateProtocolCacheDisabled();
    }
    async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
    }
    async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
            return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.enable', {
                    handleAuthRequests: true,
                    patterns: [{ urlPattern: '*' }],
                }),
            ]);
        }
        else {
            await Promise.all([
                this._updateProtocolCacheDisabled(),
                this._client.send('Fetch.disable')
            ]);
        }
    }
    async _updateProtocolCacheDisabled() {
        await this._client.send('Network.setCacheDisabled', {
            cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled
        });
    }
    _onRequestWillBeSent(event) {
        // Request interception doesn't happen for data URLs with Network Service.
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {
            const requestId = event.requestId;
            const interceptionId = this._requestIdToInterceptionId.get(requestId);
            if (interceptionId) {
                this._onRequest(event, interceptionId);
                this._requestIdToInterceptionId.delete(requestId);
            }
            else {
                this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
            }
            return;
        }
        this._onRequest(event, null);
    }
    _onAuthRequired(event) {
        let response = 'Default';
        if (this._attemptedAuthentications.has(event.requestId)) {
            response = 'CancelAuth';
        }
        else if (this._credentials) {
            response = 'ProvideCredentials';
            this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || { username: undefined, password: undefined };
        this._client.send('Fetch.continueWithAuth', {
            requestId: event.requestId,
            authChallengeResponse: { response, username, password },
        }).catch(helper_1.debugError);
    }
    _onRequestPaused(event) {
        if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
            this._client.send('Fetch.continueRequest', {
                requestId: event.requestId
            }).catch(helper_1.debugError);
        }
        if (!event.networkId || event.request.url.startsWith('data:'))
            return;
        const requestId = event.networkId;
        const interceptionId = event.requestId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
            this._onRequest(requestWillBeSentEvent, interceptionId);
            this._requestIdToRequestWillBeSentEvent.delete(requestId);
        }
        else {
            this._requestIdToInterceptionId.set(requestId, interceptionId);
        }
    }
    _onRequest(event, interceptionId) {
        if (event.request.url.startsWith('data:'))
            return;
        let redirectChain = [];
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse);
                redirectChain = request.request._redirectChain;
            }
        }
        // TODO: how can frame be null here?
        const frame = event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        const isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';
        const documentId = isNavigationRequest ? event.loaderId : undefined;
        const request = new InterceptableRequest(this._client, frame, interceptionId, documentId, this._userRequestInterceptionEnabled, event, redirectChain);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _createResponse(request, responsePayload) {
        const getResponseBody = async () => {
            const response = await this._client.send('Network.getResponseBody', { requestId: request._requestId });
            return platform.Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        return new network.Response(request.request, responsePayload.status, responsePayload.statusText, headersObject(responsePayload.headers), getResponseBody);
    }
    _handleRequestRedirect(request, responsePayload) {
        const response = this._createResponse(request, responsePayload);
        request.request._redirectChain.push(request.request);
        response._requestFinished(new Error('Response body is unavailable for redirect responses'));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestFinished(request.request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
            this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
    }
}
exports.CRNetworkManager = CRNetworkManager;
class InterceptableRequest {
    constructor(client, frame, interceptionId, documentId, allowInterception, event, redirectChain) {
        this._client = client;
        this._requestId = event.requestId;
        this._interceptionId = interceptionId;
        this._documentId = documentId;
        this.request = new network.Request(allowInterception ? this : null, frame, redirectChain, documentId, event.request.url, (event.type || '').toLowerCase(), event.request.method, event.request.postData, headersObject(event.request.headers));
    }
    async continue(overrides = {}) {
        await this._client.send('Fetch.continueRequest', {
            requestId: this._interceptionId,
            headers: overrides.headers ? headersArray(overrides.headers) : undefined,
            method: overrides.method,
            postData: overrides.postData
        }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
    async fulfill(response) {
        const responseBody = response.body && helper_1.helper.isString(response.body) ? platform.Buffer.from(response.body) : (response.body || null);
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = response.headers[header];
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(platform.Buffer.byteLength(responseBody));
        await this._client.send('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: response.status || 200,
            responsePhrase: network.STATUS_TEXTS[String(response.status || 200)],
            responseHeaders: headersArray(responseHeaders),
            body: responseBody ? responseBody.toString('base64') : undefined,
        }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
    async abort(errorCode = 'failed') {
        const errorReason = errorReasons[errorCode];
        helper_1.assert(errorReason, 'Unknown error code: ' + errorCode);
        await this._client.send('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason
        }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
}
const errorReasons = {
    'aborted': 'Aborted',
    'accessdenied': 'AccessDenied',
    'addressunreachable': 'AddressUnreachable',
    'blockedbyclient': 'BlockedByClient',
    'blockedbyresponse': 'BlockedByResponse',
    'connectionaborted': 'ConnectionAborted',
    'connectionclosed': 'ConnectionClosed',
    'connectionfailed': 'ConnectionFailed',
    'connectionrefused': 'ConnectionRefused',
    'connectionreset': 'ConnectionReset',
    'internetdisconnected': 'InternetDisconnected',
    'namenotresolved': 'NameNotResolved',
    'timedout': 'TimedOut',
    'failed': 'Failed',
};
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        if (!Object.is(headers[name], undefined))
            result.push({ name, value: headers[name] + '' });
    }
    return result;
}
function headersObject(headers) {
    const result = {};
    for (const key of Object.keys(headers))
        result[key.toLowerCase()] = headers[key];
    return result;
}


/***/ }),

/***/ "./src/chromium/crPage.ts":
/*!********************************!*\
  !*** ./src/chromium/crPage.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const dom = __webpack_require__(/*! ../dom */ "./src/dom.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const crConnection_1 = __webpack_require__(/*! ./crConnection */ "./src/chromium/crConnection.ts");
const crExecutionContext_1 = __webpack_require__(/*! ./crExecutionContext */ "./src/chromium/crExecutionContext.ts");
const crNetworkManager_1 = __webpack_require__(/*! ./crNetworkManager */ "./src/chromium/crNetworkManager.ts");
const page_1 = __webpack_require__(/*! ../page */ "./src/page.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const crProtocolHelper_1 = __webpack_require__(/*! ./crProtocolHelper */ "./src/chromium/crProtocolHelper.ts");
const dialog = __webpack_require__(/*! ../dialog */ "./src/dialog.ts");
const crInput_1 = __webpack_require__(/*! ./crInput */ "./src/chromium/crInput.ts");
const crAccessibility_1 = __webpack_require__(/*! ./crAccessibility */ "./src/chromium/crAccessibility.ts");
const crCoverage_1 = __webpack_require__(/*! ./crCoverage */ "./src/chromium/crCoverage.ts");
const crPdf_1 = __webpack_require__(/*! ./crPdf */ "./src/chromium/crPdf.ts");
const console_1 = __webpack_require__(/*! ../console */ "./src/console.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const crTarget_1 = __webpack_require__(/*! ./crTarget */ "./src/chromium/crTarget.ts");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
class CRPage {
    constructor(client, browser, browserContext) {
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client = client;
        this._browser = browser;
        this.rawKeyboard = new crInput_1.RawKeyboardImpl(client);
        this.rawMouse = new crInput_1.RawMouseImpl(client);
        this._pdf = new crPdf_1.CRPDF(client);
        this._coverage = new crCoverage_1.CRCoverage(client);
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new crNetworkManager_1.CRNetworkManager(client, this._page);
        this._eventListeners = [
            helper_1.helper.addEventListener(client, 'Inspector.targetCrashed', event => this._onTargetCrashed()),
            helper_1.helper.addEventListener(client, 'Log.entryAdded', event => this._onLogEntryAdded(event)),
            helper_1.helper.addEventListener(client, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(client, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(client, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)),
            helper_1.helper.addEventListener(client, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(client, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(client, 'Page.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)),
            helper_1.helper.addEventListener(client, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(client, 'Runtime.bindingCalled', event => this._onBindingCalled(event)),
            helper_1.helper.addEventListener(client, 'Runtime.consoleAPICalled', event => this._onConsoleAPI(event)),
            helper_1.helper.addEventListener(client, 'Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextsCleared', event => this._onExecutionContextsCleared()),
            helper_1.helper.addEventListener(client, 'Target.attachedToTarget', event => this._onAttachedToTarget(event)),
            helper_1.helper.addEventListener(client, 'Target.detachedFromTarget', event => this._onDetachedFromTarget(event)),
        ];
    }
    async initialize() {
        const [, { frameTree }] = await Promise.all([
            this._client.send('Page.enable'),
            this._client.send('Page.getFrameTree'),
        ]);
        this._handleFrameTree(frameTree);
        const promises = [
            this._client.send('Log.enable', {}),
            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
            this._client.send('Runtime.enable', {}).then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
            this._networkManager.initialize(),
            this._client.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }),
            this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }),
        ];
        const options = this._page.context()._options;
        if (options.bypassCSP)
            promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
        if (options.ignoreHTTPSErrors)
            promises.push(this._client.send('Security.setIgnoreCertificateErrors', { ignore: true }));
        if (options.viewport)
            promises.push(this._updateViewport(true /* updateTouch */));
        if (options.javaScriptEnabled === false)
            promises.push(this._client.send('Emulation.setScriptExecutionDisabled', { value: true }));
        if (options.userAgent || options.locale)
            promises.push(this._client.send('Emulation.setUserAgentOverride', { userAgent: options.userAgent || '', acceptLanguage: options.locale }));
        if (options.timezoneId)
            promises.push(emulateTimezone(this._client, options.timezoneId));
        if (options.geolocation)
            promises.push(this._client.send('Emulation.setGeolocationOverride', options.geolocation));
        await Promise.all(promises);
    }
    didClose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referrer) {
        const response = await this._client.send('Page.navigate', { url, referrer, frameId: frame._id });
        if (response.errorText)
            throw new Error(`${response.errorText} at ${url}`);
        return { newDocumentId: response.loaderId };
    }
    _onLifecycleEvent(event) {
        if (event.name === 'load')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');
        else if (event.name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    page() {
        return this._page;
    }
    _onFrameAttached(frameId, parentFrameId) {
        this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);
    }
    async _ensureIsolatedWorld(name) {
        if (this._isolatedWorlds.has(name))
            return;
        this._isolatedWorlds.add(name);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `//# sourceURL=${crExecutionContext_1.EVALUATION_SCRIPT_URL}`,
            worldName: name,
        });
        await Promise.all(this._page.frames().map(frame => this._client.send('Page.createIsolatedWorld', {
            frameId: frame._id,
            grantUniveralAccess: true,
            worldName: name,
        }).catch(helper_1.debugError))); // frames might be removed before we send this
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
    }
    _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame)
            return;
        if (contextPayload.auxData && contextPayload.auxData.type === 'isolated')
            this._isolatedWorlds.add(contextPayload.name);
        const delegate = new crExecutionContext_1.CRExecutionContext(this._client, contextPayload);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
            frame._contextCreated('main', context);
        else if (contextPayload.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        this._contextIdToContext.set(contextPayload.id, context);
    }
    _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
            this._onExecutionContextDestroyed(contextId);
    }
    _onAttachedToTarget(event) {
        const session = crConnection_1.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type !== 'worker') {
            // Ideally, detaching should resume any target, but there is a bug in the backend.
            session.send('Runtime.runIfWaitingForDebugger').catch(helper_1.debugError).then(() => {
                this._client.send('Target.detachFromTarget', { sessionId: event.sessionId }).catch(helper_1.debugError);
            });
            return;
        }
        const url = event.targetInfo.url;
        const worker = new page_1.Worker(url);
        this._page._addWorker(event.sessionId, worker);
        session.once('Runtime.executionContextCreated', async (event) => {
            worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        Promise.all([
            session.send('Runtime.enable'),
            session.send('Network.enable'),
            session.send('Runtime.runIfWaitingForDebugger'),
        ]).catch(helper_1.debugError); // This might fail if the target is closed before we initialize.
        session.on('Runtime.consoleAPICalled', event => {
            const args = event.args.map(o => worker._existingExecutionContext._createHandle(o));
            this._page._addConsoleMessage(event.type, args, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
        });
        session.on('Runtime.exceptionThrown', exception => this._page.emit(events_1.Events.Page.PageError, crProtocolHelper_1.exceptionToError(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session);
    }
    _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
    }
    async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Playwright clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/GoogleChrome/puppeteer/issues/3865
            return;
        }
        const context = this._contextIdToContext.get(event.executionContextId);
        const values = event.args.map(arg => context._createHandle(arg));
        this._page._addConsoleMessage(event.type, values, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
    }
    async exposeBinding(name, bindingFunction) {
        await this._client.send('Runtime.addBinding', { name: name });
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: bindingFunction });
        await Promise.all(this._page.frames().map(frame => frame.evaluate(bindingFunction).catch(helper_1.debugError)));
    }
    _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        this._page._onBindingCalled(event.payload, context);
    }
    _onDialog(event) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(event.type, event.message, async (accept, promptText) => {
            await this._client.send('Page.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    _handleException(exceptionDetails) {
        this._page.emit(events_1.Events.Page.PageError, crProtocolHelper_1.exceptionToError(exceptionDetails));
    }
    _onTargetCrashed() {
        this._page._didCrash();
    }
    _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
            args.map(arg => crProtocolHelper_1.releaseObject(this._client, arg));
        if (source !== 'worker')
            this._page.emit(events_1.Events.Page.Console, new console_1.ConsoleMessage(level, text, [], { url, lineNumber }));
    }
    async _onFileChooserOpened(event) {
        const frame = this._page._frameManager.frame(event.frameId);
        const utilityContext = await frame._utilityContext();
        const handle = await this.adoptBackendNodeId(event.backendNodeId, utilityContext);
        this._page._onFileChooserOpened(handle);
    }
    async setExtraHTTPHeaders(headers) {
        await this._client.send('Network.setExtraHTTPHeaders', { headers });
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._updateViewport(false /* updateTouch */);
    }
    async _updateViewport(updateTouch) {
        let viewport = this._page.context()._options.viewport || { width: 0, height: 0 };
        const viewportSize = this._page._state.viewportSize;
        if (viewportSize)
            viewport = { ...viewport, ...viewportSize };
        const isLandscape = viewport.width > viewport.height;
        const promises = [
            this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile: !!viewport.isMobile,
                width: viewport.width,
                height: viewport.height,
                deviceScaleFactor: viewport.deviceScaleFactor || 1,
                screenOrientation: isLandscape ? { angle: 90, type: 'landscapePrimary' } : { angle: 0, type: 'portraitPrimary' },
            }),
        ];
        if (updateTouch)
            promises.push(this._client.send('Emulation.setTouchEmulationEnabled', { enabled: !!viewport.isMobile }));
        await Promise.all(promises);
    }
    async setEmulateMedia(mediaType, colorScheme) {
        const features = colorScheme ? [{ name: 'prefers-color-scheme', value: colorScheme }] : [];
        await this._client.send('Emulation.setEmulatedMedia', { media: mediaType || '', features });
    }
    setCacheEnabled(enabled) {
        return this._networkManager.setCacheEnabled(enabled);
    }
    async setRequestInterception(enabled) {
        await this._networkManager.setRequestInterception(enabled);
    }
    async setOfflineMode(value) {
        await this._networkManager.setOfflineMode(value);
    }
    async authenticate(credentials) {
        await this._networkManager.authenticate(credentials);
    }
    async setFileChooserIntercepted(enabled) {
        await this._client.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        const openerTarget = crTarget_1.CRTarget.fromPage(this._page).opener();
        if (!openerTarget)
            return null;
        return await openerTarget.page();
    }
    async reload() {
        await this._client.send('Page.reload');
    }
    async _go(delta) {
        const history = await this._client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
            return false;
        await this._client.send('Page.navigateToHistoryEntry', { entryId: entry.id });
        return true;
    }
    goBack() {
        return this._go(-1);
    }
    goForward() {
        return this._go(+1);
    }
    async evaluateOnNewDocument(source) {
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source });
    }
    async closePage(runBeforeUnload) {
        if (runBeforeUnload)
            await this._client.send('Page.close');
        else
            await this._browser._closePage(this._page);
    }
    async getBoundingBoxForScreenshot(handle) {
        const rect = await handle.boundingBox();
        if (!rect)
            return rect;
        const { layoutViewport: { pageX, pageY } } = await this._client.send('Page.getLayoutMetrics');
        rect.x += pageX;
        rect.y += pageY;
        return rect;
    }
    canScreenshotOutsideViewport() {
        return false;
    }
    async setBackgroundColor(color) {
        await this._client.send('Emulation.setDefaultBackgroundColorOverride', { color });
    }
    async takeScreenshot(format, options, viewportSize) {
        await this._client.send('Page.bringToFront', {});
        const clip = options.clip ? { ...options.clip, scale: 1 } : undefined;
        const result = await this._client.send('Page.captureScreenshot', { format, quality: options.quality, clip });
        return platform.Buffer.from(result.data, 'base64');
    }
    async resetViewport() {
        await this._client.send('Emulation.setDeviceMetricsOverride', { mobile: false, width: 0, height: 0, deviceScaleFactor: 0 });
    }
    async getContentFrame(handle) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId
        });
        if (!nodeInfo || typeof nodeInfo.node.frameId !== 'string')
            return null;
        return this._page._frameManager.frame(nodeInfo.node.frameId);
    }
    async getOwnerFrame(handle) {
        // document.documentElement has frameId of the owner frame.
        const documentElement = await handle.evaluateHandle(node => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
                return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
        });
        if (!documentElement)
            return null;
        const remoteObject = toRemoteObject(documentElement);
        if (!remoteObject.objectId)
            return null;
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: remoteObject.objectId
        });
        const frameId = nodeInfo && typeof nodeInfo.node.frameId === 'string' ?
            nodeInfo.node.frameId : null;
        await documentElement.dispose();
        return frameId;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const result = await this._client.send('DOM.getBoxModel', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x, y, width, height };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._client.send('DOM.scrollIntoViewIfNeeded', {
            objectId: toRemoteObject(handle).objectId,
            rect,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                e.message = 'Node is either not visible or not an HTMLElement';
            throw e;
        });
    }
    async getContentQuads(handle) {
        const result = await this._client.send('DOM.getContentQuads', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] }
        ]);
    }
    async layoutViewport() {
        const layoutMetrics = await this._client.send('Page.getLayoutMetrics');
        return { width: layoutMetrics.layoutViewport.clientWidth, height: layoutMetrics.layoutViewport.clientHeight };
    }
    async setInputFiles(handle, files) {
        await handle.evaluate(dom.setFileInputFunction, files);
    }
    async adoptElementHandle(handle, to) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId,
        });
        return this.adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
    }
    async adoptBackendNodeId(backendNodeId, to) {
        const result = await this._client.send('DOM.resolveNode', {
            backendNodeId,
            executionContextId: to._delegate._contextId,
        }).catch(helper_1.debugError);
        if (!result || result.object.subtype === 'null')
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.object).asElement();
    }
    async getAccessibilityTree(needle) {
        return crAccessibility_1.getAccessibilityTree(this._client, needle);
    }
    async pdf(options) {
        return this._pdf.generate(options);
    }
    coverage() {
        return this._coverage;
    }
    async getFrameElement(frame) {
        const { backendNodeId } = await this._client.send('DOM.getFrameOwner', { frameId: frame._id }).catch(e => {
            if (e instanceof Error && e.message.includes('Frame with the given id was not found.'))
                e.message = 'Frame has been detached.';
            throw e;
        });
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        return this.adoptBackendNodeId(backendNodeId, await parent._mainContext());
    }
}
exports.CRPage = CRPage;
function toRemoteObject(handle) {
    return handle._remoteObject;
}
async function emulateTimezone(session, timezoneId) {
    try {
        await session.send('Emulation.setTimezoneOverride', { timezoneId: timezoneId });
    }
    catch (exception) {
        if (exception.message.includes('Invalid timezone'))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
        throw exception;
    }
}


/***/ }),

/***/ "./src/chromium/crPdf.ts":
/*!*******************************!*\
  !*** ./src/chromium/crPdf.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const crProtocolHelper_1 = __webpack_require__(/*! ./crProtocolHelper */ "./src/chromium/crProtocolHelper.ts");
const PagePaperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 },
};
const unitToPixels = {
    'px': 1,
    'in': 96,
    'cm': 37.8,
    'mm': 3.78
};
function convertPrintParameterToInches(parameter) {
    if (typeof parameter === 'undefined')
        return undefined;
    let pixels;
    if (helper_1.helper.isNumber(parameter)) {
        // Treat numbers as pixel values to be aligned with phantom's paperSize.
        pixels = parameter;
    }
    else if (helper_1.helper.isString(parameter)) {
        const text = parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = '';
        if (unitToPixels.hasOwnProperty(unit)) {
            valueText = text.substring(0, text.length - 2);
        }
        else {
            // In case of unknown unit try to parse the whole parameter as number of pixels.
            // This is consistent with phantom's paperSize behavior.
            unit = 'px';
            valueText = text;
        }
        const value = Number(valueText);
        helper_1.assert(!isNaN(value), 'Failed to parse parameter value: ' + text);
        pixels = value * unitToPixels[unit];
    }
    else {
        throw new Error('page.pdf() Cannot handle parameter type: ' + (typeof parameter));
    }
    return pixels / 96;
}
class CRPDF {
    constructor(client) {
        this._client = client;
    }
    async generate(options = {}) {
        const { scale = 1, displayHeaderFooter = false, headerTemplate = '', footerTemplate = '', printBackground = false, landscape = false, pageRanges = '', preferCSSPageSize = false, margin = {}, path = null } = options;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options.format) {
            const format = PagePaperFormats[options.format.toLowerCase()];
            helper_1.assert(format, 'Unknown paper format: ' + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
        }
        else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
        });
        return await crProtocolHelper_1.readProtocolStream(this._client, result.stream, path);
    }
}
exports.CRPDF = CRPDF;


/***/ }),

/***/ "./src/chromium/crProtocolHelper.ts":
/*!******************************************!*\
  !*** ./src/chromium/crProtocolHelper.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
function getExceptionMessage(exceptionDetails) {
    if (exceptionDetails.exception)
        return exceptionDetails.exception.description || exceptionDetails.exception.value;
    let message = exceptionDetails.text;
    if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;
            const functionName = callframe.functionName || '<anonymous>';
            message += `\n    at ${functionName} (${location})`;
        }
    }
    return message;
}
exports.getExceptionMessage = getExceptionMessage;
function valueFromRemoteObject(remoteObject) {
    helper_1.assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.unserializableValue) {
        if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined')
            return BigInt(remoteObject.unserializableValue.replace('n', ''));
        switch (remoteObject.unserializableValue) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);
        }
    }
    return remoteObject.value;
}
exports.valueFromRemoteObject = valueFromRemoteObject;
async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId)
        return;
    await client.send('Runtime.releaseObject', { objectId: remoteObject.objectId }).catch(error => {
        // Exceptions might happen in case of a page been navigated or closed.
        // Swallow these since they are harmless and we don't leak anything in this case.
        helper_1.debugError(error);
    });
}
exports.releaseObject = releaseObject;
async function readProtocolStream(client, handle, path) {
    let eof = false;
    let fd;
    if (path)
        fd = await platform.openFdAsync(path, 'w');
    const bufs = [];
    while (!eof) {
        const response = await client.send('IO.read', { handle });
        eof = response.eof;
        const buf = platform.Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);
        bufs.push(buf);
        if (path)
            await platform.writeFdAsync(fd, buf);
    }
    if (path)
        await platform.closeFdAsync(fd);
    await client.send('IO.close', { handle });
    let resultBuffer = null;
    try {
        resultBuffer = platform.Buffer.concat(bufs);
    }
    finally {
        return resultBuffer;
    }
}
exports.readProtocolStream = readProtocolStream;
function toConsoleMessageLocation(stackTrace) {
    return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber,
    } : {};
}
exports.toConsoleMessageLocation = toConsoleMessageLocation;
function exceptionToError(exceptionDetails) {
    const message = getExceptionMessage(exceptionDetails);
    const err = new Error(message);
    // Don't report clientside error with a node stack attached
    err.stack = 'Error: ' + err.message; // Stack is supposed to contain error message as the first line.
    return err;
}
exports.exceptionToError = exceptionToError;


/***/ }),

/***/ "./src/chromium/crTarget.ts":
/*!**********************************!*\
  !*** ./src/chromium/crTarget.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crConnection_1 = __webpack_require__(/*! ./crConnection */ "./src/chromium/crConnection.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const page_1 = __webpack_require__(/*! ../page */ "./src/page.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const crPage_1 = __webpack_require__(/*! ./crPage */ "./src/chromium/crPage.ts");
const crExecutionContext_1 = __webpack_require__(/*! ./crExecutionContext */ "./src/chromium/crExecutionContext.ts");
const targetSymbol = Symbol('target');
class CRTarget {
    constructor(browser, targetInfo, browserContext, sessionFactory) {
        this._pagePromise = null;
        this._crPage = null;
        this._workerPromise = null;
        this._initializedCallback = () => { };
        this._targetInfo = targetInfo;
        this._browser = browser;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._initializedPromise = new Promise(fulfill => this._initializedCallback = fulfill).then(async (success) => {
            if (!success)
                return false;
            const opener = this.opener();
            if (!opener || !opener._pagePromise || this.type() !== 'page')
                return true;
            const openerPage = await opener._pagePromise;
            if (!openerPage.listenerCount(events_1.Events.Page.Popup))
                return true;
            const popupPage = await this.page();
            openerPage.emit(events_1.Events.Page.Popup, popupPage);
            return true;
        });
        this._isInitialized = this._targetInfo.type !== 'page' || this._targetInfo.url !== '';
        if (this._isInitialized)
            this._initializedCallback(true);
    }
    static fromPage(page) {
        return page[targetSymbol];
    }
    _didClose() {
        if (this._crPage)
            this._crPage.didClose();
    }
    async page() {
        if ((this._targetInfo.type === 'page' || this._targetInfo.type === 'background_page') && !this._pagePromise) {
            this._pagePromise = this._sessionFactory().then(async (client) => {
                this._crPage = new crPage_1.CRPage(client, this._browser, this._browserContext);
                const page = this._crPage.page();
                page[targetSymbol] = this;
                client.once(crConnection_1.CRSessionEvents.Disconnected, () => page._didDisconnect());
                await this._crPage.initialize();
                return page;
            });
        }
        return this._pagePromise;
    }
    async _worker() {
        if (this._targetInfo.type !== 'service_worker' && this._targetInfo.type !== 'shared_worker')
            return null;
        if (!this._workerPromise) {
            // TODO(einbinder): Make workers send their console logs.
            this._workerPromise = this._sessionFactory().then(session => {
                const worker = new page_1.Worker(this._targetInfo.url);
                session.once('Runtime.executionContextCreated', async (event) => {
                    worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
                });
                // This might fail if the target is closed before we recieve all execution contexts.
                session.send('Runtime.enable', {}).catch(helper_1.debugError);
                return worker;
            });
        }
        return this._workerPromise;
    }
    url() {
        return this._targetInfo.url;
    }
    type() {
        const type = this._targetInfo.type;
        if (type === 'page' || type === 'background_page' || type === 'service_worker' || type === 'shared_worker' || type === 'browser')
            return type;
        return 'other';
    }
    context() {
        return this._browserContext;
    }
    opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
            return null;
        return this._browser._targets.get(openerId);
    }
    createCDPSession() {
        return this._sessionFactory();
    }
    _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized && (this._targetInfo.type !== 'page' || this._targetInfo.url !== '')) {
            this._isInitialized = true;
            this._initializedCallback(true);
            return;
        }
    }
}
exports.CRTarget = CRTarget;


/***/ }),

/***/ "./src/chromium/events.ts":
/*!********************************!*\
  !*** ./src/chromium/events.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = {
    CRBrowser: {
        TargetCreated: 'targetcreated',
        TargetDestroyed: 'targetdestroyed',
        TargetChanged: 'targetchanged',
    }
};


/***/ }),

/***/ "./src/console.ts":
/*!************************!*\
  !*** ./src/console.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class ConsoleMessage {
    constructor(type, text, args, location) {
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location || {};
    }
    type() {
        return this._type;
    }
    text() {
        if (this._text === undefined)
            this._text = this._args.map(arg => arg._context._delegate.handleToString(arg, false /* includeType */)).join(' ');
        return this._text;
    }
    args() {
        return this._args;
    }
    location() {
        return this._location;
    }
}
exports.ConsoleMessage = ConsoleMessage;


/***/ }),

/***/ "./src/dialog.ts":
/*!***********************!*\
  !*** ./src/dialog.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
class Dialog {
    constructor(type, message, onHandle, defaultValue) {
        this._handled = false;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || '';
    }
    type() {
        return this._type;
    }
    message() {
        return this._message;
    }
    defaultValue() {
        return this._defaultValue;
    }
    async accept(promptText) {
        helper_1.assert(!this._handled, 'Cannot accept dialog which is already handled!');
        this._handled = true;
        await this._onHandle(true, promptText);
    }
    async dismiss() {
        helper_1.assert(!this._handled, 'Cannot dismiss dialog which is already handled!');
        this._handled = true;
        await this._onHandle(false);
    }
}
exports.Dialog = Dialog;


/***/ }),

/***/ "./src/dom.ts":
/*!********************!*\
  !*** ./src/dom.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js = __webpack_require__(/*! ./javascript */ "./src/javascript.ts");
const injectedSource = __webpack_require__(/*! ./generated/injectedSource */ "./src/generated/injectedSource.ts");
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
const selectors_1 = __webpack_require__(/*! ./selectors */ "./src/selectors.ts");
class FrameExecutionContext extends js.ExecutionContext {
    constructor(delegate, frame) {
        super(delegate);
        this._injectedGeneration = -1;
        this.frame = frame;
    }
    async _evaluate(returnByValue, pageFunction, ...args) {
        const needsAdoption = (value) => {
            return typeof value === 'object' && value instanceof ElementHandle && value._context !== this;
        };
        if (!args.some(needsAdoption)) {
            // Only go through asynchronous calls if required.
            return this._delegate.evaluate(this, returnByValue, pageFunction, ...args);
        }
        const toDispose = [];
        const adopted = await Promise.all(args.map(async (arg) => {
            if (!needsAdoption(arg))
                return arg;
            const adopted = this.frame._page._delegate.adoptElementHandle(arg, this);
            toDispose.push(adopted);
            return adopted;
        }));
        let result;
        try {
            result = await this._delegate.evaluate(this, returnByValue, pageFunction, ...adopted);
        }
        finally {
            await Promise.all(toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose())));
        }
        return result;
    }
    _createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
            return new ElementHandle(this, remoteObject);
        return super._createHandle(remoteObject);
    }
    _injected() {
        const selectors = selectors_1.Selectors._instance();
        if (this._injectedPromise && selectors._generation !== this._injectedGeneration) {
            this._injectedPromise.then(handle => handle.dispose());
            this._injectedPromise = undefined;
        }
        if (!this._injectedPromise) {
            const source = `
        new (${injectedSource.source})([
          ${selectors._sources.join(',\n')}
        ])
      `;
            this._injectedPromise = this.evaluateHandle(source);
            this._injectedGeneration = selectors._generation;
        }
        return this._injectedPromise;
    }
    async _$(selector, scope) {
        const handle = await this.evaluateHandle((injected, selector, scope) => injected.querySelector(selector, scope || document), await this._injected(), normalizeSelector(selector), scope);
        if (!handle.asElement())
            await handle.dispose();
        return handle.asElement();
    }
    async _$array(selector, scope) {
        const arrayHandle = await this.evaluateHandle((injected, selector, scope) => injected.querySelectorAll(selector, scope || document), await this._injected(), normalizeSelector(selector), scope);
        return arrayHandle;
    }
    async _$$(selector, scope) {
        const arrayHandle = await this._$array(selector, scope);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
            else
                await property.dispose();
        }
        return result;
    }
}
exports.FrameExecutionContext = FrameExecutionContext;
class ElementHandle extends js.JSHandle {
    constructor(context, remoteObject) {
        super(context, remoteObject);
        this._evaluateInUtility = async (pageFunction, ...args) => {
            const utility = await this._context.frame._utilityContext();
            return utility.evaluate(pageFunction, this, ...args);
        };
        this.$eval = async (selector, pageFunction, ...args) => {
            const elementHandle = await this._context._$(selector, this);
            if (!elementHandle)
                throw new Error(`Error: failed to find element matching selector "${selector}"`);
            const result = await elementHandle.evaluate(pageFunction, ...args);
            await elementHandle.dispose();
            return result;
        };
        this.$$eval = async (selector, pageFunction, ...args) => {
            const arrayHandle = await this._context._$array(selector, this);
            const result = await arrayHandle.evaluate(pageFunction, ...args);
            await arrayHandle.dispose();
            return result;
        };
        this._context = context;
        this._page = context.frame._page;
    }
    asElement() {
        return this;
    }
    async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
            return null;
        const pages = this._page.context()._existingPages();
        for (const page of pages) {
            const frame = page._frameManager.frame(frameId);
            if (frame)
                return frame;
        }
        return null;
    }
    async contentFrame() {
        const isFrameElement = await this._evaluateInUtility(node => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'));
        if (!isFrameElement)
            return null;
        return this._page._delegate.getContentFrame(this);
    }
    async _scrollRectIntoViewIfNeeded(rect) {
        await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
    }
    async scrollIntoViewIfNeeded() {
        await this._scrollRectIntoViewIfNeeded();
    }
    async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
            return quad.map(point => ({
                x: Math.min(Math.max(point.x, 0), metrics.width),
                y: Math.min(Math.max(point.y, 0), metrics.height),
            }));
        };
        const computeQuadArea = (quad) => {
            // Compute sum of all directed areas of adjacent triangles
            // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
                const p1 = quad[i];
                const p2 = quad[(i + 1) % quad.length];
                area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
            this._page._delegate.getContentQuads(this),
            this._page._delegate.layoutViewport(),
        ]);
        if (!quads || !quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 1);
        if (!filtered.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Return the middle point of the first quad.
        const result = { x: 0, y: 0 };
        for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
        }
        return result;
    }
    async _relativePoint(relativePoint) {
        const [box, border] = await Promise.all([
            this.boundingBox(),
            this._evaluateInUtility((node) => {
                if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)
                    return { x: 0, y: 0 };
                const style = node.ownerDocument.defaultView.getComputedStyle(node);
                return { x: parseInt(style.borderLeftWidth || '', 10), y: parseInt(style.borderTopWidth || '', 10) };
            }).catch(helper_1.debugError),
        ]);
        const point = { x: relativePoint.x, y: relativePoint.y };
        if (box) {
            point.x += box.x;
            point.y += box.y;
        }
        if (border) {
            // Make point relative to the padding box to align with offsetX/offsetY.
            point.x += border.x;
            point.y += border.y;
        }
        return point;
    }
    async _performPointerAction(action, options) {
        const relativePoint = options ? options.relativePoint : undefined;
        await this._scrollRectIntoViewIfNeeded(relativePoint ? { x: relativePoint.x, y: relativePoint.y, width: 0, height: 0 } : undefined);
        const point = relativePoint ? await this._relativePoint(relativePoint) : await this._clickablePoint();
        let restoreModifiers;
        if (options && options.modifiers)
            restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
        await action(point);
        if (restoreModifiers)
            await this._page.keyboard._ensureModifiers(restoreModifiers);
    }
    hover(options) {
        return this._performPointerAction(point => this._page.mouse.move(point.x, point.y), options);
    }
    click(options) {
        return this._performPointerAction(point => this._page.mouse.click(point.x, point.y, options), options);
    }
    dblclick(options) {
        return this._performPointerAction(point => this._page.mouse.dblclick(point.x, point.y, options), options);
    }
    tripleclick(options) {
        return this._performPointerAction(point => this._page.mouse.tripleclick(point.x, point.y, options), options);
    }
    async select(...values) {
        const options = values.map(value => typeof value === 'object' ? value : { value });
        for (const option of options) {
            if (option instanceof ElementHandle)
                continue;
            if (option.value !== undefined)
                helper_1.assert(helper_1.helper.isString(option.value), 'Values must be strings. Found value "' + option.value + '" of type "' + (typeof option.value) + '"');
            if (option.label !== undefined)
                helper_1.assert(helper_1.helper.isString(option.label), 'Labels must be strings. Found label "' + option.label + '" of type "' + (typeof option.label) + '"');
            if (option.index !== undefined)
                helper_1.assert(helper_1.helper.isNumber(option.index), 'Indices must be numbers. Found index "' + option.index + '" of type "' + (typeof option.index) + '"');
        }
        return this._evaluateInUtility((node, ...optionsToSelect) => {
            if (node.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const element = node;
            const options = Array.from(element.options);
            element.value = undefined;
            for (let index = 0; index < options.length; index++) {
                const option = options[index];
                option.selected = optionsToSelect.some(optionToSelect => {
                    if (optionToSelect instanceof Node)
                        return option === optionToSelect;
                    let matches = true;
                    if (optionToSelect.value !== undefined)
                        matches = matches && optionToSelect.value === option.value;
                    if (optionToSelect.label !== undefined)
                        matches = matches && optionToSelect.label === option.label;
                    if (optionToSelect.index !== undefined)
                        matches = matches && optionToSelect.index === index;
                    return matches;
                });
                if (option.selected && !element.multiple)
                    break;
            }
            element.dispatchEvent(new Event('input', { 'bubbles': true }));
            element.dispatchEvent(new Event('change', { 'bubbles': true }));
            return options.filter(option => option.selected).map(option => option.value);
        }, ...options);
    }
    async fill(value) {
        helper_1.assert(helper_1.helper.isString(value), 'Value must be string. Found value "' + value + '" of type "' + (typeof value) + '"');
        const error = await this._evaluateInUtility((node, value) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'Node is not of type HTMLElement';
            const element = node;
            if (!element.isConnected)
                return 'Element is not attached to the DOM';
            if (!element.ownerDocument || !element.ownerDocument.defaultView)
                return 'Element does not belong to a window';
            const style = element.ownerDocument.defaultView.getComputedStyle(element);
            if (!style || style.visibility === 'hidden')
                return 'Element is hidden';
            if (!element.offsetParent && element.tagName !== 'BODY')
                return 'Element is not visible';
            if (element.nodeName.toLowerCase() === 'input') {
                const input = element;
                const type = input.getAttribute('type') || '';
                const kTextInputTypes = new Set(['', 'email', 'number', 'password', 'search', 'tel', 'text', 'url']);
                if (!kTextInputTypes.has(type.toLowerCase()))
                    return 'Cannot fill input of type "' + type + '".';
                if (type.toLowerCase() === 'number') {
                    value = value.trim();
                    if (!value || isNaN(Number(value)))
                        return 'Cannot type text into input[type=number].';
                }
                if (input.disabled)
                    return 'Cannot fill a disabled input.';
                if (input.readOnly)
                    return 'Cannot fill a readonly input.';
                input.select();
                input.focus();
            }
            else if (element.nodeName.toLowerCase() === 'textarea') {
                const textarea = element;
                if (textarea.disabled)
                    return 'Cannot fill a disabled textarea.';
                if (textarea.readOnly)
                    return 'Cannot fill a readonly textarea.';
                textarea.selectionStart = 0;
                textarea.selectionEnd = textarea.value.length;
                textarea.focus();
            }
            else if (element.isContentEditable) {
                const range = element.ownerDocument.createRange();
                range.selectNodeContents(element);
                const selection = element.ownerDocument.defaultView.getSelection();
                if (!selection)
                    return 'Element belongs to invisible iframe.';
                selection.removeAllRanges();
                selection.addRange(range);
                element.focus();
            }
            else {
                return 'Element is not an <input>, <textarea> or [contenteditable] element.';
            }
            return false;
        }, value);
        if (error)
            throw new Error(error);
        if (value)
            await this._page.keyboard.sendCharacters(value);
        else
            await this._page.keyboard.press('Delete');
    }
    async setInputFiles(...files) {
        const multiple = await this._evaluateInUtility((node) => {
            if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== 'INPUT')
                throw new Error('Node is not an HTMLInputElement');
            const input = node;
            return input.multiple;
        });
        helper_1.assert(multiple || files.length <= 1, 'Non-multiple file input can only accept single file!');
        const filePayloads = await Promise.all(files.map(async (item) => {
            if (typeof item === 'string') {
                const file = {
                    name: platform.basename(item),
                    type: platform.getMimeType(item),
                    data: await platform.readFileAsync(item, 'base64')
                };
                return file;
            }
            return item;
        }));
        await this._page._delegate.setInputFiles(this, filePayloads);
    }
    async focus() {
        const errorMessage = await this._evaluateInUtility((element) => {
            if (!element['focus'])
                return 'Node is not an HTML or SVG element.';
            element.focus();
            return false;
        });
        if (errorMessage)
            throw new Error(errorMessage);
    }
    async type(text, options) {
        await this.focus();
        await this._page.keyboard.type(text, options);
    }
    async press(key, options) {
        await this.focus();
        await this._page.keyboard.press(key, options);
    }
    async check() {
        await this._setChecked(true);
    }
    async uncheck() {
        await this._setChecked(false);
    }
    async _setChecked(state) {
        const isCheckboxChecked = async () => {
            return this._evaluateInUtility((node) => {
                if (node.nodeType !== Node.ELEMENT_NODE)
                    throw new Error('Not a checkbox or radio button');
                let element = node;
                if (element.getAttribute('role') === 'checkbox')
                    return element.getAttribute('aria-checked') === 'true';
                if (element.nodeName === 'LABEL') {
                    const forId = element.getAttribute('for');
                    if (forId && element.ownerDocument)
                        element = element.ownerDocument.querySelector(`input[id="${forId}"]`) || undefined;
                    else
                        element = element.querySelector('input[type=checkbox],input[type=radio]') || undefined;
                }
                if (element && element.nodeName === 'INPUT') {
                    const type = element.getAttribute('type');
                    if (type && (type.toLowerCase() === 'checkbox' || type.toLowerCase() === 'radio'))
                        return element.checked;
                }
                throw new Error('Not a checkbox');
            });
        };
        if (await isCheckboxChecked() === state)
            return;
        await this.click();
        if (await isCheckboxChecked() !== state)
            throw new Error('Unable to click checkbox');
    }
    async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
    }
    async screenshot(options) {
        return this._page._screenshotter.screenshotElement(this, options);
    }
    $(selector) {
        return this._context._$(selector, this);
    }
    $$(selector) {
        return this._context._$$(selector, this);
    }
    visibleRatio() {
        return this._evaluateInUtility(async (node) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                throw new Error('Node is not of type HTMLElement');
            const element = node;
            const visibleRatio = await new Promise(resolve => {
                const observer = new IntersectionObserver(entries => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
                // Firefox doesn't call IntersectionObserver callback unless
                // there are rafs.
                requestAnimationFrame(() => { });
            });
            return visibleRatio;
        });
    }
}
exports.ElementHandle = ElementHandle;
function normalizeSelector(selector) {
    const eqIndex = selector.indexOf('=');
    if (eqIndex !== -1 && selector.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-]+$/))
        return selector;
    // If selector starts with '//' or '//' prefixed with multiple opening
    // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
    if (/^\(*\/\//.test(selector))
        return 'xpath=' + selector;
    if (selector.startsWith('"'))
        return 'text=' + selector;
    return 'css=' + selector;
}
function waitForFunctionTask(selector, pageFunction, options, ...args) {
    const { polling = 'raf' } = options;
    if (helper_1.helper.isString(polling))
        helper_1.assert(polling === 'raf' || polling === 'mutation', 'Unknown polling option: ' + polling);
    else if (helper_1.helper.isNumber(polling))
        helper_1.assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);
    else
        throw new Error('Unknown polling options: ' + polling);
    const predicateBody = helper_1.helper.isString(pageFunction) ? 'return (' + pageFunction + ')' : 'return (' + pageFunction + ')(...args)';
    if (selector !== undefined)
        selector = normalizeSelector(selector);
    return async (context) => context.evaluateHandle((injected, selector, predicateBody, polling, timeout, ...args) => {
        const innerPredicate = new Function('...args', predicateBody);
        if (polling === 'raf')
            return injected.pollRaf(selector, predicate, timeout);
        if (polling === 'mutation')
            return injected.pollMutation(selector, predicate, timeout);
        return injected.pollInterval(selector, polling, predicate, timeout);
        function predicate(element) {
            if (selector === undefined)
                return innerPredicate(...args);
            return innerPredicate(element, ...args);
        }
    }, await context._injected(), selector, predicateBody, polling, options.timeout || 0, ...args);
}
exports.waitForFunctionTask = waitForFunctionTask;
function waitForSelectorTask(selector, visibility, timeout) {
    return async (context) => {
        selector = normalizeSelector(selector);
        return context.evaluateHandle((injected, selector, visibility, timeout) => {
            if (visibility !== 'any')
                return injected.pollRaf(selector, predicate, timeout);
            return injected.pollMutation(selector, predicate, timeout);
            function predicate(element) {
                if (!element)
                    return visibility === 'hidden';
                if (visibility === 'any')
                    return element;
                return injected.isVisible(element) === (visibility === 'visible') ? element : false;
            }
        }, await context._injected(), selector, visibility, timeout);
    };
}
exports.waitForSelectorTask = waitForSelectorTask;
exports.setFileInputFunction = async (element, payloads) => {
    const files = await Promise.all(payloads.map(async (file) => {
        const result = await fetch(`data:${file.type};base64,${file.data}`);
        return new File([await result.blob()], file.name, { type: file.type });
    }));
    const dt = new DataTransfer();
    for (const file of files)
        dt.items.add(file);
    element.files = dt.files;
    element.dispatchEvent(new Event('input', { 'bubbles': true }));
};


/***/ }),

/***/ "./src/errors.ts":
/*!***********************!*\
  !*** ./src/errors.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
class TimeoutError extends CustomError {
}
exports.TimeoutError = TimeoutError;


/***/ }),

/***/ "./src/events.ts":
/*!***********************!*\
  !*** ./src/events.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = {
    Browser: {
        Disconnected: 'disconnected'
    },
    BrowserContext: {
        Close: 'close'
    },
    BrowserServer: {
        Close: 'close',
    },
    Page: {
        Close: 'close',
        Console: 'console',
        Dialog: 'dialog',
        FileChooser: 'filechooser',
        DOMContentLoaded: 'domcontentloaded',
        // Can't use just 'error' due to node.js special treatment of error events.
        // @see https://nodejs.org/api/events.html#events_error_events
        PageError: 'pageerror',
        Request: 'request',
        Response: 'response',
        RequestFailed: 'requestfailed',
        RequestFinished: 'requestfinished',
        FrameAttached: 'frameattached',
        FrameDetached: 'framedetached',
        FrameNavigated: 'framenavigated',
        Load: 'load',
        Popup: 'popup',
        WorkerCreated: 'workercreated',
        WorkerDestroyed: 'workerdestroyed',
    },
};


/***/ }),

/***/ "./src/firefox/ffAccessibility.ts":
/*!****************************************!*\
  !*** ./src/firefox/ffAccessibility.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
async function getAccessibilityTree(session, needle) {
    const objectId = needle ? needle._remoteObject.objectId : undefined;
    const { tree } = await session.send('Accessibility.getFullAXTree', { objectId });
    const axNode = new FFAXNode(tree);
    return {
        tree: axNode,
        needle: needle ? axNode._findNeedle() : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
const FFRoleToARIARole = new Map(Object.entries({
    'pushbutton': 'button',
    'checkbutton': 'checkbox',
    'editcombobox': 'combobox',
    'content deletion': 'deletion',
    'footnote': 'doc-footnote',
    'non-native document': 'document',
    'grouping': 'group',
    'graphic': 'img',
    'content insertion': 'insertion',
    'animation': 'marquee',
    'flat equation': 'math',
    'menupopup': 'menu',
    'check menu item': 'menuitemcheckbox',
    'radio menu item': 'menuitemradio',
    'listbox option': 'option',
    'radiobutton': 'radio',
    'statusbar': 'status',
    'pagetab': 'tab',
    'pagetablist': 'tablist',
    'propertypage': 'tabpanel',
    'entry': 'textbox',
    'outline': 'tree',
    'tree table': 'treegrid',
    'outlineitem': 'treeitem',
}));
class FFAXNode {
    constructor(payload) {
        this._payload = payload;
        this._children = (payload.children || []).map(x => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && (payload.tag !== 'textarea' && payload.tag !== 'input');
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
        this._cachedHasFocusableChild;
    }
    _isPlainTextField() {
        if (this._richlyEditable)
            return false;
        if (this._editable)
            return true;
        return this._role === 'entry';
    }
    _isTextOnlyObject() {
        const role = this._role;
        return (role === 'text leaf' || role === 'text' || role === 'statictext');
    }
    _hasFocusableChild() {
        if (this._cachedHasFocusableChild === undefined) {
            this._cachedHasFocusableChild = false;
            for (const child of this._children) {
                if (child._focusable || child._hasFocusableChild()) {
                    this._cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this._cachedHasFocusableChild;
    }
    children() {
        return this._children;
    }
    _findNeedle() {
        if (this._payload.foundObject)
            return this;
        for (const child of this._children) {
            const found = child._findNeedle();
            if (found)
                return found;
        }
        return null;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this._isPlainTextField() || this._isTextOnlyObject())
            return true;
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this._role) {
            case 'graphic':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
            default:
                break;
        }
        // Here and below: Android heuristics
        if (this._hasFocusableChild())
            return false;
        if (this._focusable && this._name)
            return true;
        if (this._role === 'heading' && this._name)
            return true;
        return false;
    }
    isControl() {
        switch (this._role) {
            case 'checkbutton':
            case 'check menu item':
            case 'check rich option':
            case 'combobox':
            case 'combobox option':
            case 'color chooser':
            case 'listbox':
            case 'listbox option':
            case 'listbox rich option':
            case 'popup menu':
            case 'menupopup':
            case 'menuitem':
            case 'menubar':
            case 'button':
            case 'pushbutton':
            case 'radiobutton':
            case 'radio menuitem':
            case 'scrollbar':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'pagetab':
            case 'entry':
            case 'tree table':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!this._name.trim();
    }
    serialize() {
        const node = {
            role: FFRoleToARIARole.get(this._role) || this._role,
            name: this._name || ''
        };
        const userStringProperties = [
            'name',
            'value',
            'description',
            'roledescription',
            'valuetext',
            'keyshortcuts',
        ];
        for (const userStringProperty of userStringProperties) {
            if (!(userStringProperty in this._payload))
                continue;
            node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            if (this._role === 'document' && booleanProperty === 'focused')
                continue; // document focusing is strange
            const value = this._payload[booleanProperty];
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const tristateProperties = [
            'checked',
            'pressed',
        ];
        for (const tristateProperty of tristateProperties) {
            if (!(tristateProperty in this._payload))
                continue;
            const value = this._payload[tristateProperty];
            node[tristateProperty] = value;
        }
        const numericalProperties = [
            'level'
        ];
        for (const numericalProperty of numericalProperties) {
            if (!(numericalProperty in this._payload))
                continue;
            node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = this._payload[tokenProperty];
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        return node;
    }
}


/***/ }),

/***/ "./src/firefox/ffBrowser.ts":
/*!**********************************!*\
  !*** ./src/firefox/ffBrowser.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = __webpack_require__(/*! ../browser */ "./src/browser.ts");
const browserContext_1 = __webpack_require__(/*! ../browserContext */ "./src/browserContext.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const ffConnection_1 = __webpack_require__(/*! ./ffConnection */ "./src/firefox/ffConnection.ts");
const ffPage_1 = __webpack_require__(/*! ./ffPage */ "./src/firefox/ffPage.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const transport_1 = __webpack_require__(/*! ../transport */ "./src/transport.ts");
class FFBrowser extends platform.EventEmitter {
    constructor(connection) {
        super();
        this._connection = connection;
        this._targets = new Map();
        this._defaultContext = this._createBrowserContext(null, {});
        this._contexts = new Map();
        this._connection.on(ffConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this.contexts())
                context._browserClosed();
            this.emit(events_1.Events.Browser.Disconnected);
        });
        this._eventListeners = [
            helper_1.helper.addEventListener(this._connection, 'Target.targetCreated', this._onTargetCreated.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.targetInfoChanged', this._onTargetInfoChanged.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.attachedToTarget', this._onAttachedToTarget.bind(this)),
        ];
    }
    static async connect(transport, slowMo) {
        const connection = new ffConnection_1.FFConnection(transport_1.SlowMoTransport.wrap(transport, slowMo));
        const browser = new FFBrowser(connection);
        await connection.send('Target.enable');
        return browser;
    }
    isConnected() {
        return !this._connection._closed;
    }
    async newContext(options = {}) {
        const viewport = options.viewport ? {
            viewportSize: { width: options.viewport.width, height: options.viewport.height },
            isMobile: !!options.viewport.isMobile,
            deviceScaleFactor: options.viewport.deviceScaleFactor || 1,
            hasTouch: !!options.viewport.isMobile,
        } : undefined;
        const { browserContextId } = await this._connection.send('Target.createBrowserContext', {
            userAgent: options.userAgent,
            bypassCSP: options.bypassCSP,
            javaScriptDisabled: options.javaScriptEnabled === false ? true : undefined,
            viewport,
        });
        // TODO: move ignoreHTTPSErrors to browser context level.
        if (options.ignoreHTTPSErrors)
            await this._connection.send('Browser.setIgnoreHTTPSErrors', { enabled: true });
        const context = this._createBrowserContext(browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this._allTargets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise(x => resolve = x);
        this.on('targetchanged', check);
        try {
            if (!timeout)
                return await targetPromise;
            return await helper_1.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener('targetchanged', check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    _allTargets() {
        return Array.from(this._targets.values());
    }
    async _onTargetCreated(payload) {
        const { targetId, url, browserContextId, openerId, type } = payload;
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        const target = new Target(this._connection, this, context, targetId, type, url, openerId);
        this._targets.set(targetId, target);
    }
    _onTargetDestroyed(payload) {
        const { targetId } = payload;
        const target = this._targets.get(targetId);
        this._targets.delete(targetId);
        target._didClose();
    }
    _onTargetInfoChanged(payload) {
        const { targetId, url } = payload;
        const target = this._targets.get(targetId);
        target._url = url;
    }
    async _onAttachedToTarget(payload) {
        const { targetId } = payload.targetInfo;
        const target = this._targets.get(targetId);
        target._initPagePromise(this._connection.getSession(payload.sessionId));
        const opener = target.opener();
        if (opener && opener._pagePromise) {
            const openerPage = await opener._pagePromise;
            if (openerPage.listenerCount(events_1.Events.Page.Popup)) {
                const popupPage = await target.page();
                openerPage.emit(events_1.Events.Page.Popup, popupPage);
            }
        }
    }
    async close() {
        await Promise.all(this.contexts().map(context => context.close()));
        helper_1.helper.removeEventListeners(this._eventListeners);
        const disconnected = new Promise(f => this.once(events_1.Events.Browser.Disconnected, f));
        this._connection.close();
        await disconnected;
    }
    _createBrowserContext(browserContextId, options) {
        browserContext_1.BrowserContext.validateOptions(options);
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const targets = this._allTargets().filter(target => target.context() === context && target.type() === 'page');
                const pages = await Promise.all(targets.map(target => target.page()));
                return pages.filter(page => !!page);
            },
            existingPages: () => {
                const pages = [];
                for (const target of this._allTargets()) {
                    if (target.context() === context && target._ffPage)
                        pages.push(target._ffPage._page);
                }
                return pages;
            },
            newPage: async () => {
                const { targetId } = await this._connection.send('Target.newPage', {
                    browserContextId: browserContextId || undefined
                });
                const target = this._targets.get(targetId);
                return target.page();
            },
            close: async () => {
                helper_1.assert(browserContextId, 'Non-incognito profiles cannot be closed!');
                await this._connection.send('Target.removeBrowserContext', { browserContextId });
                this._contexts.delete(browserContextId);
            },
            cookies: async () => {
                const { cookies } = await this._connection.send('Browser.getCookies', { browserContextId: browserContextId || undefined });
                return cookies.map(c => {
                    const copy = { ...c };
                    delete copy.size;
                    return copy;
                });
            },
            clearCookies: async () => {
                await this._connection.send('Browser.clearCookies', { browserContextId: browserContextId || undefined });
            },
            setCookies: async (cookies) => {
                await this._connection.send('Browser.setCookies', { browserContextId: browserContextId || undefined, cookies });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geo'],
                    ['microphone', 'microphone'],
                    ['camera', 'camera'],
                    ['notifications', 'desktop-notifications'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._connection.send('Browser.grantPermissions', { origin, browserContextId: browserContextId || undefined, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._connection.send('Browser.resetPermissions', { browserContextId: browserContextId || undefined });
            },
            setGeolocation: async (geolocation) => {
                throw new Error('Geolocation emulation is not supported in Firefox');
            }
        }, options);
        return context;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugProtocol = debugFunction;
    }
}
exports.FFBrowser = FFBrowser;
class Target {
    constructor(connection, browser, context, targetId, type, url, openerId) {
        this._ffPage = null;
        this._browser = browser;
        this._context = context;
        this._connection = connection;
        this._targetId = targetId;
        this._type = type;
        this._url = url;
        this._openerId = openerId;
    }
    _didClose() {
        if (this._ffPage)
            this._ffPage.didClose();
    }
    opener() {
        return this._openerId ? this._browser._targets.get(this._openerId) : null;
    }
    type() {
        return this._type;
    }
    url() {
        return this._url;
    }
    context() {
        return this._context;
    }
    async page() {
        if (this._type !== 'page')
            throw new Error(`Cannot create page for "${this._type}" target`);
        if (!this._pagePromise)
            await this._connection.send('Target.attachToTarget', { targetId: this._targetId });
        return this._pagePromise;
    }
    _initPagePromise(session) {
        this._pagePromise = new Promise(async (f) => {
            this._ffPage = new ffPage_1.FFPage(session, this._context, async () => {
                const openerTarget = this.opener();
                if (!openerTarget)
                    return null;
                return await openerTarget.page();
            });
            const page = this._ffPage._page;
            session.once(ffConnection_1.FFSessionEvents.Disconnected, () => page._didDisconnect());
            await this._ffPage._initialize().catch(helper_1.debugError);
            f(page);
        });
    }
    browser() {
        return this._browser;
    }
}


/***/ }),

/***/ "./src/firefox/ffConnection.ts":
/*!*************************************!*\
  !*** ./src/firefox/ffConnection.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
exports.ConnectionEvents = {
    Disconnected: Symbol('Disconnected'),
};
// FFPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
class FFConnection extends platform.EventEmitter {
    constructor(transport) {
        super();
        this._debugProtocol = platform.debug('pw:protocol');
        this._transport = transport;
        this._lastId = 0;
        this._callbacks = new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    static fromSession(session) {
        return session._connection;
    }
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    send(method, params) {
        const id = this.nextMessageId();
        this._rawSend({ id, method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    nextMessageId() {
        return ++this._lastId;
    }
    _rawSend(message) {
        message = JSON.stringify(message);
        this._debugProtocol('SEND ► ' + message);
        this._transport.send(message);
    }
    async _onMessage(message) {
        this._debugProtocol('◀ RECV ' + message);
        const object = JSON.parse(message);
        if (object.id === exports.kBrowserCloseMessageId)
            return;
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new FFSession(this, object.params.targetInfo.type, sessionId, message => this._rawSend({ ...message, sessionId }));
            this._sessions.set(sessionId, session);
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
                session._onClosed();
                this._sessions.delete(object.params.sessionId);
            }
        }
        if (object.sessionId) {
            const session = this._sessions.get(object.sessionId);
            if (session)
                session.dispatchMessage(object);
        }
        else if (object.id) {
            const callback = this._callbacks.get(object.id);
            // Callbacks could be all rejected if someone has called `.dispose()`.
            if (callback) {
                this._callbacks.delete(object.id);
                if (object.error)
                    callback.reject(createProtocolError(callback.error, callback.method, object));
                else
                    callback.resolve(object.result);
            }
        }
        else {
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        for (const session of this._sessions.values())
            session._onClosed();
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(exports.ConnectionEvents.Disconnected));
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
    getSession(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
}
exports.FFConnection = FFConnection;
exports.FFSessionEvents = {
    Disconnected: Symbol('Disconnected')
};
class FFSession extends platform.EventEmitter {
    constructor(connection, targetType, sessionId, rawSend) {
        super();
        this._disposed = false;
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    send(method, params) {
        if (this._disposed)
            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        const id = this._connection.nextMessageId();
        this._rawSend({ method, params, id });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else {
            helper_1.assert(!object.id);
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
    _onClosed() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._disposed = true;
        Promise.resolve().then(() => this.emit(exports.FFSessionEvents.Disconnected));
    }
}
exports.FFSession = FFSession;
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${object.error.data}`;
    return rewriteError(error, message);
}
function rewriteError(error, message) {
    error.message = message;
    return error;
}


/***/ }),

/***/ "./src/firefox/ffExecutionContext.ts":
/*!*******************************************!*\
  !*** ./src/firefox/ffExecutionContext.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const js = __webpack_require__(/*! ../javascript */ "./src/javascript.ts");
class FFExecutionContext {
    constructor(session, executionContextId) {
        this._session = session;
        this._executionContextId = executionContextId;
    }
    async evaluate(context, returnByValue, pageFunction, ...args) {
        if (helper_1.helper.isString(pageFunction)) {
            const payload = await this._session.send('Runtime.evaluate', {
                expression: pageFunction.trim(),
                returnByValue,
                executionContextId: this._executionContextId,
            }).catch(rewriteError);
            checkException(payload.exceptionDetails);
            if (returnByValue)
                return deserializeValue(payload.result);
            return context._createHandle(payload.result);
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (e1) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText = 'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (e2) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        const protocolArgs = args.map(arg => {
            if (arg instanceof js.JSHandle) {
                if (arg._context !== context)
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                if (arg._disposed)
                    throw new Error('JSHandle is disposed!');
                return this._toCallArgument(arg._remoteObject);
            }
            if (Object.is(arg, Infinity))
                return { unserializableValue: 'Infinity' };
            if (Object.is(arg, -Infinity))
                return { unserializableValue: '-Infinity' };
            if (Object.is(arg, -0))
                return { unserializableValue: '-0' };
            if (Object.is(arg, NaN))
                return { unserializableValue: 'NaN' };
            return { value: arg };
        });
        let callFunctionPromise;
        try {
            callFunctionPromise = this._session.send('Runtime.callFunction', {
                functionDeclaration: functionText,
                args: protocolArgs,
                returnByValue,
                executionContextId: this._executionContextId
            });
        }
        catch (err) {
            if (err instanceof TypeError && err.message.startsWith('Converting circular structure to JSON'))
                err.message += ' Are you passing a nested JSHandle?';
            throw err;
        }
        const payload = await callFunctionPromise.catch(rewriteError);
        checkException(payload.exceptionDetails);
        if (returnByValue)
            return deserializeValue(payload.result);
        return context._createHandle(payload.result);
        function rewriteError(error) {
            if (error.message.includes('cyclic object value') || error.message.includes('Object is not serializable'))
                return { result: { type: 'undefined', value: undefined } };
            if (error.message.includes('Failed to find execution context with id') || error.message.includes('Execution context was destroyed!'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    async getProperties(handle) {
        const objectId = handle._remoteObject.objectId;
        if (!objectId)
            return new Map();
        const response = await this._session.send('Runtime.getObjectProperties', {
            executionContextId: this._executionContextId,
            objectId,
        });
        const result = new Map();
        for (const property of response.properties)
            result.set(property.name, handle._context._createHandle(property.value));
        return result;
    }
    async releaseHandle(handle) {
        if (!handle._remoteObject.objectId)
            return;
        await this._session.send('Runtime.disposeObject', {
            executionContextId: this._executionContextId,
            objectId: handle._remoteObject.objectId,
        }).catch(error => {
            // Exceptions might happen in case of a page been navigated or closed.
            // Swallow these since they are harmless and we don't leak anything in this case.
            helper_1.debugError(error);
        });
    }
    async handleJSONValue(handle) {
        const payload = handle._remoteObject;
        if (!payload.objectId)
            return deserializeValue(payload);
        const simpleValue = await this._session.send('Runtime.callFunction', {
            executionContextId: this._executionContextId,
            returnByValue: true,
            functionDeclaration: ((e) => e).toString(),
            args: [this._toCallArgument(payload)],
        });
        return deserializeValue(simpleValue.result);
    }
    handleToString(handle, includeType) {
        const payload = handle._remoteObject;
        if (payload.objectId)
            return 'JSHandle@' + (payload.subtype || payload.type);
        return (includeType ? 'JSHandle:' : '') + deserializeValue(payload);
    }
    _toCallArgument(payload) {
        return { value: payload.value, unserializableValue: payload.unserializableValue, objectId: payload.objectId };
    }
}
exports.FFExecutionContext = FFExecutionContext;
function checkException(exceptionDetails) {
    if (exceptionDetails) {
        if (exceptionDetails.value)
            throw new Error('Evaluation failed: ' + JSON.stringify(exceptionDetails.value));
        else
            throw new Error('Evaluation failed: ' + exceptionDetails.text + '\n' + exceptionDetails.stack);
    }
}
function deserializeValue({ unserializableValue, value }) {
    if (unserializableValue === 'Infinity')
        return Infinity;
    if (unserializableValue === '-Infinity')
        return -Infinity;
    if (unserializableValue === '-0')
        return -0;
    if (unserializableValue === 'NaN')
        return NaN;
    return value;
}
exports.deserializeValue = deserializeValue;


/***/ }),

/***/ "./src/firefox/ffInput.ts":
/*!********************************!*\
  !*** ./src/firefox/ffInput.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
function toModifiersMask(modifiers) {
    let mask = 0;
    if (modifiers.has('Alt'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Shift'))
        mask |= 4;
    if (modifiers.has('Meta'))
        mask |= 8;
    return mask;
}
function toButtonNumber(button) {
    if (button === 'left')
        return 0;
    if (button === 'middle')
        return 1;
    if (button === 'right')
        return 2;
    return 0;
}
function toButtonsMask(buttons) {
    let mask = 0;
    if (buttons.has('left'))
        mask |= 1;
    if (buttons.has('right'))
        mask |= 2;
    if (buttons.has('middle'))
        mask |= 4;
    return mask;
}
class RawKeyboardImpl {
    constructor(client) {
        this._client = client;
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        if (code === 'MetaLeft')
            code = 'OSLeft';
        if (code === 'MetaRight')
            code = 'OSRight';
        // Firefox will figure out Enter by itself
        if (text === '\r')
            text = '';
        await this._client.send('Page.dispatchKeyEvent', {
            type: 'keydown',
            keyCode: keyCodeWithoutLocation,
            code,
            key,
            repeat: autoRepeat,
            location,
            text,
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        if (code === 'MetaLeft')
            code = 'OSLeft';
        if (code === 'MetaRight')
            code = 'OSRight';
        await this._client.send('Page.dispatchKeyEvent', {
            type: 'keyup',
            key,
            keyCode: keyCodeWithoutLocation,
            code,
            location,
            repeat: false
        });
    }
    async sendText(text) {
        await this._client.send('Page.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(client) {
        this._client = client;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mousemove',
            button: 0,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers)
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mousedown',
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        await this._client.send('Page.dispatchMouseEvent', {
            type: 'mouseup',
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;


/***/ }),

/***/ "./src/firefox/ffNetworkManager.ts":
/*!*****************************************!*\
  !*** ./src/firefox/ffNetworkManager.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const network = __webpack_require__(/*! ../network */ "./src/network.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
class FFNetworkManager {
    constructor(session, page) {
        this._session = session;
        this._requests = new Map();
        this._page = page;
        this._eventListeners = [
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestFinished', this._onRequestFinished.bind(this)),
            helper_1.helper.addEventListener(session, 'Network.requestFailed', this._onRequestFailed.bind(this)),
        ];
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
    }
    async setRequestInterception(enabled) {
        await this._session.send('Network.setRequestInterception', { enabled });
    }
    _onRequestWillBeSent(event) {
        const redirected = event.redirectedFrom ? this._requests.get(event.redirectedFrom) : null;
        const frame = redirected ? redirected.request.frame() : (event.frameId ? this._page._frameManager.frame(event.frameId) : null);
        if (!frame)
            return;
        let redirectChain = [];
        if (redirected) {
            redirectChain = redirected.request._redirectChain;
            redirectChain.push(redirected.request);
            this._requests.delete(redirected._id);
        }
        const request = new InterceptableRequest(this._session, frame, redirectChain, event);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _onResponseReceived(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', {
                requestId: request._id
            });
            if (response.evicted)
                throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
            return platform.Buffer.from(response.base64body, 'base64');
        };
        const headers = {};
        for (const { name, value } of event.headers)
            headers[name.toLowerCase()] = value;
        const response = new network.Response(request.request, event.status, event.statusText, headers, getResponseBody);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        const response = request.request.response();
        // Keep redirected requests in the map for future reference in redirectChain.
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        if (isRedirected) {
            response._requestFinished(new Error('Response body is unavailable for redirect responses'));
        }
        else {
            this._requests.delete(request._id);
            response._requestFinished();
        }
        this._page._frameManager.requestFinished(request.request);
    }
    _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
            return;
        this._requests.delete(request._id);
        const response = request.request.response();
        if (response)
            response._requestFinished();
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === 'NS_BINDING_ABORTED');
    }
}
exports.FFNetworkManager = FFNetworkManager;
const causeToResourceType = {
    TYPE_INVALID: 'other',
    TYPE_OTHER: 'other',
    TYPE_SCRIPT: 'script',
    TYPE_IMAGE: 'image',
    TYPE_STYLESHEET: 'stylesheet',
    TYPE_OBJECT: 'other',
    TYPE_DOCUMENT: 'document',
    TYPE_SUBDOCUMENT: 'document',
    TYPE_REFRESH: 'document',
    TYPE_XBL: 'other',
    TYPE_PING: 'other',
    TYPE_XMLHTTPREQUEST: 'xhr',
    TYPE_OBJECT_SUBREQUEST: 'other',
    TYPE_DTD: 'other',
    TYPE_FONT: 'font',
    TYPE_MEDIA: 'media',
    TYPE_WEBSOCKET: 'websocket',
    TYPE_CSP_REPORT: 'other',
    TYPE_XSLT: 'other',
    TYPE_BEACON: 'other',
    TYPE_FETCH: 'fetch',
    TYPE_IMAGESET: 'images',
    TYPE_WEB_MANIFEST: 'manifest',
};
class InterceptableRequest {
    constructor(session, frame, redirectChain, payload) {
        this._id = payload.requestId;
        this._session = session;
        const headers = {};
        for (const { name, value } of payload.headers)
            headers[name.toLowerCase()] = value;
        this.request = new network.Request(payload.isIntercepted ? this : null, frame, redirectChain, payload.navigationId, payload.url, causeToResourceType[payload.cause] || 'other', payload.method, payload.postData, headers);
    }
    async continue(overrides) {
        const { method, headers, postData } = overrides;
        await this._session.send('Network.resumeInterceptedRequest', {
            requestId: this._id,
            method,
            headers: headers ? headersArray(headers) : undefined,
            postData: postData ? Buffer.from(postData).toString('base64') : undefined
        }).catch(error => {
            helper_1.debugError(error);
        });
    }
    async fulfill(response) {
        const responseBody = response.body && helper_1.helper.isString(response.body) ? platform.Buffer.from(response.body) : (response.body || null);
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = response.headers[header];
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(platform.Buffer.byteLength(responseBody));
        await this._session.send('Network.fulfillInterceptedRequest', {
            requestId: this._id,
            status: response.status || 200,
            statusText: network.STATUS_TEXTS[String(response.status || 200)] || '',
            headers: headersArray(responseHeaders),
            base64body: responseBody ? responseBody.toString('base64') : undefined,
        }).catch(error => {
            helper_1.debugError(error);
        });
    }
    async abort(errorCode) {
        await this._session.send('Network.abortInterceptedRequest', {
            requestId: this._id,
            errorCode,
        }).catch(error => {
            helper_1.debugError(error);
        });
    }
}
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        if (!Object.is(headers[name], undefined))
            result.push({ name, value: headers[name] + '' });
    }
    return result;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/firefox/ffPage.ts":
/*!*******************************!*\
  !*** ./src/firefox/ffPage.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const dom = __webpack_require__(/*! ../dom */ "./src/dom.ts");
const ffConnection_1 = __webpack_require__(/*! ./ffConnection */ "./src/firefox/ffConnection.ts");
const ffExecutionContext_1 = __webpack_require__(/*! ./ffExecutionContext */ "./src/firefox/ffExecutionContext.ts");
const page_1 = __webpack_require__(/*! ../page */ "./src/page.ts");
const ffNetworkManager_1 = __webpack_require__(/*! ./ffNetworkManager */ "./src/firefox/ffNetworkManager.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const dialog = __webpack_require__(/*! ../dialog */ "./src/dialog.ts");
const ffInput_1 = __webpack_require__(/*! ./ffInput */ "./src/firefox/ffInput.ts");
const ffAccessibility_1 = __webpack_require__(/*! ./ffAccessibility */ "./src/firefox/ffAccessibility.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const screenshotter_1 = __webpack_require__(/*! ../screenshotter */ "./src/screenshotter.ts");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
class FFPage {
    constructor(session, browserContext, openerResolver) {
        this._workers = new Map();
        this._session = session;
        this._openerResolver = openerResolver;
        this.rawKeyboard = new ffInput_1.RawKeyboardImpl(session);
        this.rawMouse = new ffInput_1.RawMouseImpl(session);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new ffNetworkManager_1.FFNetworkManager(session, this._page);
        this._page.on(events_1.Events.Page.FrameDetached, frame => this._removeContextsForFrame(frame));
        this._eventListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.eventFired', this._onEventFired.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', this._onFrameAttached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', this._onFrameDetached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationAborted', this._onNavigationAborted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationCommitted', this._onNavigationCommitted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationStarted', this._onNavigationStarted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.sameDocumentNavigation', this._onSameDocumentNavigation.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', this._onExecutionContextCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextDestroyed', this._onExecutionContextDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.uncaughtError', this._onUncaughtError.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.console', this._onConsole.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dialogOpened', this._onDialogOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.bindingCalled', this._onBindingCalled.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', this._onFileChooserOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerCreated', this._onWorkerCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerDestroyed', this._onWorkerDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dispatchMessageFromWorker', this._onDispatchMessageFromWorker.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.crashed', this._onCrashed.bind(this)),
        ];
    }
    async _initialize() {
        await Promise.all([
            this._session.send('Page.addScriptToEvaluateOnNewDocument', {
                script: '',
                worldName: UTILITY_WORLD_NAME,
            }),
            new Promise(f => this._session.once('Page.ready', f)),
        ]);
    }
    _onExecutionContextCreated(payload) {
        const { executionContextId, auxData } = payload;
        const frame = this._page._frameManager.frame(auxData ? auxData.frameId : null);
        if (!frame)
            return;
        const delegate = new ffExecutionContext_1.FFExecutionContext(this._session, executionContextId);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (auxData.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        else if (!auxData.name)
            frame._contextCreated('main', context);
        this._contextIdToContext.set(executionContextId, context);
    }
    _onExecutionContextDestroyed(payload) {
        const { executionContextId } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame)
                this._contextIdToContext.delete(contextId);
        }
    }
    _onNavigationStarted() {
    }
    _onNavigationAborted(params) {
        const frame = this._page._frameManager.frame(params.frameId);
        for (const watcher of frame._documentWatchers)
            watcher(params.navigationId, new Error(params.errorText));
    }
    _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
            if (worker.frameId === params.frameId)
                this._onWorkerDestroyed({ workerId });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || '', params.navigationId || '', false);
    }
    _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
    }
    _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
    }
    _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
    }
    _onEventFired(payload) {
        const { frameId, name } = payload;
        if (name === 'load')
            this._page._frameManager.frameLifecycleEvent(frameId, 'load');
        if (name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(frameId, 'domcontentloaded');
    }
    _onUncaughtError(params) {
        const error = new Error(params.message);
        error.stack = params.stack;
        this._page.emit(events_1.Events.Page.PageError, error);
    }
    _onConsole(payload) {
        const { type, args, executionContextId, location } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        this._page._addConsoleMessage(type, args.map(arg => context._createHandle(arg)), location);
    }
    _onDialogOpened(params) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(params.type, params.message, async (accept, promptText) => {
            await this._session.send('Page.handleDialog', { dialogId: params.dialogId, accept, promptText }).catch(helper_1.debugError);
        }, params.defaultValue));
    }
    _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        this._page._onBindingCalled(event.payload, context);
    }
    async _onFileChooserOpened(payload) {
        const { executionContextId, element } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        const handle = context._createHandle(element).asElement();
        this._page._onFileChooserOpened(handle);
    }
    async _onWorkerCreated(event) {
        const workerId = event.workerId;
        const worker = new page_1.Worker(event.url);
        const workerSession = new ffConnection_1.FFSession(this._session._connection, 'worker', workerId, (message) => {
            this._session.send('Page.sendMessageToWorker', {
                frameId: event.frameId,
                workerId: workerId,
                message: JSON.stringify(message)
            }).catch(e => {
                workerSession.dispatchMessage({ id: message.id, method: '', params: {}, error: { message: e.message, data: undefined } });
            });
        });
        this._workers.set(workerId, { session: workerSession, frameId: event.frameId });
        this._page._addWorker(workerId, worker);
        workerSession.once('Runtime.executionContextCreated', event => {
            worker._createExecutionContext(new ffExecutionContext_1.FFExecutionContext(workerSession, event.executionContextId));
        });
        workerSession.on('Runtime.console', event => {
            const { type, args, location } = event;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map(arg => context._createHandle(arg)), location);
        });
        // Note: we receive worker exceptions directly from the page.
    }
    async _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
            return;
        worker.session._onClosed();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
    }
    async _onDispatchMessageFromWorker(event) {
        const worker = this._workers.get(event.workerId);
        if (!worker)
            return;
        worker.session.dispatchMessage(JSON.parse(event.message));
    }
    async _onCrashed(event) {
        this._page._didCrash();
    }
    async exposeBinding(name, bindingFunction) {
        await this._session.send('Page.addBinding', { name: name });
        await this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: bindingFunction });
        await Promise.all(this._page.frames().map(frame => frame.evaluate(bindingFunction).catch(helper_1.debugError)));
    }
    didClose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referer) {
        const response = await this._session.send('Page.navigate', { url, referer, frameId: frame._id });
        return { newDocumentId: response.navigationId || undefined };
    }
    async setExtraHTTPHeaders(headers) {
        const array = [];
        for (const [name, value] of Object.entries(headers))
            array.push({ name, value });
        await this._session.send('Network.setExtraHTTPHeaders', { headers: array });
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._session.send('Page.setViewportSize', {
            viewportSize: {
                width: viewportSize.width,
                height: viewportSize.height,
            },
        });
    }
    async setEmulateMedia(mediaType, colorScheme) {
        await this._session.send('Page.setEmulatedMedia', {
            type: mediaType === null ? undefined : mediaType,
            colorScheme: colorScheme === null ? undefined : colorScheme
        });
    }
    async setCacheEnabled(enabled) {
        await this._session.send('Page.setCacheDisabled', { cacheDisabled: !enabled });
    }
    async setRequestInterception(enabled) {
        await this._networkManager.setRequestInterception(enabled);
    }
    async setOfflineMode(enabled) {
        throw new Error('Offline mode not implemented in Firefox');
    }
    async authenticate(credentials) {
        await this._session.send('Network.setAuthCredentials', credentials || { username: null, password: null });
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        return await this._openerResolver();
    }
    async reload() {
        await this._session.send('Page.reload', { frameId: this._page.mainFrame()._id });
    }
    async goBack() {
        const { navigationId } = await this._session.send('Page.goBack', { frameId: this._page.mainFrame()._id });
        return navigationId !== null;
    }
    async goForward() {
        const { navigationId } = await this._session.send('Page.goForward', { frameId: this._page.mainFrame()._id });
        return navigationId !== null;
    }
    async evaluateOnNewDocument(source) {
        await this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: source });
    }
    async closePage(runBeforeUnload) {
        await this._session.send('Page.close', { runBeforeUnload });
    }
    async getBoundingBoxForScreenshot(handle) {
        const frameId = handle._context.frame._id;
        const response = await this._session.send('Page.getBoundingBox', {
            frameId,
            objectId: handle._remoteObject.objectId,
        });
        return response.boundingBox;
    }
    canScreenshotOutsideViewport() {
        return true;
    }
    async setBackgroundColor(color) {
        if (color)
            throw new Error('Not implemented');
    }
    async takeScreenshot(format, options, viewportSize) {
        const { data } = await this._session.send('Page.screenshot', {
            mimeType: ('image/' + format),
            fullPage: options.fullPage,
            clip: options.clip,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('document.documentElement is null'))
                e.message = screenshotter_1.kScreenshotDuringNavigationError;
            throw e;
        });
        return platform.Buffer.from(data, 'base64');
    }
    async resetViewport() {
        await this._session.send('Page.setViewportSize', { viewportSize: null });
    }
    async getContentFrame(handle) {
        const { contentFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        });
        if (!contentFrameId)
            return null;
        return this._page._frameManager.frame(contentFrameId);
    }
    async getOwnerFrame(handle) {
        const { ownerFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        });
        return ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._session.send('Page.scrollIntoViewIfNeeded', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
            rect,
        });
    }
    async getContentQuads(handle) {
        const result = await this._session.send('Page.getContentQuads', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [quad.p1, quad.p2, quad.p3, quad.p4]);
    }
    async layoutViewport() {
        return this._page.evaluate(() => ({ width: innerWidth, height: innerHeight }));
    }
    async setInputFiles(handle, files) {
        await handle.evaluate(dom.setFileInputFunction, files);
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.send('Page.adoptNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
            executionContextId: to._delegate._executionContextId
        });
        if (!result.remoteObject)
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.remoteObject);
    }
    async getAccessibilityTree(needle) {
        return ffAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const context = await parent._utilityContext();
        const handles = await context._$$('iframe');
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        await Promise.all(items.map(item => item === result ? Promise.resolve() : item.handle.dispose()));
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
}
exports.FFPage = FFPage;
function normalizeWaitUntil(waitUntil) {
    if (!Array.isArray(waitUntil))
        waitUntil = [waitUntil];
    for (const condition of waitUntil) {
        if (condition !== 'load' && condition !== 'domcontentloaded')
            throw new Error('Unknown waitUntil condition: ' + condition);
    }
    return waitUntil;
}
exports.normalizeWaitUntil = normalizeWaitUntil;
function toRemoteObject(handle) {
    return handle._remoteObject;
}


/***/ }),

/***/ "./src/frames.ts":
/*!***********************!*\
  !*** ./src/frames.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const dom = __webpack_require__(/*! ./dom */ "./src/dom.ts");
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
const kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle0', 'networkidle2']);
class FrameManager {
    constructor(page) {
        this._frames = new Map();
        this._lifecycleWatchers = new Set();
        this._consoleMessageTags = new Map();
        this._page = page;
        this._mainFrame = undefined;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
            frames.push(frame);
            for (const subframe of frame.childFrames())
                collect(subframe);
        }
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
            if (this._mainFrame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(this._mainFrame._id);
                this._mainFrame._id = frameId;
            }
            else {
                helper_1.assert(!this._frames.has(frameId));
                this._mainFrame = new Frame(this._page, frameId, parentFrame);
            }
            this._frames.set(frameId, this._mainFrame);
            return this._mainFrame;
        }
        else {
            helper_1.assert(!this._frames.has(frameId));
            const frame = new Frame(this._page, frameId, parentFrame);
            this._frames.set(frameId, frame);
            this._page.emit(events_1.Events.Page.FrameAttached, frame);
            return frame;
        }
    }
    frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._url = url;
        frame._name = name;
        frame._lastDocumentId = documentId;
        for (const watcher of frame._documentWatchers)
            watcher(documentId);
        this.clearFrameLifecycle(frame);
        if (!initial)
            this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._url = url;
        for (const watcher of frame._sameDocumentNavigationWatchers)
            watcher();
        this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    frameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        const hasDOMContentLoaded = frame._firedLifecycleEvents.has('domcontentloaded');
        const hasLoad = frame._firedLifecycleEvents.has('load');
        frame._firedLifecycleEvents.add('domcontentloaded');
        frame._firedLifecycleEvents.add('load');
        for (const watcher of this._lifecycleWatchers)
            watcher();
        if (frame === this.mainFrame() && !hasDOMContentLoaded)
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
        if (frame === this.mainFrame() && !hasLoad)
            this._page.emit(events_1.Events.Page.Load);
    }
    frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._firedLifecycleEvents.add(event);
        for (const watcher of this._lifecycleWatchers)
            watcher();
        if (frame === this._mainFrame && event === 'load')
            this._page.emit(events_1.Events.Page.Load);
        if (frame === this._mainFrame && event === 'domcontentloaded')
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
    }
    clearFrameLifecycle(frame) {
        frame._firedLifecycleEvents.clear();
        // Keep the current navigation request if any.
        frame._inflightRequests = new Set(Array.from(frame._inflightRequests).filter(request => request._documentId === frame._lastDocumentId));
        this._stopNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 0)
            this._startNetworkIdleTimer(frame, 'networkidle0');
        this._stopNetworkIdleTimer(frame, 'networkidle2');
        if (frame._inflightRequests.size <= 2)
            this._startNetworkIdleTimer(frame, 'networkidle2');
    }
    requestStarted(request) {
        this._inflightRequestStarted(request);
        const frame = request.frame();
        if (frame) {
            for (const watcher of frame._requestWatchers)
                watcher(request);
        }
        if (!request._isFavicon)
            this._page._requestStarted(request);
    }
    requestReceivedResponse(response) {
        if (!response.request()._isFavicon)
            this._page.emit(events_1.Events.Page.Response, response);
    }
    requestFinished(request) {
        this._inflightRequestFinished(request);
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFinished, request);
    }
    requestFailed(request, canceled) {
        this._inflightRequestFinished(request);
        const frame = request.frame();
        if (request._documentId && frame) {
            const isCurrentDocument = frame._lastDocumentId === request._documentId;
            if (!isCurrentDocument) {
                let errorText = request.failure().errorText;
                if (canceled)
                    errorText += '; maybe frame was detached?';
                for (const watcher of frame._documentWatchers)
                    watcher(request._documentId, new Error(errorText));
            }
        }
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFailed, request);
    }
    provisionalLoadFailed(frame, documentId, error) {
        for (const watcher of frame._documentWatchers)
            watcher(documentId, new Error(error));
    }
    _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._onDetached();
        this._frames.delete(frame._id);
        this._page.emit(events_1.Events.Page.FrameDetached, frame);
    }
    _inflightRequestFinished(request) {
        const frame = request.frame();
        if (!frame || request._isFavicon)
            return;
        if (!frame._inflightRequests.has(request))
            return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
            this._startNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 2)
            this._startNetworkIdleTimer(frame, 'networkidle2');
    }
    _inflightRequestStarted(request) {
        const frame = request.frame();
        if (!frame || request._isFavicon)
            return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
            this._stopNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 3)
            this._stopNetworkIdleTimer(frame, 'networkidle2');
    }
    _startNetworkIdleTimer(frame, event) {
        helper_1.assert(!frame._networkIdleTimers.has(event));
        if (frame._firedLifecycleEvents.has(event))
            return;
        frame._networkIdleTimers.set(event, setTimeout(() => {
            this.frameLifecycleEvent(frame._id, event);
        }, 500));
    }
    _stopNetworkIdleTimer(frame, event) {
        const timeoutId = frame._networkIdleTimers.get(event);
        if (timeoutId)
            clearTimeout(timeoutId);
        frame._networkIdleTimers.delete(event);
    }
    interceptConsoleMessage(message) {
        if (message.type() !== 'debug')
            return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
            return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
    }
}
exports.FrameManager = FrameManager;
class Frame {
    constructor(page, id, parentFrame) {
        this._lastDocumentId = '';
        this._requestWatchers = new Set();
        this._documentWatchers = new Set();
        this._sameDocumentNavigationWatchers = new Set();
        this._url = '';
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = '';
        this._inflightRequests = new Set();
        this._networkIdleTimers = new Map();
        this._setContentCounter = 0;
        this._detachedCallback = () => { };
        this.evaluateHandle = async (pageFunction, ...args) => {
            const context = await this._mainContext();
            return context.evaluateHandle(pageFunction, ...args);
        };
        this.evaluate = async (pageFunction, ...args) => {
            const context = await this._mainContext();
            return context.evaluate(pageFunction, ...args);
        };
        this.$eval = async (selector, pageFunction, ...args) => {
            const context = await this._mainContext();
            const elementHandle = await context._$(selector);
            if (!elementHandle)
                throw new Error(`Error: failed to find element matching selector "${selector}"`);
            const result = await elementHandle.evaluate(pageFunction, ...args);
            await elementHandle.dispose();
            return result;
        };
        this.$$eval = async (selector, pageFunction, ...args) => {
            const context = await this._mainContext();
            const arrayHandle = await context._$array(selector);
            const result = await arrayHandle.evaluate(pageFunction, ...args);
            await arrayHandle.dispose();
            return result;
        };
        this._id = id;
        this._firedLifecycleEvents = new Set();
        this._page = page;
        this._parentFrame = parentFrame;
        this._detachedPromise = new Promise(x => this._detachedCallback = x);
        this._contextData.set('main', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._contextData.set('utility', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._setContext('main', null);
        this._setContext('utility', null);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    async goto(url, options = {}) {
        const headers = (this._page._state.extraHTTPHeaders || {});
        let referer = headers['referer'] || headers['Referer'];
        if (options.referer !== undefined) {
            if (referer !== undefined && referer !== options.referer)
                throw new Error('"referer" is already specified as extra HTTP header');
            referer = options.referer;
        }
        url = helper_1.helper.completeUserURL(url);
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const disposer = new Disposer();
        const timeoutPromise = disposer.add(createTimeoutPromise(timeout));
        const frameDestroyedPromise = this._createFrameDestroyedPromise();
        const sameDocumentPromise = disposer.add(this._waitForSameDocumentNavigation());
        const requestWatcher = disposer.add(this._trackDocumentRequests());
        let navigateResult;
        const navigate = async () => {
            try {
                navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
            }
            catch (error) {
                return error;
            }
        };
        throwIfError(await Promise.race([
            navigate(),
            timeoutPromise,
            frameDestroyedPromise,
        ]));
        const promises = [timeoutPromise, frameDestroyedPromise];
        if (navigateResult.newDocumentId)
            promises.push(disposer.add(this._waitForSpecificDocument(navigateResult.newDocumentId)));
        else
            promises.push(sameDocumentPromise);
        throwIfError(await Promise.race(promises));
        const request = (navigateResult && navigateResult.newDocumentId) ? requestWatcher.get(navigateResult.newDocumentId) : null;
        const waitForLifecyclePromise = disposer.add(this._waitForLifecycle(options.waitUntil));
        throwIfError(await Promise.race([timeoutPromise, frameDestroyedPromise, waitForLifecyclePromise]));
        disposer.dispose();
        return request ? request._finalRequest._waitForResponse() : null;
        function throwIfError(error) {
            if (!error)
                return;
            disposer.dispose();
            const message = `While navigating to ${url}: ${error.message}`;
            if (error instanceof errors_1.TimeoutError)
                throw new errors_1.TimeoutError(message);
            throw new Error(message);
        }
    }
    async waitForNavigation(options = {}) {
        const disposer = new Disposer();
        const requestWatcher = disposer.add(this._trackDocumentRequests());
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const failurePromise = Promise.race([
            this._createFrameDestroyedPromise(),
            disposer.add(createTimeoutPromise(timeout)),
        ]);
        let documentId = null;
        let error = await Promise.race([
            failurePromise,
            disposer.add(this._waitForNewDocument(options.url)).then(result => {
                if (result.error)
                    return result.error;
                documentId = result.documentId;
            }),
            disposer.add(this._waitForSameDocumentNavigation(options.url)),
        ]);
        const request = requestWatcher.get(documentId);
        if (!error) {
            error = await Promise.race([
                failurePromise,
                disposer.add(this._waitForLifecycle(options.waitUntil)),
            ]);
        }
        disposer.dispose();
        if (error)
            throw error;
        return request ? request._finalRequest._waitForResponse() : null;
    }
    async waitForLoadState(options = {}) {
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const disposer = new Disposer();
        const error = await Promise.race([
            this._createFrameDestroyedPromise(),
            disposer.add(createTimeoutPromise(timeout)),
            disposer.add(this._waitForLifecycle(options.waitUntil)),
        ]);
        disposer.dispose();
        if (error)
            throw error;
    }
    _waitForSpecificDocument(expectedDocumentId) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = (documentId, error) => {
            if (documentId !== expectedDocumentId)
                return resolve(new Error('Navigation interrupted by another one'));
            resolve(error);
        };
        const dispose = () => this._documentWatchers.delete(watch);
        this._documentWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForNewDocument(url) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = (documentId, error) => {
            if (!error && !platform.urlMatches(this.url(), url))
                return;
            resolve({ error, documentId });
        };
        const dispose = () => this._documentWatchers.delete(watch);
        this._documentWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForSameDocumentNavigation(url) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = () => {
            if (platform.urlMatches(this.url(), url))
                resolve();
        };
        const dispose = () => this._sameDocumentNavigationWatchers.delete(watch);
        this._sameDocumentNavigationWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForLifecycle(waitUntil = 'load') {
        let resolve;
        const expectedLifecycle = typeof waitUntil === 'string' ? [waitUntil] : waitUntil;
        for (const event of expectedLifecycle) {
            if (!kLifecycleEvents.has(event))
                throw new Error(`Unsupported waitUntil option ${String(event)}`);
        }
        const checkLifecycleComplete = () => {
            if (!checkLifecycleRecursively(this))
                return;
            resolve();
        };
        const promise = new Promise(x => resolve = x);
        const dispose = () => this._page._frameManager._lifecycleWatchers.delete(checkLifecycleComplete);
        this._page._frameManager._lifecycleWatchers.add(checkLifecycleComplete);
        checkLifecycleComplete();
        return { value: promise, dispose };
        function checkLifecycleRecursively(frame) {
            for (const event of expectedLifecycle) {
                if (!frame._firedLifecycleEvents.has(event))
                    return false;
            }
            for (const child of frame.childFrames()) {
                if (!checkLifecycleRecursively(child))
                    return false;
            }
            return true;
        }
    }
    _trackDocumentRequests() {
        const requestMap = new Map();
        const dispose = () => {
            this._requestWatchers.delete(onRequest);
        };
        const onRequest = (request) => {
            if (!request._documentId || request.redirectChain().length)
                return;
            requestMap.set(request._documentId, request);
        };
        this._requestWatchers.add(onRequest);
        return { dispose, value: requestMap };
    }
    _createFrameDestroyedPromise() {
        return Promise.race([
            this._page._disconnectedPromise.then(() => new Error('Navigation failed because browser has disconnected!')),
            this._detachedPromise.then(() => new Error('Navigating frame was detached!')),
        ]);
    }
    async frameElement() {
        return this._page._delegate.getFrameElement(this);
    }
    _context(contextType) {
        if (this._detached)
            throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(contextType).contextPromise;
    }
    _mainContext() {
        return this._context('main');
    }
    _utilityContext() {
        return this._context('utility');
    }
    async $(selector) {
        const utilityContext = await this._utilityContext();
        const mainContext = await this._mainContext();
        const handle = await utilityContext._$(selector);
        if (handle && handle._context !== mainContext) {
            const adopted = this._page._delegate.adoptElementHandle(handle, mainContext);
            await handle.dispose();
            return adopted;
        }
        return handle;
    }
    async waitForSelector(selector, options) {
        const { timeout = this._page._timeoutSettings.timeout(), visibility = 'any' } = (options || {});
        const handle = await this._waitForSelectorInUtilityContext(selector, visibility, timeout);
        const mainContext = await this._mainContext();
        if (handle && handle._context !== mainContext) {
            const adopted = this._page._delegate.adoptElementHandle(handle, mainContext);
            await handle.dispose();
            return adopted;
        }
        return handle;
    }
    async $wait(selector, options) {
        return this.waitForSelector(selector, options);
    }
    async $$(selector) {
        const context = await this._mainContext();
        return context._$$(selector);
    }
    async content() {
        const context = await this._utilityContext();
        return context.evaluate(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options) {
        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
        const context = await this._utilityContext();
        const lifecyclePromise = new Promise(resolve => {
            this._page._frameManager._consoleMessageTags.set(tag, () => {
                // Clear lifecycle right after document.open() - see 'tag' below.
                this._page._frameManager.clearFrameLifecycle(this);
                resolve(this.waitForLoadState(options));
            });
        });
        const contentPromise = context.evaluate((html, tag) => {
            window.stop();
            document.open();
            console.debug(tag); // eslint-disable-line no-console
            document.write(html);
            document.close();
        }, html, tag);
        await Promise.all([contentPromise, lifecyclePromise]);
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    isDetached() {
        return this._detached;
    }
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();
            if (path !== null) {
                let contents = await platform.readFileAsync(path, 'utf8');
                contents += '//# sourceURL=' + path.replace(/\n/g, '');
                return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();
            }
            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();
        });
        async function addScriptUrl(url, type) {
            const script = document.createElement('script');
            script.src = url;
            if (type)
                script.type = type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = rej;
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(content, type = 'text/javascript') {
            const script = document.createElement('script');
            script.type = type;
            script.text = content;
            let error = null;
            script.onerror = e => error = e;
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addStyleUrl, url)).asElement();
            if (path !== null) {
                let contents = await platform.readFileAsync(path, 'utf8');
                contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
                return (await context.evaluateHandle(addStyleContent, contents)).asElement();
            }
            return (await context.evaluateHandle(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error;
        let cspMessage;
        const actionPromise = new Promise(async (resolve) => {
            try {
                result = await func();
            }
            catch (e) {
                error = e;
            }
            resolve();
        });
        const errorPromise = new Promise(resolve => {
            listeners.push(helper_1.helper.addEventListener(this._page, events_1.Events.Page.Console, (message) => {
                if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
                    cspMessage = message;
                    resolve();
                }
            }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
            throw new Error(cspMessage.text());
        if (error)
            throw error;
        return result;
    }
    async click(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.click(options);
        await handle.dispose();
    }
    async dblclick(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.dblclick(options);
        await handle.dispose();
    }
    async tripleclick(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.tripleclick(options);
        await handle.dispose();
    }
    async fill(selector, value, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.fill(value);
        await handle.dispose();
    }
    async focus(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.focus();
        await handle.dispose();
    }
    async hover(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.hover(options);
        await handle.dispose();
    }
    async select(selector, value, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        const values = value === undefined ? [] : Array.isArray(value) ? value : [value];
        const result = await handle.select(...values);
        await handle.dispose();
        return result;
    }
    async type(selector, text, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.type(text, options);
        await handle.dispose();
    }
    async check(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.check();
        await handle.dispose();
    }
    async uncheck(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.uncheck();
        await handle.dispose();
    }
    async waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        if (helper_1.helper.isString(selectorOrFunctionOrTimeout))
            return this.waitForSelector(selectorOrFunctionOrTimeout, options);
        if (helper_1.helper.isNumber(selectorOrFunctionOrTimeout))
            return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === 'function')
            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error('Unsupported target type: ' + (typeof selectorOrFunctionOrTimeout)));
    }
    async _optionallyWaitForSelectorInUtilityContext(selector, options) {
        const { timeout = this._page._timeoutSettings.timeout(), waitFor = 'visible' } = (options || {});
        let handle;
        if (waitFor !== 'nowait') {
            const maybeHandle = await this._waitForSelectorInUtilityContext(selector, waitFor, timeout);
            if (!maybeHandle)
                throw new Error('No node found for selector: ' + selectorToString(selector, waitFor));
            handle = maybeHandle;
        }
        else {
            const context = await this._context('utility');
            const maybeHandle = await context._$(selector);
            helper_1.assert(maybeHandle, 'No node found for selector: ' + selector);
            handle = maybeHandle;
        }
        return handle;
    }
    async _waitForSelectorInUtilityContext(selector, waitFor, timeout) {
        let visibility = 'any';
        if (waitFor === 'visible' || waitFor === 'hidden' || waitFor === 'any')
            visibility = waitFor;
        else
            throw new Error(`Unsupported waitFor option "${waitFor}"`);
        const task = dom.waitForSelectorTask(selector, visibility, timeout);
        const result = await this._scheduleRerunnableTask(task, 'utility', timeout, `selector "${selectorToString(selector, visibility)}"`);
        if (!result.asElement()) {
            await result.dispose();
            return null;
        }
        return result.asElement();
    }
    async waitForFunction(pageFunction, options, ...args) {
        options = { timeout: this._page._timeoutSettings.timeout(), ...(options || {}) };
        const task = dom.waitForFunctionTask(undefined, pageFunction, options, ...args);
        return this._scheduleRerunnableTask(task, 'main', options.timeout);
    }
    async title() {
        const context = await this._utilityContext();
        return context.evaluate(() => document.title);
    }
    _onDetached() {
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        }
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
    _scheduleRerunnableTask(task, contextType, timeout, title) {
        const data = this._contextData.get(contextType);
        const rerunnableTask = new RerunnableTask(data, task, timeout, title);
        data.rerunnableTasks.add(rerunnableTask);
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _setContext(contextType, context) {
        const data = this._contextData.get(contextType);
        data.context = context;
        if (context) {
            data.contextResolveCallback.call(null, context);
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.rerun(context);
        }
        else {
            data.contextPromise = new Promise(fulfill => {
                data.contextResolveCallback = fulfill;
            });
        }
    }
    _contextCreated(contextType, context) {
        const data = this._contextData.get(contextType);
        // In case of multiple sessions to the same target, there's a race between
        // connections so we might end up creating multiple isolated worlds.
        // We can use either.
        if (data.context)
            this._setContext(contextType, null);
        this._setContext(contextType, context);
    }
    _contextDestroyed(context) {
        for (const [contextType, data] of this._contextData) {
            if (data.context === context)
                this._setContext(contextType, null);
        }
    }
}
exports.Frame = Frame;
class RerunnableTask {
    constructor(data, task, timeout, title) {
        this._resolve = () => { };
        this._reject = () => { };
        this._terminated = false;
        this._contextData = data;
        this._task = task;
        this._runCount = 0;
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        // Since page navigation requires us to re-install the pageScript, we should track
        // timeout on our end.
        if (timeout) {
            const timeoutError = new errors_1.TimeoutError(`waiting for ${title || 'function'} failed: timeout ${timeout}ms exceeded`);
            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);
        }
    }
    terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._doCleanup();
    }
    async rerun(context) {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        try {
            success = await this._task(context);
        }
        catch (e) {
            error = e;
        }
        if (this._terminated || runCount !== this._runCount) {
            if (success)
                await success.dispose();
            return;
        }
        // Ignore timeouts in pageScript - we track timeouts ourselves.
        // If execution context has been already destroyed, `context.evaluate` will
        // throw an error - ignore this predicate run altogether.
        if (!error && await context.evaluate(s => !s, success).catch(e => true)) {
            await success.dispose();
            return;
        }
        // When the page is navigated, the promise is rejected.
        // We will try again in the new execution context.
        if (error && error.message.includes('Execution context was destroyed'))
            return;
        // We could have tried to evaluate in a context which was already
        // destroyed.
        if (error && error.message.includes('Cannot find context with specified id'))
            return;
        if (error)
            this._reject(error);
        else
            this._resolve(success);
        this._doCleanup();
    }
    _doCleanup() {
        if (this._timeoutTimer)
            clearTimeout(this._timeoutTimer);
        this._contextData.rerunnableTasks.delete(this);
    }
}
class Disposer {
    constructor() {
        this._disposes = [];
    }
    add({ value, dispose }) {
        this._disposes.push(dispose);
        return value;
    }
    dispose() {
        for (const dispose of this._disposes)
            dispose();
        this._disposes = [];
    }
}
function createTimeoutPromise(timeout) {
    if (!timeout)
        return { value: new Promise(() => { }), dispose: () => void 0 };
    let timer;
    const errorMessage = 'Navigation timeout of ' + timeout + ' ms exceeded';
    const promise = new Promise(fulfill => timer = setTimeout(fulfill, timeout))
        .then(() => new errors_1.TimeoutError(errorMessage));
    const dispose = () => {
        clearTimeout(timer);
    };
    return {
        value: promise,
        dispose
    };
}
function selectorToString(selector, visibility) {
    let label;
    switch (visibility) {
        case 'visible':
            label = '[visible] ';
            break;
        case 'hidden':
            label = '[hidden] ';
            break;
        case 'any':
        case undefined:
            label = '';
            break;
    }
    return `${label}${selector}`;
}


/***/ }),

/***/ "./src/generated/injectedSource.ts":
/*!*****************************************!*\
  !*** ./src/generated/injectedSource.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.source = "(/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/injected/injected.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/injected/cssSelectorEngine.ts\":\n/*!*******************************************!*\\\n  !*** ./src/injected/cssSelectorEngine.ts ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CSSEngine = {\n    name: 'css',\n    create(root, targetElement) {\n        const tokens = [];\n        function uniqueCSSSelector(prefix) {\n            const path = tokens.slice();\n            if (prefix)\n                path.unshift(prefix);\n            const selector = path.join(' > ');\n            const nodes = Array.from(root.querySelectorAll(selector));\n            return nodes[0] === targetElement ? selector : undefined;\n        }\n        for (let element = targetElement; element && element !== root; element = element.parentElement) {\n            const nodeName = element.nodeName.toLowerCase();\n            // Element ID is the strongest signal, use it.\n            let bestTokenForLevel = '';\n            if (element.id) {\n                const token = /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(element.id) ? '#' + element.id : `[id=\"${element.id}\"]`;\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                bestTokenForLevel = token;\n            }\n            const parent = element.parentElement;\n            // Combine class names until unique.\n            const classes = Array.from(element.classList);\n            for (let i = 0; i < classes.length; ++i) {\n                const token = '.' + classes.slice(0, i + 1).join('.');\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                // Even if not unique, does this subset of classes uniquely identify node as a child?\n                if (!bestTokenForLevel && parent) {\n                    const sameClassSiblings = parent.querySelectorAll(token);\n                    if (sameClassSiblings.length === 1)\n                        bestTokenForLevel = token;\n                }\n            }\n            // Ordinal is the weakest signal.\n            if (parent) {\n                const siblings = Array.from(parent.children);\n                const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n                const token = sameTagSiblings.length === 1 ? nodeName : `${nodeName}:nth-child(${1 + siblings.indexOf(element)})`;\n                const selector = uniqueCSSSelector(token);\n                if (selector)\n                    return selector;\n                if (!bestTokenForLevel)\n                    bestTokenForLevel = token;\n            }\n            else if (!bestTokenForLevel) {\n                bestTokenForLevel = nodeName;\n            }\n            tokens.unshift(bestTokenForLevel);\n        }\n        return uniqueCSSSelector();\n    },\n    query(root, selector) {\n        return root.querySelector(selector) || undefined;\n    },\n    queryAll(root, selector) {\n        return Array.from(root.querySelectorAll(selector));\n    }\n};\n\n\n/***/ }),\n\n/***/ \"./src/injected/injected.ts\":\n/*!**********************************!*\\\n  !*** ./src/injected/injected.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/injected/utils.ts\");\nconst cssSelectorEngine_1 = __webpack_require__(/*! ./cssSelectorEngine */ \"./src/injected/cssSelectorEngine.ts\");\nconst xpathSelectorEngine_1 = __webpack_require__(/*! ./xpathSelectorEngine */ \"./src/injected/xpathSelectorEngine.ts\");\nconst textSelectorEngine_1 = __webpack_require__(/*! ./textSelectorEngine */ \"./src/injected/textSelectorEngine.ts\");\nfunction createAttributeEngine(attribute) {\n    const engine = {\n        name: attribute,\n        create(root, target) {\n            const value = target.getAttribute(attribute);\n            if (!value)\n                return;\n            if (root.querySelector(`[${attribute}=${value}]`) === target)\n                return value;\n        },\n        query(root, selector) {\n            return root.querySelector(`[${attribute}=${selector}]`) || undefined;\n        },\n        queryAll(root, selector) {\n            return Array.from(root.querySelectorAll(`[${attribute}=${selector}]`));\n        }\n    };\n    return engine;\n}\nclass Injected {\n    constructor(customEngines) {\n        const defaultEngines = [\n            cssSelectorEngine_1.CSSEngine,\n            xpathSelectorEngine_1.XPathEngine,\n            textSelectorEngine_1.TextEngine,\n            createAttributeEngine('id'),\n            createAttributeEngine('data-testid'),\n            createAttributeEngine('data-test-id'),\n            createAttributeEngine('data-test'),\n        ];\n        this.utils = new utils_1.Utils();\n        this.engines = new Map();\n        for (const engine of [...defaultEngines, ...customEngines])\n            this.engines.set(engine.name, engine);\n    }\n    querySelector(selector, root) {\n        const parsed = this._parseSelector(selector);\n        if (!root['querySelector'])\n            throw new Error('Node is not queryable.');\n        let element = root;\n        for (const { engine, selector } of parsed) {\n            const next = engine.query(element.shadowRoot || element, selector);\n            if (!next)\n                return;\n            element = next;\n        }\n        return element;\n    }\n    querySelectorAll(selector, root) {\n        const parsed = this._parseSelector(selector);\n        if (!root['querySelectorAll'])\n            throw new Error('Node is not queryable.');\n        let set = new Set([root]);\n        for (const { engine, selector } of parsed) {\n            const newSet = new Set();\n            for (const prev of set) {\n                for (const next of engine.queryAll(prev.shadowRoot || prev, selector)) {\n                    if (newSet.has(next))\n                        continue;\n                    newSet.add(next);\n                }\n            }\n            set = newSet;\n        }\n        return Array.from(set);\n    }\n    _parseSelector(selector) {\n        let index = 0;\n        let quote;\n        let start = 0;\n        const result = [];\n        const append = () => {\n            const part = selector.substring(start, index);\n            const eqIndex = part.indexOf('=');\n            if (eqIndex === -1)\n                throw new Error(`Cannot parse selector ${selector}`);\n            const name = part.substring(0, eqIndex).trim();\n            const body = part.substring(eqIndex + 1);\n            const engine = this.engines.get(name.toLowerCase());\n            if (!engine)\n                throw new Error(`Unknown engine ${name} while parsing selector ${selector}`);\n            result.push({ engine, selector: body });\n        };\n        while (index < selector.length) {\n            const c = selector[index];\n            if (c === '\\\\' && index + 1 < selector.length) {\n                index += 2;\n            }\n            else if (c === quote) {\n                quote = undefined;\n                index++;\n            }\n            else if (!quote && c === '>' && selector[index + 1] === '>') {\n                append();\n                index += 2;\n                start = index;\n            }\n            else {\n                index++;\n            }\n        }\n        append();\n        return result;\n    }\n    isVisible(element) {\n        if (!element.ownerDocument || !element.ownerDocument.defaultView)\n            return true;\n        const style = element.ownerDocument.defaultView.getComputedStyle(element);\n        if (!style || style.visibility === 'hidden')\n            return false;\n        const rect = element.getBoundingClientRect();\n        return !!(rect.top || rect.bottom || rect.width || rect.height);\n    }\n    pollMutation(selector, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        const element = selector === undefined ? undefined : this.querySelector(selector, document);\n        const success = predicate(element);\n        if (success)\n            return Promise.resolve(success);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const observer = new MutationObserver(() => {\n            if (timedOut) {\n                observer.disconnect();\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success) {\n                observer.disconnect();\n                fulfill(success);\n            }\n        });\n        observer.observe(document, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return result;\n    }\n    pollRaf(selector, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const onRaf = () => {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success)\n                fulfill(success);\n            else\n                requestAnimationFrame(onRaf);\n        };\n        onRaf();\n        return result;\n    }\n    pollInterval(selector, pollInterval, predicate, timeout) {\n        let timedOut = false;\n        if (timeout)\n            setTimeout(() => timedOut = true, timeout);\n        let fulfill;\n        const result = new Promise(x => fulfill = x);\n        const onTimeout = () => {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const element = selector === undefined ? undefined : this.querySelector(selector, document);\n            const success = predicate(element);\n            if (success)\n                fulfill(success);\n            else\n                setTimeout(onTimeout, pollInterval);\n        };\n        onTimeout();\n        return result;\n    }\n}\nexports.default = Injected;\n\n\n/***/ }),\n\n/***/ \"./src/injected/textSelectorEngine.ts\":\n/*!********************************************!*\\\n  !*** ./src/injected/textSelectorEngine.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextEngine = {\n    name: 'text',\n    create(root, targetElement, type) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        for (let child = targetElement.firstChild; child; child = child.nextSibling) {\n            if (child.nodeType === 3 /* Node.TEXT_NODE */) {\n                const text = child.nodeValue;\n                if (!text)\n                    continue;\n                if (text.match(/^\\s*[a-zA-Z0-9]+\\s*$/) && exports.TextEngine.query(root, text.trim()) === targetElement)\n                    return text.trim();\n                if (exports.TextEngine.query(root, JSON.stringify(text)) === targetElement)\n                    return JSON.stringify(text);\n            }\n        }\n    },\n    query(root, selector) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        const matcher = createMatcher(selector);\n        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n        while (walker.nextNode()) {\n            const node = walker.currentNode;\n            const element = node.parentElement;\n            const text = node.nodeValue;\n            if (element && text && matcher(text))\n                return element;\n        }\n    },\n    queryAll(root, selector) {\n        const result = [];\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return result;\n        const matcher = createMatcher(selector);\n        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);\n        while (walker.nextNode()) {\n            const node = walker.currentNode;\n            const element = node.parentElement;\n            const text = node.nodeValue;\n            if (element && text && matcher(text))\n                result.push(element);\n        }\n        return result;\n    }\n};\nfunction createMatcher(selector) {\n    if (selector[0] === '\"' && selector[selector.length - 1] === '\"') {\n        const parsed = JSON.parse(selector);\n        return text => text === parsed;\n    }\n    if (selector[0] === '/' && selector.lastIndexOf('/') > 0) {\n        const lastSlash = selector.lastIndexOf('/');\n        const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n        return text => re.test(text);\n    }\n    selector = selector.trim();\n    return text => text.trim() === selector;\n}\n\n\n/***/ }),\n\n/***/ \"./src/injected/utils.ts\":\n/*!*******************************!*\\\n  !*** ./src/injected/utils.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Utils {\n    parentElementOrShadowHost(element) {\n        if (element.parentElement)\n            return element.parentElement;\n        if (!element.parentNode)\n            return;\n        if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n            return element.parentNode.host;\n    }\n    deepElementFromPoint(document, x, y) {\n        let container = document;\n        let element;\n        while (container) {\n            const innerElement = container.elementFromPoint(x, y);\n            if (!innerElement || element === innerElement)\n                break;\n            element = innerElement;\n            container = element.shadowRoot;\n        }\n        return element;\n    }\n}\nexports.Utils = Utils;\n\n\n/***/ }),\n\n/***/ \"./src/injected/xpathSelectorEngine.ts\":\n/*!*********************************************!*\\\n  !*** ./src/injected/xpathSelectorEngine.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst maxTextLength = 80;\nconst minMeaningfulSelectorLegth = 100;\nexports.XPathEngine = {\n    name: 'xpath',\n    create(root, targetElement, type) {\n        const maybeDocument = root instanceof Document ? root : root.ownerDocument;\n        if (!maybeDocument)\n            return;\n        const document = maybeDocument;\n        const xpathCache = new Map();\n        if (type === 'notext')\n            return createNoText(root, targetElement);\n        const tokens = [];\n        function evaluateXPath(expression) {\n            let nodes = xpathCache.get(expression);\n            if (!nodes) {\n                nodes = [];\n                try {\n                    const result = document.evaluate(expression, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n                    for (let node = result.iterateNext(); node; node = result.iterateNext()) {\n                        if (node.nodeType === Node.ELEMENT_NODE)\n                            nodes.push(node);\n                    }\n                }\n                catch (e) {\n                }\n                xpathCache.set(expression, nodes);\n            }\n            return nodes;\n        }\n        function uniqueXPathSelector(prefix) {\n            const path = tokens.slice();\n            if (prefix)\n                path.unshift(prefix);\n            let selector = '//' + path.join('/');\n            while (selector.includes('///'))\n                selector = selector.replace('///', '//');\n            if (selector.endsWith('/'))\n                selector = selector.substring(0, selector.length - 1);\n            const nodes = evaluateXPath(selector);\n            if (nodes[nodes.length - 1] === targetElement)\n                return selector;\n            // If we are looking at a small set of elements with long selector, fall back to ordinal.\n            if (nodes.length < 5 && selector.length > minMeaningfulSelectorLegth) {\n                const index = nodes.indexOf(targetElement);\n                if (index !== -1)\n                    return `(${selector})[${index + 1}]`;\n            }\n            return undefined;\n        }\n        function escapeAndCap(text) {\n            text = text.substring(0, maxTextLength);\n            // XPath 1.0 does not support quote escaping.\n            // 1. If there are no single quotes - use them.\n            if (text.indexOf(`'`) === -1)\n                return `'${text}'`;\n            // 2. If there are no double quotes - use them to enclose text.\n            if (text.indexOf(`\"`) === -1)\n                return `\"${text}\"`;\n            // 3. Otherwise, use popular |concat| trick.\n            const Q = `'`;\n            return `concat(${text.split(Q).map(token => Q + token + Q).join(`, \"'\", `)})`;\n        }\n        const defaultAttributes = new Set(['title', 'aria-label', 'disabled', 'role']);\n        const importantAttributes = new Map([\n            ['form', ['action']],\n            ['img', ['alt']],\n            ['input', ['placeholder', 'type', 'name', 'value']],\n        ]);\n        let usedTextConditions = false;\n        for (let element = targetElement; element && element !== root; element = element.parentElement) {\n            const nodeName = element.nodeName.toLowerCase();\n            const tag = nodeName === 'svg' ? '*' : nodeName;\n            const tagConditions = [];\n            if (nodeName === 'svg')\n                tagConditions.push('local-name()=\"svg\"');\n            const attrConditions = [];\n            const importantAttrs = [...defaultAttributes, ...(importantAttributes.get(tag) || [])];\n            for (const attr of importantAttrs) {\n                const value = element.getAttribute(attr);\n                if (value && value.length < maxTextLength)\n                    attrConditions.push(`normalize-space(@${attr})=${escapeAndCap(value)}`);\n                else if (value)\n                    attrConditions.push(`starts-with(normalize-space(@${attr}), ${escapeAndCap(value)})`);\n            }\n            const text = document.evaluate('normalize-space(.)', element).stringValue;\n            const textConditions = [];\n            if (tag !== 'select' && text.length && !usedTextConditions) {\n                if (text.length < maxTextLength)\n                    textConditions.push(`normalize-space(.)=${escapeAndCap(text)}`);\n                else\n                    textConditions.push(`starts-with(normalize-space(.), ${escapeAndCap(text)})`);\n                usedTextConditions = true;\n            }\n            // Always retain the last tag.\n            const conditions = [...tagConditions, ...textConditions, ...attrConditions];\n            const token = conditions.length ? `${tag}[${conditions.join(' and ')}]` : (tokens.length ? '' : tag);\n            const selector = uniqueXPathSelector(token);\n            if (selector)\n                return selector;\n            // Ordinal is the weakest signal.\n            const parent = element.parentElement;\n            let tagWithOrdinal = tag;\n            if (parent) {\n                const siblings = Array.from(parent.children);\n                const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);\n                if (sameTagSiblings.length > 1)\n                    tagWithOrdinal += `[${1 + siblings.indexOf(element)}]`;\n            }\n            // Do not include text into this token, only tag / attributes.\n            // Topmost node will get all the text.\n            const nonTextConditions = [...tagConditions, ...attrConditions];\n            const levelToken = nonTextConditions.length ? `${tagWithOrdinal}[${nonTextConditions.join(' and ')}]` : tokens.length ? '' : tagWithOrdinal;\n            tokens.unshift(levelToken);\n        }\n        return uniqueXPathSelector();\n    },\n    query(root, selector) {\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                return node;\n        }\n    },\n    queryAll(root, selector) {\n        const result = [];\n        const document = root instanceof Document ? root : root.ownerDocument;\n        if (!document)\n            return result;\n        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n        for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n            if (node.nodeType === Node.ELEMENT_NODE)\n                result.push(node);\n        }\n        return result;\n    }\n};\nfunction createNoText(root, targetElement) {\n    const steps = [];\n    for (let element = targetElement; element && element !== root; element = element.parentElement) {\n        if (element.getAttribute('id')) {\n            steps.unshift(`//*[@id=\"${element.getAttribute('id')}\"]`);\n            return steps.join('/');\n        }\n        const siblings = element.parentElement ? Array.from(element.parentElement.children) : [];\n        const similarElements = siblings.filter(sibling => element.nodeName === sibling.nodeName);\n        const index = similarElements.length === 1 ? 0 : similarElements.indexOf(element) + 1;\n        steps.unshift(index ? `${element.nodeName}[${index}]` : element.nodeName);\n    }\n    return '/' + steps.join('/');\n}\n\n\n/***/ })\n\n/******/ })).default";


/***/ }),

/***/ "./src/helper.ts":
/*!***********************!*\
  !*** ./src/helper.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __webpack_require__(/*! ./errors */ "./src/errors.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
exports.debugError = platform.debug(`pw:error`);
class Helper {
    static evaluationString(fun, ...args) {
        if (Helper.isString(fun)) {
            assert(args.length === 0, 'Cannot evaluate a string with arguments');
            return fun;
        }
        return `(${fun})(${args.map(serializeArgument).join(',')})`;
        function serializeArgument(arg) {
            if (Object.is(arg, undefined))
                return 'undefined';
            return JSON.stringify(arg);
        }
    }
    static installApiHooks(className, classType) {
        const log = platform.debug('pw:api');
        for (const methodName of Reflect.ownKeys(classType.prototype)) {
            const method = Reflect.get(classType.prototype, methodName);
            if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function')
                continue;
            const isAsync = method.constructor.name === 'AsyncFunction';
            if (!isAsync && !log.enabled)
                continue;
            Reflect.set(classType.prototype, methodName, function (...args) {
                if (log.enabled) {
                    if (args.length)
                        log(`${className}.${methodName} %o`, args);
                    else
                        log(`${className}.${methodName}`);
                }
                if (!isAsync)
                    return method.call(this, ...args);
                const syncStack = {};
                Error.captureStackTrace(syncStack);
                return method.call(this, ...args).catch((e) => {
                    const stack = syncStack.stack.substring(syncStack.stack.indexOf('\n') + 1);
                    const clientStack = stack.substring(stack.indexOf('\n'));
                    if (e instanceof Error && e.stack && !e.stack.includes(clientStack))
                        e.stack += '\n  -- ASYNC --\n' + stack;
                    throw e;
                });
            });
        }
    }
    static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return { emitter, eventName, handler };
    }
    static removeEventListeners(listeners) {
        for (const listener of listeners)
            listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
    }
    static isString(obj) {
        return typeof obj === 'string' || obj instanceof String;
    }
    static isNumber(obj) {
        return typeof obj === 'number' || obj instanceof Number;
    }
    static async waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
        let eventTimeout;
        let resolveCallback = () => { };
        let rejectCallback = () => { };
        const promise = new Promise((resolve, reject) => {
            resolveCallback = resolve;
            rejectCallback = reject;
        });
        const listener = Helper.addEventListener(emitter, eventName, event => {
            try {
                if (!predicate(event))
                    return;
                resolveCallback(event);
            }
            catch (e) {
                rejectCallback(e);
            }
        });
        if (timeout) {
            eventTimeout = setTimeout(() => {
                rejectCallback(new errors_1.TimeoutError(`Timeout exceeded while waiting for ${String(eventName)}`));
            }, timeout);
        }
        function cleanup() {
            Helper.removeEventListeners([listener]);
            clearTimeout(eventTimeout);
        }
        const result = await Promise.race([promise, abortPromise]).then(r => {
            cleanup();
            return r;
        }, e => {
            cleanup();
            throw e;
        });
        if (result instanceof Error)
            throw result;
        return result;
    }
    static async waitWithTimeout(promise, taskName, timeout) {
        let reject;
        const timeoutError = new errors_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
        const timeoutPromise = new Promise((resolve, x) => reject = x);
        let timeoutTimer = null;
        if (timeout)
            timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
        try {
            return await Promise.race([promise, timeoutPromise]);
        }
        finally {
            if (timeoutTimer)
                clearTimeout(timeoutTimer);
        }
    }
    static globToRegex(glob) {
        const tokens = ['^'];
        let inGroup;
        for (let i = 0; i < glob.length; ++i) {
            const c = glob[i];
            if (escapeGlobChars.has(c)) {
                tokens.push('\\' + c);
                continue;
            }
            if (c === '*') {
                const beforeDeep = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === '*') {
                    starCount++;
                    i++;
                }
                const afterDeep = glob[i + 1];
                const isDeep = starCount > 1 &&
                    (beforeDeep === '/' || beforeDeep === undefined) &&
                    (afterDeep === '/' || afterDeep === undefined);
                if (isDeep) {
                    tokens.push('((?:[^/]*(?:\/|$))*)');
                    i++;
                }
                else {
                    tokens.push('([^/]*)');
                }
                continue;
            }
            switch (c) {
                case '?':
                    tokens.push('.');
                    break;
                case '{':
                    inGroup = true;
                    tokens.push('(');
                    break;
                case '}':
                    inGroup = false;
                    tokens.push(')');
                    break;
                case ',':
                    if (inGroup) {
                        tokens.push('|');
                        break;
                    }
                    tokens.push('\\' + c);
                    break;
                default:
                    tokens.push(c);
            }
        }
        tokens.push('$');
        return new RegExp(tokens.join(''));
    }
    static completeUserURL(urlString) {
        if (urlString.startsWith('localhost') || urlString.startsWith('127.0.0.1'))
            urlString = 'http://' + urlString;
        return urlString;
    }
}
function assert(value, message) {
    if (!value)
        throw new Error(message);
}
exports.assert = assert;
const escapeGlobChars = new Set(['/', '$', '^', '+', '.', '(', ')', '=', '!', '|']);
exports.helper = Helper;


/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const keyboardLayout = __webpack_require__(/*! ./usKeyboardLayout */ "./src/usKeyboardLayout.ts");
exports.keypadLocation = keyboardLayout.keypadLocation;
const kModifiers = ['Alt', 'Control', 'Meta', 'Shift'];
class Keyboard {
    constructor(raw) {
        this._pressedModifiers = new Set();
        this._pressedKeys = new Set();
        this._raw = raw;
    }
    async down(key, options = { text: undefined }) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        if (kModifiers.includes(description.key))
            this._pressedModifiers.add(description.key);
        const text = options.text === undefined ? description.text : options.text;
        await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
    }
    _keyDescriptionForString(keyString) {
        const shift = this._pressedModifiers.has('Shift');
        const description = {
            key: '',
            keyCode: 0,
            keyCodeWithoutLocation: 0,
            code: '',
            text: '',
            location: 0
        };
        const definition = keyboardLayout.keyDefinitions[keyString];
        helper_1.assert(definition, `Unknown key: "${keyString}"`);
        if (definition.key)
            description.key = definition.key;
        if (shift && definition.shiftKey)
            description.key = definition.shiftKey;
        if (definition.keyCode)
            description.keyCode = definition.keyCode;
        if (shift && definition.shiftKeyCode)
            description.keyCode = definition.shiftKeyCode;
        if (definition.code)
            description.code = definition.code;
        if (definition.location)
            description.location = definition.location;
        if (description.key.length === 1)
            description.text = description.key;
        if (definition.text)
            description.text = definition.text;
        if (shift && definition.shiftText)
            description.text = definition.shiftText;
        // if any modifiers besides shift are pressed, no text should be sent
        if (this._pressedModifiers.size > 1 || (!this._pressedModifiers.has('Shift') && this._pressedModifiers.size === 1))
            description.text = '';
        if (definition.keyCodeWithoutLocation)
            description.keyCodeWithoutLocation = definition.keyCodeWithoutLocation;
        else
            description.keyCodeWithoutLocation = description.keyCode;
        return description;
    }
    async up(key) {
        const description = this._keyDescriptionForString(key);
        if (kModifiers.includes(description.key))
            this._pressedModifiers.delete(description.key);
        this._pressedKeys.delete(description.code);
        await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
    }
    async sendCharacters(text) {
        await this._raw.sendText(text);
    }
    async type(text, options) {
        const delay = (options && options.delay) || undefined;
        for (const char of text) {
            if (keyboardLayout.keyDefinitions[char]) {
                await this.press(char, { delay });
            }
            else {
                if (delay)
                    await new Promise(f => setTimeout(f, delay));
                await this.sendCharacters(char);
            }
        }
    }
    async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay)
            await new Promise(f => setTimeout(f, options.delay));
        await this.up(key);
    }
    async _ensureModifiers(modifiers) {
        for (const modifier of modifiers) {
            if (!kModifiers.includes(modifier))
                throw new Error('Uknown modifier ' + modifier);
        }
        const restore = Array.from(this._pressedModifiers);
        const promises = [];
        for (const key of kModifiers) {
            const needDown = modifiers.includes(key);
            const isDown = this._pressedModifiers.has(key);
            if (needDown && !isDown)
                promises.push(this.down(key));
            else if (!needDown && isDown)
                promises.push(this.up(key));
        }
        await Promise.all(promises);
        return restore;
    }
    _modifiers() {
        return this._pressedModifiers;
    }
}
exports.Keyboard = Keyboard;
class Mouse {
    constructor(raw, keyboard) {
        this._x = 0;
        this._y = 0;
        this._lastButton = 'none';
        this._buttons = new Set();
        this._raw = raw;
        this._keyboard = keyboard;
    }
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const fromX = this._x;
        const fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
            const middleX = fromX + (x - fromX) * (i / steps);
            const middleY = fromY + (y - fromY) * (i / steps);
            await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers());
        }
    }
    async down(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._lastButton = button;
        this._buttons.add(button);
        await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
    }
    async up(options = {}) {
        const { button = 'left', clickCount = 1 } = options;
        this._lastButton = 'none';
        this._buttons.delete(button);
        await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
    }
    async click(x, y, options = {}) {
        const { delay = null } = options;
        if (delay !== null) {
            await Promise.all([
                this.move(x, y),
                this.down(options),
            ]);
            await new Promise(f => setTimeout(f, delay));
            await this.up(options);
        }
        else {
            await Promise.all([
                this.move(x, y),
                this.down(options),
                this.up(options),
            ]);
        }
    }
    async dblclick(x, y, options = {}) {
        const { delay = null } = options;
        if (delay !== null) {
            await this.move(x, y);
            await this.down({ ...options, clickCount: 1 });
            await new Promise(f => setTimeout(f, delay));
            await this.up({ ...options, clickCount: 1 });
            await new Promise(f => setTimeout(f, delay));
            await this.down({ ...options, clickCount: 2 });
            await new Promise(f => setTimeout(f, delay));
            await this.up({ ...options, clickCount: 2 });
        }
        else {
            await Promise.all([
                this.move(x, y),
                this.down({ ...options, clickCount: 1 }),
                this.up({ ...options, clickCount: 1 }),
                this.down({ ...options, clickCount: 2 }),
                this.up({ ...options, clickCount: 2 }),
            ]);
        }
    }
    async tripleclick(x, y, options = {}) {
        const { delay = null } = options;
        if (delay !== null) {
            await this.move(x, y);
            await this.down({ ...options, clickCount: 1 });
            await new Promise(f => setTimeout(f, delay));
            await this.up({ ...options, clickCount: 1 });
            await new Promise(f => setTimeout(f, delay));
            await this.down({ ...options, clickCount: 2 });
            await new Promise(f => setTimeout(f, delay));
            await this.up({ ...options, clickCount: 2 });
            await new Promise(f => setTimeout(f, delay));
            await this.down({ ...options, clickCount: 3 });
            await new Promise(f => setTimeout(f, delay));
            await this.up({ ...options, clickCount: 3 });
        }
        else {
            await Promise.all([
                this.move(x, y),
                this.down({ ...options, clickCount: 1 }),
                this.up({ ...options, clickCount: 1 }),
                this.down({ ...options, clickCount: 2 }),
                this.up({ ...options, clickCount: 2 }),
                this.down({ ...options, clickCount: 3 }),
                this.up({ ...options, clickCount: 3 }),
            ]);
        }
    }
}
exports.Mouse = Mouse;


/***/ }),

/***/ "./src/javascript.ts":
/*!***************************!*\
  !*** ./src/javascript.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class ExecutionContext {
    constructor(delegate) {
        this.evaluate = async (pageFunction, ...args) => {
            return this._evaluate(true /* returnByValue */, pageFunction, ...args);
        };
        this.evaluateHandle = async (pageFunction, ...args) => {
            return this._evaluate(false /* returnByValue */, pageFunction, ...args);
        };
        this._delegate = delegate;
    }
    _evaluate(returnByValue, pageFunction, ...args) {
        return this._delegate.evaluate(this, returnByValue, pageFunction, ...args);
    }
    _createHandle(remoteObject) {
        return new JSHandle(this, remoteObject);
    }
}
exports.ExecutionContext = ExecutionContext;
class JSHandle {
    constructor(context, remoteObject) {
        this._disposed = false;
        this.evaluate = (pageFunction, ...args) => {
            return this._context.evaluate(pageFunction, this, ...args);
        };
        this.evaluateHandle = (pageFunction, ...args) => {
            return this._context.evaluateHandle(pageFunction, this, ...args);
        };
        this._context = context;
        this._remoteObject = remoteObject;
    }
    async getProperty(propertyName) {
        const objectHandle = await this.evaluateHandle((object, propertyName) => {
            const result = { __proto__: null };
            result[propertyName] = object[propertyName];
            return result;
        }, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName) || null;
        await objectHandle.dispose();
        return result;
    }
    getProperties() {
        return this._context._delegate.getProperties(this);
    }
    jsonValue() {
        return this._context._delegate.handleJSONValue(this);
    }
    asElement() {
        return null;
    }
    async dispose() {
        if (this._disposed)
            return;
        this._disposed = true;
        await this._context._delegate.releaseHandle(this);
    }
    toString() {
        return this._context._delegate.handleToString(this, true /* includeType */);
    }
}
exports.JSHandle = JSHandle;


/***/ }),

/***/ "./src/network.ts":
/*!************************!*\
  !*** ./src/network.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
function filterCookies(cookies, urls) {
    const parsedURLs = urls.map(s => new URL(s));
    // Chromiums's cookies are missing sameSite when it is 'None'
    return cookies.filter(c => {
        if (!parsedURLs.length)
            return true;
        for (const parsedURL of parsedURLs) {
            if (parsedURL.hostname !== c.domain)
                continue;
            if (!parsedURL.pathname.startsWith(c.path))
                continue;
            if ((parsedURL.protocol === 'https:') !== c.secure)
                continue;
            return true;
        }
        return false;
    });
}
exports.filterCookies = filterCookies;
function rewriteCookies(cookies) {
    return cookies.map(c => {
        helper_1.assert(c.name, 'Cookie should have a name');
        helper_1.assert(c.value, 'Cookie should have a value');
        helper_1.assert(c.url || (c.domain && c.path), 'Cookie should have a url or a domain/path pair');
        helper_1.assert(!(c.url && c.domain), 'Cookie should have either url or domain');
        helper_1.assert(!(c.url && c.path), 'Cookie should have either url or domain');
        const copy = { ...c };
        if (copy.url) {
            helper_1.assert(copy.url !== 'about:blank', `Blank page can not have cookie "${c.name}"`);
            helper_1.assert(!copy.url.startsWith('data:'), `Data URL page can not have cookie "${c.name}"`);
            const url = new URL(copy.url);
            copy.domain = url.hostname;
            copy.path = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
            copy.secure = url.protocol === 'https:';
        }
        return copy;
    });
}
exports.rewriteCookies = rewriteCookies;
function stripFragmentFromUrl(url) {
    if (!url.indexOf('#'))
        return url;
    const parsed = new URL(url);
    parsed.hash = '';
    return parsed.href;
}
class Request {
    constructor(delegate, frame, redirectChain, documentId, url, resourceType, method, postData, headers) {
        this._response = null;
        this._failureText = null;
        this._waitForResponsePromiseCallback = () => { };
        this._waitForFinishedPromiseCallback = () => { };
        this._interceptionHandled = false;
        helper_1.assert(!url.startsWith('data:'), 'Data urls should not fire requests');
        this._delegate = delegate;
        this._frame = frame;
        this._redirectChain = redirectChain;
        this._finalRequest = this;
        for (const request of redirectChain)
            request._finalRequest = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        this._waitForResponsePromise = new Promise(f => this._waitForResponsePromiseCallback = f);
        this._waitForFinishedPromise = new Promise(f => this._waitForFinishedPromiseCallback = f);
        this._isFavicon = url.endsWith('/favicon.ico');
    }
    _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForFinishedPromiseCallback(null);
    }
    url() {
        return this._url;
    }
    resourceType() {
        return this._resourceType;
    }
    method() {
        return this._method;
    }
    postData() {
        return this._postData;
    }
    headers() {
        return this._headers;
    }
    response() {
        return this._response;
    }
    async _waitForFinished() {
        return this._waitForFinishedPromise;
    }
    async _waitForResponse() {
        const response = await this._waitForResponsePromise;
        await response._finishedPromise;
        return response;
    }
    _setResponse(response) {
        this._response = response;
        this._waitForResponsePromiseCallback(response);
        response._finishedPromise.then(() => this._waitForFinishedPromiseCallback(response));
    }
    frame() {
        return this._frame;
    }
    isNavigationRequest() {
        return !!this._documentId;
    }
    redirectChain() {
        return this._redirectChain.slice();
    }
    failure() {
        if (this._failureText === null)
            return null;
        return {
            errorText: this._failureText
        };
    }
    async abort(errorCode = 'failed') {
        helper_1.assert(this._delegate, 'Request Interception is not enabled!');
        helper_1.assert(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        await this._delegate.abort(errorCode);
    }
    async fulfill(response) {
        helper_1.assert(this._delegate, 'Request Interception is not enabled!');
        helper_1.assert(!this._interceptionHandled, 'Request is already handled!');
        this._interceptionHandled = true;
        await this._delegate.fulfill(response);
    }
    async continue(overrides = {}) {
        helper_1.assert(this._delegate, 'Request Interception is not enabled!');
        helper_1.assert(!this._interceptionHandled, 'Request is already handled!');
        await this._delegate.continue(overrides);
    }
    _isIntercepted() {
        return !!this._delegate;
    }
}
exports.Request = Request;
class Response {
    constructor(request, status, statusText, headers, getResponseBodyCallback) {
        this._contentPromise = null;
        this._request = request;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._finishedPromise = new Promise(f => {
            this._finishedPromiseCallback = f;
        });
        this._request._setResponse(this);
    }
    _requestFinished(error) {
        this._finishedPromiseCallback.call(null, error);
    }
    url() {
        return this._url;
    }
    ok() {
        return this._status === 0 || (this._status >= 200 && this._status <= 299);
    }
    status() {
        return this._status;
    }
    statusText() {
        return this._statusText;
    }
    headers() {
        return this._headers;
    }
    buffer() {
        if (!this._contentPromise) {
            this._contentPromise = this._finishedPromise.then(async (error) => {
                if (error)
                    throw error;
                return this._getResponseBodyCallback();
            });
        }
        return this._contentPromise;
    }
    async text() {
        const content = await this.buffer();
        return content.toString('utf8');
    }
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    request() {
        return this._request;
    }
    frame() {
        return this._request.frame();
    }
}
exports.Response = Response;
// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.
exports.STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': 'I\'m a teapot',
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};


/***/ }),

/***/ "./src/page.ts":
/*!*********************!*\
  !*** ./src/page.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const frames = __webpack_require__(/*! ./frames */ "./src/frames.ts");
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const input = __webpack_require__(/*! ./input */ "./src/input.ts");
const js = __webpack_require__(/*! ./javascript */ "./src/javascript.ts");
const screenshotter_1 = __webpack_require__(/*! ./screenshotter */ "./src/screenshotter.ts");
const timeoutSettings_1 = __webpack_require__(/*! ./timeoutSettings */ "./src/timeoutSettings.ts");
const types = __webpack_require__(/*! ./types */ "./src/types.ts");
const events_1 = __webpack_require__(/*! ./events */ "./src/events.ts");
const console_1 = __webpack_require__(/*! ./console */ "./src/console.ts");
const accessibility = __webpack_require__(/*! ./accessibility */ "./src/accessibility.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
class Page extends platform.EventEmitter {
    constructor(delegate, browserContext) {
        super();
        this._closed = false;
        this._disconnected = false;
        this._pageBindings = new Map();
        this._workers = new Map();
        this._requestHandlers = [];
        this.evaluateHandle = async (pageFunction, ...args) => {
            return this.mainFrame().evaluateHandle(pageFunction, ...args);
        };
        this.$eval = async (selector, pageFunction, ...args) => {
            return this.mainFrame().$eval(selector, pageFunction, ...args);
        };
        this.$$eval = async (selector, pageFunction, ...args) => {
            return this.mainFrame().$$eval(selector, pageFunction, ...args);
        };
        this.evaluate = async (pageFunction, ...args) => {
            return this.mainFrame().evaluate(pageFunction, ...args);
        };
        this._delegate = delegate;
        this._closedCallback = () => { };
        this._closedPromise = new Promise(f => this._closedCallback = f);
        this._disconnectedCallback = () => { };
        this._disconnectedPromise = new Promise(f => this._disconnectedCallback = f);
        this._browserContext = browserContext;
        let viewportSize = null;
        if (browserContext._options.viewport) {
            viewportSize = {
                width: browserContext._options.viewport.width,
                height: browserContext._options.viewport.height,
            };
        }
        this._state = {
            viewportSize,
            mediaType: null,
            colorScheme: null,
            extraHTTPHeaders: null,
            cacheEnabled: null,
            interceptNetwork: null,
            offlineMode: null,
            credentials: null,
            hasTouch: null,
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard);
        this.mouse = new input.Mouse(delegate.rawMouse, this.keyboard);
        this._timeoutSettings = new timeoutSettings_1.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new screenshotter_1.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
            this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
    }
    _didClose() {
        helper_1.assert(!this._closed, 'Page closed twice');
        this._closed = true;
        this.emit(events_1.Events.Page.Close);
        this._closedCallback();
    }
    _didCrash() {
        const error = new Error('Page crashed!');
        // Do not report node.js stack.
        error.stack = 'Error: ' + error.message; // Stack is supposed to contain error message as the first line.
        this.emit('error', error);
    }
    _didDisconnect() {
        helper_1.assert(!this._disconnected, 'Page disconnected twice');
        this._disconnected = true;
        this._disconnectedCallback(new Error('Target closed'));
    }
    async _onFileChooserOpened(handle) {
        const multiple = await handle.evaluate(element => !!element.multiple);
        if (!this.listenerCount(events_1.Events.Page.FileChooser)) {
            await handle.dispose();
            return;
        }
        const fileChooser = { element: handle, multiple };
        this.emit(events_1.Events.Page.FileChooser, fileChooser);
    }
    context() {
        return this._browserContext;
    }
    async opener() {
        return await this._delegate.opener();
    }
    mainFrame() {
        return this._frameManager.mainFrame();
    }
    frames() {
        return this._frameManager.frames();
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    async $(selector) {
        return this.mainFrame().$(selector);
    }
    async waitForSelector(selector, options) {
        return this.mainFrame().waitForSelector(selector, options);
    }
    async $wait(selector, options) {
        return this.mainFrame().$wait(selector, options);
    }
    async $$(selector) {
        return this.mainFrame().$$(selector);
    }
    async addScriptTag(options) {
        return this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
        return this.mainFrame().addStyleTag(options);
    }
    async exposeFunction(name, playwrightFunction) {
        if (this._pageBindings.has(name))
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        this._pageBindings.set(name, playwrightFunction);
        await this._delegate.exposeBinding(name, helper_1.helper.evaluationString(addPageBinding, name));
        function addPageBinding(bindingName) {
            const binding = window[bindingName];
            window[bindingName] = (...args) => {
                const me = window[bindingName];
                let callbacks = me['callbacks'];
                if (!callbacks) {
                    callbacks = new Map();
                    me['callbacks'] = callbacks;
                }
                const seq = (me['lastSeq'] || 0) + 1;
                me['lastSeq'] = seq;
                const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
                binding(JSON.stringify({ name: bindingName, seq, args }));
                return promise;
            };
        }
    }
    setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = {};
        for (const key of Object.keys(headers)) {
            const value = headers[key];
            helper_1.assert(helper_1.helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            this._state.extraHTTPHeaders[key] = value;
        }
        return this._delegate.setExtraHTTPHeaders(headers);
    }
    async _onBindingCalled(payload, context) {
        const { name, seq, args } = JSON.parse(payload);
        let expression = null;
        try {
            const result = await this._pageBindings.get(name)(...args);
            expression = helper_1.helper.evaluationString(deliverResult, name, seq, result);
        }
        catch (error) {
            if (error instanceof Error)
                expression = helper_1.helper.evaluationString(deliverError, name, seq, error.message, error.stack);
            else
                expression = helper_1.helper.evaluationString(deliverErrorValue, name, seq, error);
        }
        context.evaluate(expression).catch(helper_1.debugError);
        function deliverResult(name, seq, result) {
            window[name]['callbacks'].get(seq).resolve(result);
            window[name]['callbacks'].delete(seq);
        }
        function deliverError(name, seq, message, stack) {
            const error = new Error(message);
            error.stack = stack;
            window[name]['callbacks'].get(seq).reject(error);
            window[name]['callbacks'].delete(seq);
        }
        function deliverErrorValue(name, seq, value) {
            window[name]['callbacks'].get(seq).reject(value);
            window[name]['callbacks'].delete(seq);
        }
    }
    _addConsoleMessage(type, args, location, text) {
        const message = new console_1.ConsoleMessage(type, text, args, location);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(events_1.Events.Page.Console))
            args.forEach(arg => arg.dispose());
        else
            this.emit(events_1.Events.Page.Console, message);
    }
    url() {
        return this.mainFrame().url();
    }
    async content() {
        return this.mainFrame().content();
    }
    async setContent(html, options) {
        return this.mainFrame().setContent(html, options);
    }
    async goto(url, options) {
        return this.mainFrame().goto(url, options);
    }
    async reload(options) {
        const waitPromise = this.waitForNavigation(options);
        await this._delegate.reload();
        return waitPromise;
    }
    async waitForNavigation(options) {
        return this.mainFrame().waitForNavigation(options);
    }
    async waitForLoadState(options) {
        return this.mainFrame().waitForLoadState(options);
    }
    async waitForEvent(event, optionsOrPredicate = {}) {
        if (typeof optionsOrPredicate === 'function')
            optionsOrPredicate = { predicate: optionsOrPredicate };
        const { timeout = this._timeoutSettings.timeout(), predicate = () => true } = optionsOrPredicate;
        return helper_1.helper.waitForEvent(this, event, (...args) => !!predicate(...args), timeout, this._disconnectedPromise);
    }
    async waitForRequest(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return helper_1.helper.waitForEvent(this, events_1.Events.Page.Request, (request) => {
            if (helper_1.helper.isString(urlOrPredicate) || urlOrPredicate instanceof RegExp)
                return platform.urlMatches(request.url(), urlOrPredicate);
            return urlOrPredicate(request);
        }, timeout, this._disconnectedPromise);
    }
    async waitForResponse(urlOrPredicate, options = {}) {
        const { timeout = this._timeoutSettings.timeout() } = options;
        return helper_1.helper.waitForEvent(this, events_1.Events.Page.Response, (response) => {
            if (helper_1.helper.isString(urlOrPredicate) || urlOrPredicate instanceof RegExp)
                return platform.urlMatches(response.url(), urlOrPredicate);
            return urlOrPredicate(response);
        }, timeout, this._disconnectedPromise);
    }
    async goBack(options) {
        const waitPromise = this.waitForNavigation(options);
        const result = await this._delegate.goBack();
        if (!result) {
            waitPromise.catch(() => { });
            return null;
        }
        return waitPromise;
    }
    async goForward(options) {
        const waitPromise = this.waitForNavigation(options);
        const result = await this._delegate.goForward();
        if (!result) {
            waitPromise.catch(() => { });
            return null;
        }
        return waitPromise;
    }
    async emulateMedia(options) {
        helper_1.assert(!options.media || types.mediaTypes.has(options.media), 'Unsupported media: ' + options.media);
        helper_1.assert(!options.colorScheme || types.colorSchemes.has(options.colorScheme), 'Unsupported color scheme: ' + options.colorScheme);
        if (options.media !== undefined)
            this._state.mediaType = options.media;
        if (options.colorScheme !== undefined)
            this._state.colorScheme = options.colorScheme;
        await this._delegate.setEmulateMedia(this._state.mediaType, this._state.colorScheme);
    }
    async setViewportSize(viewportSize) {
        this._state.viewportSize = { ...viewportSize };
        await this._delegate.setViewportSize(this._state.viewportSize);
    }
    viewportSize() {
        return this._state.viewportSize;
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
        const source = helper_1.helper.evaluationString(pageFunction, ...args);
        await this._delegate.evaluateOnNewDocument(source);
    }
    async setCacheEnabled(enabled = true) {
        if (this._state.cacheEnabled === enabled)
            return;
        this._state.cacheEnabled = enabled;
        await this._delegate.setCacheEnabled(enabled);
    }
    async route(url, handler) {
        if (!this._state.interceptNetwork) {
            this._state.interceptNetwork = true;
            await this._delegate.setRequestInterception(true);
        }
        this._requestHandlers.push({ url, handler });
    }
    _requestStarted(request) {
        this.emit(events_1.Events.Page.Request, request);
        if (!request._isIntercepted())
            return;
        for (const { url, handler } of this._requestHandlers) {
            if (platform.urlMatches(request.url(), url)) {
                handler(request);
                return;
            }
        }
        request.continue();
    }
    async setOfflineMode(enabled) {
        if (this._state.offlineMode === enabled)
            return;
        this._state.offlineMode = enabled;
        await this._delegate.setOfflineMode(enabled);
    }
    async authenticate(credentials) {
        this._state.credentials = credentials;
        await this._delegate.authenticate(credentials);
    }
    async screenshot(options) {
        return this._screenshotter.screenshotPage(options);
    }
    async title() {
        return this.mainFrame().title();
    }
    async close(options = { runBeforeUnload: undefined }) {
        if (this._closed)
            return;
        helper_1.assert(!this._disconnected, 'Protocol error: Connection closed. Most likely the page has been closed.');
        const runBeforeUnload = !!options.runBeforeUnload;
        await this._delegate.closePage(runBeforeUnload);
        if (!runBeforeUnload)
            await this._closedPromise;
        if (this._ownedContext)
            await this._ownedContext.close();
    }
    isClosed() {
        return this._closed;
    }
    async click(selector, options) {
        return this.mainFrame().click(selector, options);
    }
    async dblclick(selector, options) {
        return this.mainFrame().dblclick(selector, options);
    }
    async tripleclick(selector, options) {
        return this.mainFrame().tripleclick(selector, options);
    }
    async fill(selector, value, options) {
        return this.mainFrame().fill(selector, value, options);
    }
    async focus(selector, options) {
        return this.mainFrame().focus(selector, options);
    }
    async hover(selector, options) {
        return this.mainFrame().hover(selector, options);
    }
    async select(selector, value, options) {
        return this.mainFrame().select(selector, value, options);
    }
    async type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
    }
    async check(selector, options) {
        return this.mainFrame().check(selector, options);
    }
    async uncheck(selector, options) {
        return this.mainFrame().uncheck(selector, options);
    }
    async waitFor(selectorOrFunctionOrTimeout, options, ...args) {
        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);
    }
    async waitForFunction(pageFunction, options, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
    workers() {
        return [...this._workers.values()];
    }
    _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(events_1.Events.Page.WorkerCreated, worker);
    }
    _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
            return;
        this.emit(events_1.Events.Page.WorkerDestroyed, worker);
        this._workers.delete(workerId);
    }
    _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
            this.emit(events_1.Events.Page.WorkerDestroyed, worker);
            this._workers.delete(workerId);
        }
    }
    on(event, listener) {
        if (event === events_1.Events.Page.FileChooser) {
            if (!this.listenerCount(event))
                this._delegate.setFileChooserIntercepted(true);
        }
        super.on(event, listener);
        return this;
    }
    removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === events_1.Events.Page.FileChooser && !this.listenerCount(event))
            this._delegate.setFileChooserIntercepted(false);
        return this;
    }
}
exports.Page = Page;
class Worker {
    constructor(url) {
        this._existingExecutionContext = null;
        this.evaluate = async (pageFunction, ...args) => {
            return (await this._executionContextPromise).evaluate(pageFunction, ...args);
        };
        this.evaluateHandle = async (pageFunction, ...args) => {
            return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
        };
        this._url = url;
        this._executionContextCallback = () => { };
        this._executionContextPromise = new Promise(x => this._executionContextCallback = x);
    }
    _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(delegate);
        this._executionContextCallback(this._existingExecutionContext);
    }
    url() {
        return this._url;
    }
}
exports.Worker = Worker;


/***/ }),

/***/ "./src/platform.ts":
/*!*************************!*\
  !*** ./src/platform.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate) {
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Note: this is the only file outside of src/server which can import external dependencies.
// All dependencies must be listed in web.webpack.config.js to avoid bundling them.
const nodeEvents = __webpack_require__(/*! events */ "events");
const nodeFS = __webpack_require__(/*! fs */ "events");
const nodePath = __webpack_require__(/*! path */ "events");
const nodeDebug = __webpack_require__(/*! debug */ "events");
const nodeBuffer = __webpack_require__(/*! buffer */ "events");
const jpeg = __webpack_require__(/*! jpeg-js */ "events");
const png = __webpack_require__(/*! pngjs */ "events");
const http = __webpack_require__(/*! http */ "events");
const https = __webpack_require__(/*! https */ "events");
const NodeWebSocket = __webpack_require__(/*! ws */ "events");
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
exports.isNode = typeof process === 'object' && !!process && typeof process.versions === 'object' && !!process.versions && !!process.versions.node;
function promisify(nodeFunction) {
    helper_1.assert(exports.isNode);
    function promisified(...args) {
        return new Promise((resolve, reject) => {
            function callback(err, ...result) {
                if (err)
                    return reject(err);
                if (result.length === 1)
                    return resolve(result[0]);
                return resolve(result);
            }
            nodeFunction.call(null, ...args, callback);
        });
    }
    return promisified;
}
exports.promisify = promisify;
exports.EventEmitter = exports.isNode ? nodeEvents.EventEmitter : (class EventEmitterImpl {
    constructor() {
        this._listeners = new Map();
    }
    on(event, listener) {
        let set = this._listeners.get(event);
        if (!set) {
            set = new Set();
            this._listeners.set(event, set);
        }
        set.add(listener);
        return this;
    }
    addListener(event, listener) {
        return this.on(event, listener);
    }
    once(event, listener) {
        const wrapped = (...args) => {
            this.removeListener(event, wrapped);
            listener(...args);
        };
        return this.addListener(event, wrapped);
    }
    removeListener(event, listener) {
        const set = this._listeners.get(event);
        if (set)
            set.delete(listener);
        return this;
    }
    emit(event, ...args) {
        const set = this._listeners.get(event);
        if (!set || !set.size)
            return true;
        const dispatch = !this._deliveryQueue;
        if (!this._deliveryQueue)
            this._deliveryQueue = [];
        for (const listener of set)
            this._deliveryQueue.push({ listener, args });
        if (!dispatch)
            return true;
        for (let index = 0; index < this._deliveryQueue.length; index++) {
            const { listener, args } = this._deliveryQueue[index];
            listener(...args);
        }
        this._deliveryQueue = undefined;
        return true;
    }
    listenerCount(event) {
        const set = this._listeners.get(event);
        return set ? set.size : 0;
    }
});
exports.debug = exports.isNode ? nodeDebug : (function debug(namespace) {
    return () => { };
});
exports.Buffer = exports.isNode ? nodeBuffer.Buffer : (class BufferImpl {
    constructor(data, encoding = 'utf8') {
        if (data instanceof ArrayBuffer) {
            this.data = data;
        }
        else {
            if (encoding === 'base64') {
                const binary = atob(data);
                this.data = new ArrayBuffer(binary.length * 2);
                const view = new Uint16Array(this.data);
                for (let i = 0; i < binary.length; i++)
                    view[i] = binary.charCodeAt(i);
            }
            else if (encoding === 'utf8') {
                const encoder = new TextEncoder();
                this.data = encoder.encode(data).buffer;
            }
            else {
                throw new Error('Unsupported encoding "' + encoding + '"');
            }
        }
    }
    static from(data, encoding = 'utf8') {
        return new BufferImpl(data, encoding);
    }
    static byteLength(buffer, encoding = 'utf8') {
        if (helper_1.helper.isString(buffer))
            buffer = new BufferImpl(buffer, encoding);
        return buffer.data.byteLength;
    }
    static concat(buffers) {
        if (!buffers.length)
            return new BufferImpl(new ArrayBuffer(0));
        if (buffers.length === 1)
            return buffers[0];
        const view = new Uint8Array(buffers.reduce((a, b) => a + b.data.byteLength, 0));
        let offset = 0;
        for (const buffer of buffers) {
            view.set(new Uint8Array(buffer.data), offset);
            offset += buffer.data.byteLength;
        }
        return new BufferImpl(view.buffer);
    }
    toString(encoding = 'utf8') {
        if (encoding === 'base64') {
            const binary = String.fromCharCode(...new Uint16Array(this.data));
            return btoa(binary);
        }
        const decoder = new TextDecoder(encoding, { fatal: true });
        return decoder.decode(this.data);
    }
});
function assertFileAccess() {
    helper_1.assert(exports.isNode, 'Working with filesystem using "path" is only supported in Node.js');
}
async function readFileAsync(file, encoding) {
    assertFileAccess();
    return await promisify(nodeFS.readFile)(file, encoding);
}
exports.readFileAsync = readFileAsync;
async function writeFileAsync(file, data) {
    assertFileAccess();
    return await promisify(nodeFS.writeFile)(file, data);
}
exports.writeFileAsync = writeFileAsync;
function basename(file) {
    assertFileAccess();
    return nodePath.basename(file);
}
exports.basename = basename;
async function openFdAsync(file, flags) {
    assertFileAccess();
    return await promisify(nodeFS.open)(file, flags);
}
exports.openFdAsync = openFdAsync;
async function writeFdAsync(fd, buffer) {
    assertFileAccess();
    return await promisify(nodeFS.write)(fd, buffer);
}
exports.writeFdAsync = writeFdAsync;
async function closeFdAsync(fd) {
    assertFileAccess();
    return await promisify(nodeFS.close)(fd);
}
exports.closeFdAsync = closeFdAsync;
function getMimeType(file) {
    const extension = file.substring(file.lastIndexOf('.') + 1);
    return extensionToMime[extension] || 'application/octet-stream';
}
exports.getMimeType = getMimeType;
function urlMatches(urlString, match) {
    if (match === undefined || match === '')
        return true;
    if (helper_1.helper.isString(match))
        match = helper_1.helper.globToRegex(match);
    if (match instanceof RegExp)
        return match.test(urlString);
    if (typeof match === 'string' && match === urlString)
        return true;
    const url = new URL(urlString);
    if (typeof match === 'string')
        return url.pathname === match;
    helper_1.assert(typeof match === 'function', 'url parameter should be string, RegExp or function');
    return match(url);
}
exports.urlMatches = urlMatches;
function pngToJpeg(buffer) {
    helper_1.assert(exports.isNode, 'Converting from png to jpeg is only supported in Node.js');
    return jpeg.encode(png.PNG.sync.read(buffer)).data;
}
exports.pngToJpeg = pngToJpeg;
function nodeFetch(url) {
    let resolve;
    let reject = () => { };
    const promise = new Promise((res, rej) => { resolve = res; reject = rej; });
    const endpointURL = new URL(url);
    const protocol = endpointURL.protocol === 'https:' ? https : http;
    const request = protocol.request(endpointURL, res => {
        let data = '';
        if (res.statusCode !== 200) {
            // Consume response data to free up memory.
            res.resume();
            reject(new Error('HTTP ' + res.statusCode));
            return;
        }
        res.setEncoding('utf8');
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
    });
    request.on('error', reject);
    request.end();
    return promise;
}
function fetchUrl(url) {
    if (exports.isNode)
        return nodeFetch(url);
    return fetch(url).then(response => {
        if (!response.ok)
            throw new Error('HTTP ' + response.status + ' ' + response.statusText);
        return response.text();
    });
}
exports.fetchUrl = fetchUrl;
// See https://joel.tools/microtasks/
function makeWaitForNextTask() {
    helper_1.assert(exports.isNode, 'Waitng for the next task is only supported in nodejs');
    if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
    // Unlike Node 11, Node 10 and less have a bug with Task and MicroTask execution order:
    // - https://github.com/nodejs/node/issues/22257
    //
    // So we can't simply run setImmediate to dispatch code in a following task.
    // However, we can run setImmediate from-inside setImmediate to make sure we're getting
    // in the following task.
    let spinning = false;
    const callbacks = [];
    const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
            spinning = false;
            return;
        }
        setImmediate(loop);
        // Make sure to call callback() as the last thing since it's
        // untrusted code that might throw.
        callback();
    };
    return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
            spinning = true;
            setImmediate(loop);
        }
    };
}
exports.makeWaitForNextTask = makeWaitForNextTask;
class WebSocketTransport {
    constructor(url) {
        this._ws = (exports.isNode ? new NodeWebSocket(url, [], {
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
        }) : new WebSocket(url));
        this._connectPromise = new Promise(fulfill => {
            this._ws.addEventListener('open', () => fulfill(null));
            this._ws.addEventListener('error', event => fulfill(new Error('WebSocket error: ' + event.message)));
        });
        // The 'ws' module in node sometimes sends us multiple messages in a single task.
        // In Web, all IO callbacks (e.g. WebSocket callbacks)
        // are dispatched into separate tasks, so there's no need
        // to do anything extra.
        const messageWrap = exports.isNode ? makeWaitForNextTask() : cb => cb();
        this._ws.addEventListener('message', event => {
            messageWrap(() => {
                if (this.onmessage)
                    this.onmessage.call(null, event.data);
            });
        });
        this._ws.addEventListener('close', event => {
            if (this.onclose)
                this.onclose.call(null);
        });
        // Silently ignore all errors - we don't know what to do with them.
        this._ws.addEventListener('error', () => { });
    }
    async send(message) {
        const error = await this._connectPromise;
        if (error)
            throw error;
        this._ws.send(message);
    }
    close() {
        this._ws.close();
    }
}
exports.WebSocketTransport = WebSocketTransport;
const extensionToMime = {
    'ai': 'application/postscript',
    'apng': 'image/apng',
    'appcache': 'text/cache-manifest',
    'au': 'audio/basic',
    'bmp': 'image/bmp',
    'cer': 'application/pkix-cert',
    'cgm': 'image/cgm',
    'coffee': 'text/coffeescript',
    'conf': 'text/plain',
    'crl': 'application/pkix-crl',
    'css': 'text/css',
    'csv': 'text/csv',
    'def': 'text/plain',
    'doc': 'application/msword',
    'dot': 'application/msword',
    'drle': 'image/dicom-rle',
    'dtd': 'application/xml-dtd',
    'ear': 'application/java-archive',
    'emf': 'image/emf',
    'eps': 'application/postscript',
    'exr': 'image/aces',
    'fits': 'image/fits',
    'g3': 'image/g3fax',
    'gbr': 'application/rpki-ghostbusters',
    'gif': 'image/gif',
    'glb': 'model/gltf-binary',
    'gltf': 'model/gltf+json',
    'gz': 'application/gzip',
    'h261': 'video/h261',
    'h263': 'video/h263',
    'h264': 'video/h264',
    'heic': 'image/heic',
    'heics': 'image/heic-sequence',
    'heif': 'image/heif',
    'heifs': 'image/heif-sequence',
    'htm': 'text/html',
    'html': 'text/html',
    'ics': 'text/calendar',
    'ief': 'image/ief',
    'ifb': 'text/calendar',
    'iges': 'model/iges',
    'igs': 'model/iges',
    'in': 'text/plain',
    'ini': 'text/plain',
    'jade': 'text/jade',
    'jar': 'application/java-archive',
    'jls': 'image/jls',
    'jp2': 'image/jp2',
    'jpe': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'jpf': 'image/jpx',
    'jpg': 'image/jpeg',
    'jpg2': 'image/jp2',
    'jpgm': 'video/jpm',
    'jpgv': 'video/jpeg',
    'jpm': 'image/jpm',
    'jpx': 'image/jpx',
    'js': 'application/javascript',
    'json': 'application/json',
    'json5': 'application/json5',
    'jsx': 'text/jsx',
    'jxr': 'image/jxr',
    'kar': 'audio/midi',
    'ktx': 'image/ktx',
    'less': 'text/less',
    'list': 'text/plain',
    'litcoffee': 'text/coffeescript',
    'log': 'text/plain',
    'm1v': 'video/mpeg',
    'm21': 'application/mp21',
    'm2a': 'audio/mpeg',
    'm2v': 'video/mpeg',
    'm3a': 'audio/mpeg',
    'm4a': 'audio/mp4',
    'm4p': 'application/mp4',
    'man': 'text/troff',
    'manifest': 'text/cache-manifest',
    'markdown': 'text/markdown',
    'mathml': 'application/mathml+xml',
    'md': 'text/markdown',
    'mdx': 'text/mdx',
    'me': 'text/troff',
    'mesh': 'model/mesh',
    'mft': 'application/rpki-manifest',
    'mid': 'audio/midi',
    'midi': 'audio/midi',
    'mj2': 'video/mj2',
    'mjp2': 'video/mj2',
    'mjs': 'application/javascript',
    'mml': 'text/mathml',
    'mov': 'video/quicktime',
    'mp2': 'audio/mpeg',
    'mp21': 'application/mp21',
    'mp2a': 'audio/mpeg',
    'mp3': 'audio/mpeg',
    'mp4': 'video/mp4',
    'mp4a': 'audio/mp4',
    'mp4s': 'application/mp4',
    'mp4v': 'video/mp4',
    'mpe': 'video/mpeg',
    'mpeg': 'video/mpeg',
    'mpg': 'video/mpeg',
    'mpg4': 'video/mp4',
    'mpga': 'audio/mpeg',
    'mrc': 'application/marc',
    'ms': 'text/troff',
    'msh': 'model/mesh',
    'n3': 'text/n3',
    'oga': 'audio/ogg',
    'ogg': 'audio/ogg',
    'ogv': 'video/ogg',
    'ogx': 'application/ogg',
    'otf': 'font/otf',
    'p10': 'application/pkcs10',
    'p7c': 'application/pkcs7-mime',
    'p7m': 'application/pkcs7-mime',
    'p7s': 'application/pkcs7-signature',
    'p8': 'application/pkcs8',
    'pdf': 'application/pdf',
    'pki': 'application/pkixcmp',
    'pkipath': 'application/pkix-pkipath',
    'png': 'image/png',
    'ps': 'application/postscript',
    'pskcxml': 'application/pskc+xml',
    'qt': 'video/quicktime',
    'rmi': 'audio/midi',
    'rng': 'application/xml',
    'roa': 'application/rpki-roa',
    'roff': 'text/troff',
    'rsd': 'application/rsd+xml',
    'rss': 'application/rss+xml',
    'rtf': 'application/rtf',
    'rtx': 'text/richtext',
    's3m': 'audio/s3m',
    'sgi': 'image/sgi',
    'sgm': 'text/sgml',
    'sgml': 'text/sgml',
    'shex': 'text/shex',
    'shtml': 'text/html',
    'sil': 'audio/silk',
    'silo': 'model/mesh',
    'slim': 'text/slim',
    'slm': 'text/slim',
    'snd': 'audio/basic',
    'spx': 'audio/ogg',
    'stl': 'model/stl',
    'styl': 'text/stylus',
    'stylus': 'text/stylus',
    'svg': 'image/svg+xml',
    'svgz': 'image/svg+xml',
    't': 'text/troff',
    't38': 'image/t38',
    'text': 'text/plain',
    'tfx': 'image/tiff-fx',
    'tif': 'image/tiff',
    'tiff': 'image/tiff',
    'tr': 'text/troff',
    'ts': 'video/mp2t',
    'tsv': 'text/tab-separated-values',
    'ttc': 'font/collection',
    'ttf': 'font/ttf',
    'ttl': 'text/turtle',
    'txt': 'text/plain',
    'uri': 'text/uri-list',
    'uris': 'text/uri-list',
    'urls': 'text/uri-list',
    'vcard': 'text/vcard',
    'vrml': 'model/vrml',
    'vtt': 'text/vtt',
    'war': 'application/java-archive',
    'wasm': 'application/wasm',
    'wav': 'audio/wav',
    'weba': 'audio/webm',
    'webm': 'video/webm',
    'webmanifest': 'application/manifest+json',
    'webp': 'image/webp',
    'wmf': 'image/wmf',
    'woff': 'font/woff',
    'woff2': 'font/woff2',
    'wrl': 'model/vrml',
    'x3d': 'model/x3d+xml',
    'x3db': 'model/x3d+fastinfoset',
    'x3dbz': 'model/x3d+binary',
    'x3dv': 'model/x3d-vrml',
    'x3dvz': 'model/x3d+vrml',
    'x3dz': 'model/x3d+xml',
    'xaml': 'application/xaml+xml',
    'xht': 'application/xhtml+xml',
    'xhtml': 'application/xhtml+xml',
    'xm': 'audio/xm',
    'xml': 'text/xml',
    'xsd': 'application/xml',
    'xsl': 'application/xml',
    'xslt': 'application/xslt+xml',
    'yaml': 'text/yaml',
    'yml': 'text/yaml',
    'zip': 'application/zip'
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./src/screenshotter.ts":
/*!******************************!*\
  !*** ./src/screenshotter.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
class Screenshotter {
    constructor(page) {
        this._queue = new TaskQueue();
        this._page = page;
        const browserContext = page.context();
        this._queue = browserContext[taskQueueSymbol];
        if (!this._queue) {
            this._queue = new TaskQueue();
            browserContext[taskQueueSymbol] = this._queue;
        }
    }
    async _originalViewportSize() {
        const originalViewportSize = this._page.viewportSize();
        let viewportSize = originalViewportSize;
        if (!viewportSize) {
            const maybeViewportSize = await this._page.evaluate(() => {
                if (!document.body || !document.documentElement)
                    return;
                return {
                    width: Math.max(document.body.offsetWidth, document.documentElement.offsetWidth),
                    height: Math.max(document.body.offsetHeight, document.documentElement.offsetHeight),
                };
            });
            if (!maybeViewportSize)
                throw new Error(exports.kScreenshotDuringNavigationError);
            viewportSize = maybeViewportSize;
        }
        return { viewportSize, originalViewportSize };
    }
    async screenshotPage(options = {}) {
        const format = validateScreeshotOptions(options);
        return this._queue.postTask(async () => {
            const { viewportSize, originalViewportSize } = await this._originalViewportSize();
            let overridenViewportSize = null;
            if (options.fullPage && !this._page._delegate.canScreenshotOutsideViewport()) {
                const fullPageRect = await this._page.evaluate(() => {
                    if (!document.body || !document.documentElement)
                        return null;
                    return {
                        width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
                        height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight),
                    };
                });
                if (!fullPageRect)
                    throw new Error(exports.kScreenshotDuringNavigationError);
                overridenViewportSize = fullPageRect;
                await this._page.setViewportSize(overridenViewportSize);
            }
            else if (options.clip) {
                options.clip = trimClipToViewport(viewportSize, options.clip);
            }
            return await this._screenshot(format, options, viewportSize, overridenViewportSize, originalViewportSize);
        }).catch(rewriteError);
    }
    async screenshotElement(handle, options = {}) {
        const format = validateScreeshotOptions(options);
        const rewrittenOptions = { ...options };
        return this._queue.postTask(async () => {
            let maybeBoundingBox = await this._page._delegate.getBoundingBoxForScreenshot(handle);
            helper_1.assert(maybeBoundingBox, 'Node is either not visible or not an HTMLElement');
            let boundingBox = maybeBoundingBox;
            helper_1.assert(boundingBox.width !== 0, 'Node has 0 width.');
            helper_1.assert(boundingBox.height !== 0, 'Node has 0 height.');
            boundingBox = enclosingIntRect(boundingBox);
            const { viewportSize, originalViewportSize } = await this._originalViewportSize();
            let overridenViewportSize = null;
            if (!this._page._delegate.canScreenshotOutsideViewport()) {
                if (boundingBox.width > viewportSize.width || boundingBox.height > viewportSize.height) {
                    overridenViewportSize = {
                        width: Math.max(viewportSize.width, boundingBox.width),
                        height: Math.max(viewportSize.height, boundingBox.height),
                    };
                    await this._page.setViewportSize(overridenViewportSize);
                }
                await handle.scrollIntoViewIfNeeded();
                maybeBoundingBox = await this._page._delegate.getBoundingBoxForScreenshot(handle);
                helper_1.assert(maybeBoundingBox, 'Node is either not visible or not an HTMLElement');
                boundingBox = enclosingIntRect(maybeBoundingBox);
            }
            if (!overridenViewportSize)
                rewrittenOptions.clip = boundingBox;
            return await this._screenshot(format, rewrittenOptions, viewportSize, overridenViewportSize, originalViewportSize);
        }).catch(rewriteError);
    }
    async _screenshot(format, options, viewportSize, overridenViewportSize, originalViewportSize) {
        const shouldSetDefaultBackground = options.omitBackground && format === 'png';
        if (shouldSetDefaultBackground)
            await this._page._delegate.setBackgroundColor({ r: 0, g: 0, b: 0, a: 0 });
        const buffer = await this._page._delegate.takeScreenshot(format, options, overridenViewportSize || viewportSize);
        if (shouldSetDefaultBackground)
            await this._page._delegate.setBackgroundColor();
        if (options.path)
            await platform.writeFileAsync(options.path, buffer);
        if (overridenViewportSize) {
            if (originalViewportSize)
                await this._page.setViewportSize(originalViewportSize);
            else
                await this._page._delegate.resetViewport(viewportSize);
        }
        return buffer;
    }
}
exports.Screenshotter = Screenshotter;
const taskQueueSymbol = Symbol('TaskQueue');
class TaskQueue {
    constructor() {
        this._chain = Promise.resolve();
    }
    postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => { });
        return result;
    }
}
function trimClipToViewport(viewportSize, clip) {
    if (!clip)
        return clip;
    const p1 = { x: Math.min(clip.x, viewportSize.width), y: Math.min(clip.y, viewportSize.height) };
    const p2 = { x: Math.min(clip.x + clip.width, viewportSize.width), y: Math.min(clip.y + clip.height, viewportSize.height) };
    const result = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
    helper_1.assert(result.width && result.height, 'Clipped area is either empty or outside the viewport');
    return result;
}
function validateScreeshotOptions(options) {
    let format = null;
    // options.type takes precedence over inferring the type from options.path
    // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).
    if (options.type) {
        helper_1.assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);
        format = options.type;
    }
    else if (options.path) {
        const mimeType = platform.getMimeType(options.path);
        if (mimeType === 'image/png')
            format = 'png';
        else if (mimeType === 'image/jpeg')
            format = 'jpeg';
        helper_1.assert(format, 'Unsupported screenshot mime type: ' + mimeType);
    }
    if (!format)
        format = 'png';
    if (options.quality) {
        helper_1.assert(format === 'jpeg', 'options.quality is unsupported for the ' + format + ' screenshots');
        helper_1.assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + (typeof options.quality));
        helper_1.assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
        helper_1.assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);
    }
    helper_1.assert(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');
    if (options.clip) {
        helper_1.assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + (typeof options.clip.x));
        helper_1.assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + (typeof options.clip.y));
        helper_1.assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + (typeof options.clip.width));
        helper_1.assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + (typeof options.clip.height));
        helper_1.assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
        helper_1.assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
    }
    return format;
}
function enclosingIntRect(rect) {
    const x = Math.floor(rect.x + 1e-3);
    const y = Math.floor(rect.y + 1e-3);
    const x2 = Math.ceil(rect.x + rect.width - 1e-3);
    const y2 = Math.ceil(rect.y + rect.height - 1e-3);
    return { x, y, width: x2 - x, height: y2 - y };
}
exports.kScreenshotDuringNavigationError = 'Cannot take a screenshot while page is navigating';
function rewriteError(e) {
    if (typeof e === 'object' && e instanceof Error && e.message.includes('Execution context was destroyed'))
        e.message = exports.kScreenshotDuringNavigationError;
    throw e;
}


/***/ }),

/***/ "./src/selectors.ts":
/*!**************************!*\
  !*** ./src/selectors.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ./helper */ "./src/helper.ts");
let selectors;
class Selectors {
    constructor() {
        this._generation = 0;
        this._sources = [];
    }
    static _instance() {
        if (!selectors)
            selectors = new Selectors();
        return selectors;
    }
    async register(engineFunction, ...args) {
        const source = helper_1.helper.evaluationString(engineFunction, ...args);
        this._sources.push(source);
        ++this._generation;
    }
    async _createSelector(name, handle) {
        const mainContext = await handle._page.mainFrame()._mainContext();
        return mainContext.evaluate((injected, target, name) => {
            return injected.engines.get(name).create(document.documentElement, target);
        }, await mainContext._injected(), handle, name);
    }
}
exports.Selectors = Selectors;


/***/ }),

/***/ "./src/timeoutSettings.ts":
/*!********************************!*\
  !*** ./src/timeoutSettings.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DEFAULT_TIMEOUT = 30000;
class TimeoutSettings {
    constructor(parent) {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
        this._parent = parent;
    }
    setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
    }
    navigationTimeout() {
        if (this._defaultNavigationTimeout !== null)
            return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        if (this._parent)
            return this._parent.navigationTimeout();
        return DEFAULT_TIMEOUT;
    }
    timeout() {
        if (this._defaultTimeout !== null)
            return this._defaultTimeout;
        if (this._parent)
            return this._parent.timeout();
        return DEFAULT_TIMEOUT;
    }
}
exports.TimeoutSettings = TimeoutSettings;


/***/ }),

/***/ "./src/transport.ts":
/*!**************************!*\
  !*** ./src/transport.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class SlowMoTransport {
    constructor(transport, delay) {
        this._incomingMessageQueue = [];
        this._delay = delay;
        this._delegate = transport;
        this._delegate.onmessage = this._enqueueMessage.bind(this);
        this._delegate.onclose = this._onClose.bind(this);
    }
    static wrap(transport, delay) {
        return delay ? new SlowMoTransport(transport, delay) : transport;
    }
    _enqueueMessage(message) {
        this._incomingMessageQueue.push(message);
        this._scheduleQueueDispatch();
    }
    _scheduleQueueDispatch() {
        if (this._dispatchTimerId)
            return;
        if (!this._incomingMessageQueue.length)
            return;
        this._dispatchTimerId = setTimeout(() => {
            this._dispatchTimerId = undefined;
            this._dispatchOneMessageFromQueue();
        }, this._delay);
    }
    _dispatchOneMessageFromQueue() {
        const message = this._incomingMessageQueue.shift();
        try {
            if (this.onmessage)
                this.onmessage(message);
        }
        finally {
            this._scheduleQueueDispatch();
        }
    }
    _onClose() {
        if (this.onclose)
            this.onclose();
        this._delegate.onmessage = undefined;
        this._delegate.onclose = undefined;
    }
    send(s) {
        this._delegate.send(s);
    }
    close() {
        this._delegate.close();
    }
}
exports.SlowMoTransport = SlowMoTransport;
class DeferWriteTransport {
    constructor(transport) {
        this._delegate = transport;
        let callback;
        this._readPromise = new Promise(f => callback = f);
        this._delegate.onmessage = s => {
            callback();
            if (this.onmessage)
                this.onmessage(s);
        };
        this._delegate.onclose = () => {
            if (this.onclose)
                this.onclose();
        };
    }
    async send(s) {
        await this._readPromise;
        this._delegate.send(s);
    }
    close() {
        this._delegate.close();
    }
}
exports.DeferWriteTransport = DeferWriteTransport;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mediaTypes = new Set(['screen', 'print']);
exports.colorSchemes = new Set(['dark', 'light', 'no-preference']);


/***/ }),

/***/ "./src/usKeyboardLayout.ts":
/*!*********************************!*\
  !*** ./src/usKeyboardLayout.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.keypadLocation = 3;
exports.keyDefinitions = {
    '0': { 'keyCode': 48, 'key': '0', 'code': 'Digit0' },
    '1': { 'keyCode': 49, 'key': '1', 'code': 'Digit1' },
    '2': { 'keyCode': 50, 'key': '2', 'code': 'Digit2' },
    '3': { 'keyCode': 51, 'key': '3', 'code': 'Digit3' },
    '4': { 'keyCode': 52, 'key': '4', 'code': 'Digit4' },
    '5': { 'keyCode': 53, 'key': '5', 'code': 'Digit5' },
    '6': { 'keyCode': 54, 'key': '6', 'code': 'Digit6' },
    '7': { 'keyCode': 55, 'key': '7', 'code': 'Digit7' },
    '8': { 'keyCode': 56, 'key': '8', 'code': 'Digit8' },
    '9': { 'keyCode': 57, 'key': '9', 'code': 'Digit9' },
    'Power': { 'key': 'Power', 'code': 'Power' },
    'Eject': { 'key': 'Eject', 'code': 'Eject' },
    'Abort': { 'keyCode': 3, 'code': 'Abort', 'key': 'Cancel' },
    'Help': { 'keyCode': 6, 'code': 'Help', 'key': 'Help' },
    'Backspace': { 'keyCode': 8, 'code': 'Backspace', 'key': 'Backspace' },
    'Tab': { 'keyCode': 9, 'code': 'Tab', 'key': 'Tab' },
    'Numpad5': { 'keyCode': 12, 'shiftKeyCode': 101, 'key': 'Clear', 'code': 'Numpad5', 'shiftKey': '5', 'location': 3 },
    'NumpadEnter': { 'keyCode': 13, 'code': 'NumpadEnter', 'key': 'Enter', 'text': '\r', 'location': 3 },
    'Enter': { 'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\r' },
    '\r': { 'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\r' },
    '\n': { 'keyCode': 13, 'code': 'Enter', 'key': 'Enter', 'text': '\r' },
    'ShiftLeft': { 'keyCode': 160, 'keyCodeWithoutLocation': 16, 'code': 'ShiftLeft', 'key': 'Shift', 'location': 1, 'windowsVirtualKeyCode': 160 },
    'ShiftRight': { 'keyCode': 161, 'keyCodeWithoutLocation': 16, 'code': 'ShiftRight', 'key': 'Shift', 'location': 2, 'windowsVirtualKeyCode': 161 },
    'ControlLeft': { 'keyCode': 162, 'keyCodeWithoutLocation': 17, 'code': 'ControlLeft', 'key': 'Control', 'location': 1, 'windowsVirtualKeyCode': 162 },
    'ControlRight': { 'keyCode': 163, 'keyCodeWithoutLocation': 17, 'code': 'ControlRight', 'key': 'Control', 'location': 2, 'windowsVirtualKeyCode': 163 },
    'AltLeft': { 'keyCode': 164, 'keyCodeWithoutLocation': 18, 'code': 'AltLeft', 'key': 'Alt', 'location': 1, 'windowsVirtualKeyCode': 164 },
    'AltRight': { 'keyCode': 165, 'keyCodeWithoutLocation': 18, 'code': 'AltRight', 'key': 'Alt', 'location': 2, 'windowsVirtualKeyCode': 165 },
    'Pause': { 'keyCode': 19, 'code': 'Pause', 'key': 'Pause' },
    'CapsLock': { 'keyCode': 20, 'code': 'CapsLock', 'key': 'CapsLock' },
    'Escape': { 'keyCode': 27, 'code': 'Escape', 'key': 'Escape' },
    'Convert': { 'keyCode': 28, 'code': 'Convert', 'key': 'Convert' },
    'NonConvert': { 'keyCode': 29, 'code': 'NonConvert', 'key': 'NonConvert' },
    'Space': { 'keyCode': 32, 'code': 'Space', 'key': ' ' },
    'Numpad9': { 'keyCode': 33, 'shiftKeyCode': 105, 'key': 'PageUp', 'code': 'Numpad9', 'shiftKey': '9', 'location': 3 },
    'PageUp': { 'keyCode': 33, 'code': 'PageUp', 'key': 'PageUp' },
    'Numpad3': { 'keyCode': 34, 'shiftKeyCode': 99, 'key': 'PageDown', 'code': 'Numpad3', 'shiftKey': '3', 'location': 3 },
    'PageDown': { 'keyCode': 34, 'code': 'PageDown', 'key': 'PageDown' },
    'End': { 'keyCode': 35, 'code': 'End', 'key': 'End' },
    'Numpad1': { 'keyCode': 35, 'shiftKeyCode': 97, 'key': 'End', 'code': 'Numpad1', 'shiftKey': '1', 'location': 3 },
    'Home': { 'keyCode': 36, 'code': 'Home', 'key': 'Home' },
    'Numpad7': { 'keyCode': 36, 'shiftKeyCode': 103, 'key': 'Home', 'code': 'Numpad7', 'shiftKey': '7', 'location': 3 },
    'ArrowLeft': { 'keyCode': 37, 'code': 'ArrowLeft', 'key': 'ArrowLeft' },
    'Numpad4': { 'keyCode': 37, 'shiftKeyCode': 100, 'key': 'ArrowLeft', 'code': 'Numpad4', 'shiftKey': '4', 'location': 3 },
    'Numpad8': { 'keyCode': 38, 'shiftKeyCode': 104, 'key': 'ArrowUp', 'code': 'Numpad8', 'shiftKey': '8', 'location': 3 },
    'ArrowUp': { 'keyCode': 38, 'code': 'ArrowUp', 'key': 'ArrowUp' },
    'ArrowRight': { 'keyCode': 39, 'code': 'ArrowRight', 'key': 'ArrowRight' },
    'Numpad6': { 'keyCode': 39, 'shiftKeyCode': 102, 'key': 'ArrowRight', 'code': 'Numpad6', 'shiftKey': '6', 'location': 3 },
    'Numpad2': { 'keyCode': 40, 'shiftKeyCode': 98, 'key': 'ArrowDown', 'code': 'Numpad2', 'shiftKey': '2', 'location': 3 },
    'ArrowDown': { 'keyCode': 40, 'code': 'ArrowDown', 'key': 'ArrowDown' },
    'Select': { 'keyCode': 41, 'code': 'Select', 'key': 'Select' },
    'Open': { 'keyCode': 43, 'code': 'Open', 'key': 'Execute' },
    'PrintScreen': { 'keyCode': 44, 'code': 'PrintScreen', 'key': 'PrintScreen' },
    'Insert': { 'keyCode': 45, 'code': 'Insert', 'key': 'Insert' },
    'Numpad0': { 'keyCode': 45, 'shiftKeyCode': 96, 'key': 'Insert', 'code': 'Numpad0', 'shiftKey': '0', 'location': 3 },
    'Delete': { 'keyCode': 46, 'code': 'Delete', 'key': 'Delete' },
    'NumpadDecimal': { 'keyCode': 46, 'shiftKeyCode': 110, 'code': 'NumpadDecimal', 'key': '\u0000', 'shiftKey': '.', 'location': 3 },
    'Digit0': { 'keyCode': 48, 'code': 'Digit0', 'shiftKey': ')', 'key': '0' },
    'Digit1': { 'keyCode': 49, 'code': 'Digit1', 'shiftKey': '!', 'key': '1' },
    'Digit2': { 'keyCode': 50, 'code': 'Digit2', 'shiftKey': '@', 'key': '2' },
    'Digit3': { 'keyCode': 51, 'code': 'Digit3', 'shiftKey': '#', 'key': '3' },
    'Digit4': { 'keyCode': 52, 'code': 'Digit4', 'shiftKey': '$', 'key': '4' },
    'Digit5': { 'keyCode': 53, 'code': 'Digit5', 'shiftKey': '%', 'key': '5' },
    'Digit6': { 'keyCode': 54, 'code': 'Digit6', 'shiftKey': '^', 'key': '6' },
    'Digit7': { 'keyCode': 55, 'code': 'Digit7', 'shiftKey': '&', 'key': '7' },
    'Digit8': { 'keyCode': 56, 'code': 'Digit8', 'shiftKey': '*', 'key': '8' },
    'Digit9': { 'keyCode': 57, 'code': 'Digit9', 'shiftKey': '\(', 'key': '9' },
    'KeyA': { 'keyCode': 65, 'code': 'KeyA', 'shiftKey': 'A', 'key': 'a' },
    'KeyB': { 'keyCode': 66, 'code': 'KeyB', 'shiftKey': 'B', 'key': 'b' },
    'KeyC': { 'keyCode': 67, 'code': 'KeyC', 'shiftKey': 'C', 'key': 'c' },
    'KeyD': { 'keyCode': 68, 'code': 'KeyD', 'shiftKey': 'D', 'key': 'd' },
    'KeyE': { 'keyCode': 69, 'code': 'KeyE', 'shiftKey': 'E', 'key': 'e' },
    'KeyF': { 'keyCode': 70, 'code': 'KeyF', 'shiftKey': 'F', 'key': 'f' },
    'KeyG': { 'keyCode': 71, 'code': 'KeyG', 'shiftKey': 'G', 'key': 'g' },
    'KeyH': { 'keyCode': 72, 'code': 'KeyH', 'shiftKey': 'H', 'key': 'h' },
    'KeyI': { 'keyCode': 73, 'code': 'KeyI', 'shiftKey': 'I', 'key': 'i' },
    'KeyJ': { 'keyCode': 74, 'code': 'KeyJ', 'shiftKey': 'J', 'key': 'j' },
    'KeyK': { 'keyCode': 75, 'code': 'KeyK', 'shiftKey': 'K', 'key': 'k' },
    'KeyL': { 'keyCode': 76, 'code': 'KeyL', 'shiftKey': 'L', 'key': 'l' },
    'KeyM': { 'keyCode': 77, 'code': 'KeyM', 'shiftKey': 'M', 'key': 'm' },
    'KeyN': { 'keyCode': 78, 'code': 'KeyN', 'shiftKey': 'N', 'key': 'n' },
    'KeyO': { 'keyCode': 79, 'code': 'KeyO', 'shiftKey': 'O', 'key': 'o' },
    'KeyP': { 'keyCode': 80, 'code': 'KeyP', 'shiftKey': 'P', 'key': 'p' },
    'KeyQ': { 'keyCode': 81, 'code': 'KeyQ', 'shiftKey': 'Q', 'key': 'q' },
    'KeyR': { 'keyCode': 82, 'code': 'KeyR', 'shiftKey': 'R', 'key': 'r' },
    'KeyS': { 'keyCode': 83, 'code': 'KeyS', 'shiftKey': 'S', 'key': 's' },
    'KeyT': { 'keyCode': 84, 'code': 'KeyT', 'shiftKey': 'T', 'key': 't' },
    'KeyU': { 'keyCode': 85, 'code': 'KeyU', 'shiftKey': 'U', 'key': 'u' },
    'KeyV': { 'keyCode': 86, 'code': 'KeyV', 'shiftKey': 'V', 'key': 'v' },
    'KeyW': { 'keyCode': 87, 'code': 'KeyW', 'shiftKey': 'W', 'key': 'w' },
    'KeyX': { 'keyCode': 88, 'code': 'KeyX', 'shiftKey': 'X', 'key': 'x' },
    'KeyY': { 'keyCode': 89, 'code': 'KeyY', 'shiftKey': 'Y', 'key': 'y' },
    'KeyZ': { 'keyCode': 90, 'code': 'KeyZ', 'shiftKey': 'Z', 'key': 'z' },
    'MetaLeft': { 'keyCode': 91, 'code': 'MetaLeft', 'key': 'Meta', 'location': 1 },
    'MetaRight': { 'keyCode': 92, 'code': 'MetaRight', 'key': 'Meta', 'location': 2 },
    'ContextMenu': { 'keyCode': 93, 'code': 'ContextMenu', 'key': 'ContextMenu' },
    'NumpadMultiply': { 'keyCode': 106, 'code': 'NumpadMultiply', 'key': '*', 'location': 3 },
    'NumpadAdd': { 'keyCode': 107, 'code': 'NumpadAdd', 'key': '+', 'location': 3 },
    'NumpadSubtract': { 'keyCode': 109, 'code': 'NumpadSubtract', 'key': '-', 'location': 3 },
    'NumpadDivide': { 'keyCode': 111, 'code': 'NumpadDivide', 'key': '/', 'location': 3 },
    'F1': { 'keyCode': 112, 'code': 'F1', 'key': 'F1' },
    'F2': { 'keyCode': 113, 'code': 'F2', 'key': 'F2' },
    'F3': { 'keyCode': 114, 'code': 'F3', 'key': 'F3' },
    'F4': { 'keyCode': 115, 'code': 'F4', 'key': 'F4' },
    'F5': { 'keyCode': 116, 'code': 'F5', 'key': 'F5' },
    'F6': { 'keyCode': 117, 'code': 'F6', 'key': 'F6' },
    'F7': { 'keyCode': 118, 'code': 'F7', 'key': 'F7' },
    'F8': { 'keyCode': 119, 'code': 'F8', 'key': 'F8' },
    'F9': { 'keyCode': 120, 'code': 'F9', 'key': 'F9' },
    'F10': { 'keyCode': 121, 'code': 'F10', 'key': 'F10' },
    'F11': { 'keyCode': 122, 'code': 'F11', 'key': 'F11' },
    'F12': { 'keyCode': 123, 'code': 'F12', 'key': 'F12' },
    'F13': { 'keyCode': 124, 'code': 'F13', 'key': 'F13' },
    'F14': { 'keyCode': 125, 'code': 'F14', 'key': 'F14' },
    'F15': { 'keyCode': 126, 'code': 'F15', 'key': 'F15' },
    'F16': { 'keyCode': 127, 'code': 'F16', 'key': 'F16' },
    'F17': { 'keyCode': 128, 'code': 'F17', 'key': 'F17' },
    'F18': { 'keyCode': 129, 'code': 'F18', 'key': 'F18' },
    'F19': { 'keyCode': 130, 'code': 'F19', 'key': 'F19' },
    'F20': { 'keyCode': 131, 'code': 'F20', 'key': 'F20' },
    'F21': { 'keyCode': 132, 'code': 'F21', 'key': 'F21' },
    'F22': { 'keyCode': 133, 'code': 'F22', 'key': 'F22' },
    'F23': { 'keyCode': 134, 'code': 'F23', 'key': 'F23' },
    'F24': { 'keyCode': 135, 'code': 'F24', 'key': 'F24' },
    'NumLock': { 'keyCode': 144, 'code': 'NumLock', 'key': 'NumLock' },
    'ScrollLock': { 'keyCode': 145, 'code': 'ScrollLock', 'key': 'ScrollLock' },
    'AudioVolumeMute': { 'keyCode': 173, 'code': 'AudioVolumeMute', 'key': 'AudioVolumeMute' },
    'AudioVolumeDown': { 'keyCode': 174, 'code': 'AudioVolumeDown', 'key': 'AudioVolumeDown' },
    'AudioVolumeUp': { 'keyCode': 175, 'code': 'AudioVolumeUp', 'key': 'AudioVolumeUp' },
    'MediaTrackNext': { 'keyCode': 176, 'code': 'MediaTrackNext', 'key': 'MediaTrackNext' },
    'MediaTrackPrevious': { 'keyCode': 177, 'code': 'MediaTrackPrevious', 'key': 'MediaTrackPrevious' },
    'MediaStop': { 'keyCode': 178, 'code': 'MediaStop', 'key': 'MediaStop' },
    'MediaPlayPause': { 'keyCode': 179, 'code': 'MediaPlayPause', 'key': 'MediaPlayPause' },
    'Semicolon': { 'keyCode': 186, 'code': 'Semicolon', 'shiftKey': ':', 'key': ';' },
    'Equal': { 'keyCode': 187, 'code': 'Equal', 'shiftKey': '+', 'key': '=' },
    'NumpadEqual': { 'keyCode': 187, 'code': 'NumpadEqual', 'key': '=', 'location': 3 },
    'Comma': { 'keyCode': 188, 'code': 'Comma', 'shiftKey': '\<', 'key': ',' },
    'Minus': { 'keyCode': 189, 'code': 'Minus', 'shiftKey': '_', 'key': '-' },
    'Period': { 'keyCode': 190, 'code': 'Period', 'shiftKey': '>', 'key': '.' },
    'Slash': { 'keyCode': 191, 'code': 'Slash', 'shiftKey': '?', 'key': '/' },
    'Backquote': { 'keyCode': 192, 'code': 'Backquote', 'shiftKey': '~', 'key': '`' },
    'BracketLeft': { 'keyCode': 219, 'code': 'BracketLeft', 'shiftKey': '{', 'key': '[' },
    'Backslash': { 'keyCode': 220, 'code': 'Backslash', 'shiftKey': '|', 'key': '\\' },
    'BracketRight': { 'keyCode': 221, 'code': 'BracketRight', 'shiftKey': '}', 'key': ']' },
    'Quote': { 'keyCode': 222, 'code': 'Quote', 'shiftKey': '"', 'key': '\'' },
    'AltGraph': { 'keyCode': 225, 'code': 'AltGraph', 'key': 'AltGraph' },
    'Props': { 'keyCode': 247, 'code': 'Props', 'key': 'CrSel' },
    'Cancel': { 'keyCode': 3, 'key': 'Cancel', 'code': 'Abort' },
    'Clear': { 'keyCode': 12, 'key': 'Clear', 'code': 'Numpad5', 'location': 3 },
    'Shift': { 'keyCode': 160, 'keyCodeWithoutLocation': 16, 'key': 'Shift', 'code': 'ShiftLeft', 'location': 1, 'windowsVirtualKeyCode': 160 },
    'Control': { 'keyCode': 162, 'keyCodeWithoutLocation': 17, 'key': 'Control', 'code': 'ControlLeft', 'location': 1, 'windowsVirtualKeyCode': 162 },
    'Alt': { 'keyCode': 164, 'keyCodeWithoutLocation': 18, 'key': 'Alt', 'code': 'AltLeft', 'location': 1, 'windowsVirtualKeyCode': 164 },
    'Accept': { 'keyCode': 30, 'key': 'Accept' },
    'ModeChange': { 'keyCode': 31, 'key': 'ModeChange' },
    ' ': { 'keyCode': 32, 'key': ' ', 'code': 'Space' },
    'Print': { 'keyCode': 42, 'key': 'Print' },
    'Execute': { 'keyCode': 43, 'key': 'Execute', 'code': 'Open' },
    '\u0000': { 'keyCode': 46, 'key': '\u0000', 'code': 'NumpadDecimal', 'location': 3 },
    'a': { 'keyCode': 65, 'key': 'a', 'code': 'KeyA' },
    'b': { 'keyCode': 66, 'key': 'b', 'code': 'KeyB' },
    'c': { 'keyCode': 67, 'key': 'c', 'code': 'KeyC' },
    'd': { 'keyCode': 68, 'key': 'd', 'code': 'KeyD' },
    'e': { 'keyCode': 69, 'key': 'e', 'code': 'KeyE' },
    'f': { 'keyCode': 70, 'key': 'f', 'code': 'KeyF' },
    'g': { 'keyCode': 71, 'key': 'g', 'code': 'KeyG' },
    'h': { 'keyCode': 72, 'key': 'h', 'code': 'KeyH' },
    'i': { 'keyCode': 73, 'key': 'i', 'code': 'KeyI' },
    'j': { 'keyCode': 74, 'key': 'j', 'code': 'KeyJ' },
    'k': { 'keyCode': 75, 'key': 'k', 'code': 'KeyK' },
    'l': { 'keyCode': 76, 'key': 'l', 'code': 'KeyL' },
    'm': { 'keyCode': 77, 'key': 'm', 'code': 'KeyM' },
    'n': { 'keyCode': 78, 'key': 'n', 'code': 'KeyN' },
    'o': { 'keyCode': 79, 'key': 'o', 'code': 'KeyO' },
    'p': { 'keyCode': 80, 'key': 'p', 'code': 'KeyP' },
    'q': { 'keyCode': 81, 'key': 'q', 'code': 'KeyQ' },
    'r': { 'keyCode': 82, 'key': 'r', 'code': 'KeyR' },
    's': { 'keyCode': 83, 'key': 's', 'code': 'KeyS' },
    't': { 'keyCode': 84, 'key': 't', 'code': 'KeyT' },
    'u': { 'keyCode': 85, 'key': 'u', 'code': 'KeyU' },
    'v': { 'keyCode': 86, 'key': 'v', 'code': 'KeyV' },
    'w': { 'keyCode': 87, 'key': 'w', 'code': 'KeyW' },
    'x': { 'keyCode': 88, 'key': 'x', 'code': 'KeyX' },
    'y': { 'keyCode': 89, 'key': 'y', 'code': 'KeyY' },
    'z': { 'keyCode': 90, 'key': 'z', 'code': 'KeyZ' },
    'Meta': { 'keyCode': 91, 'key': 'Meta', 'code': 'MetaLeft', 'location': 1 },
    '*': { 'keyCode': 106, 'key': '*', 'code': 'NumpadMultiply', 'location': 3 },
    '+': { 'keyCode': 107, 'key': '+', 'code': 'NumpadAdd', 'location': 3 },
    '-': { 'keyCode': 109, 'key': '-', 'code': 'NumpadSubtract', 'location': 3 },
    '/': { 'keyCode': 111, 'key': '/', 'code': 'NumpadDivide', 'location': 3 },
    ';': { 'keyCode': 186, 'key': ';', 'code': 'Semicolon' },
    '=': { 'keyCode': 187, 'key': '=', 'code': 'Equal' },
    ',': { 'keyCode': 188, 'key': ',', 'code': 'Comma' },
    '.': { 'keyCode': 190, 'key': '.', 'code': 'Period' },
    '`': { 'keyCode': 192, 'key': '`', 'code': 'Backquote' },
    '[': { 'keyCode': 219, 'key': '[', 'code': 'BracketLeft' },
    '\\': { 'keyCode': 220, 'key': '\\', 'code': 'Backslash' },
    ']': { 'keyCode': 221, 'key': ']', 'code': 'BracketRight' },
    '\'': { 'keyCode': 222, 'key': '\'', 'code': 'Quote' },
    'Attn': { 'keyCode': 246, 'key': 'Attn' },
    'CrSel': { 'keyCode': 247, 'key': 'CrSel', 'code': 'Props' },
    'ExSel': { 'keyCode': 248, 'key': 'ExSel' },
    'EraseEof': { 'keyCode': 249, 'key': 'EraseEof' },
    'Play': { 'keyCode': 250, 'key': 'Play' },
    'ZoomOut': { 'keyCode': 251, 'key': 'ZoomOut' },
    ')': { 'keyCode': 48, 'key': ')', 'code': 'Digit0' },
    '!': { 'keyCode': 49, 'key': '!', 'code': 'Digit1' },
    '@': { 'keyCode': 50, 'key': '@', 'code': 'Digit2' },
    '#': { 'keyCode': 51, 'key': '#', 'code': 'Digit3' },
    '$': { 'keyCode': 52, 'key': '$', 'code': 'Digit4' },
    '%': { 'keyCode': 53, 'key': '%', 'code': 'Digit5' },
    '^': { 'keyCode': 54, 'key': '^', 'code': 'Digit6' },
    '&': { 'keyCode': 55, 'key': '&', 'code': 'Digit7' },
    '(': { 'keyCode': 57, 'key': '\(', 'code': 'Digit9' },
    'A': { 'keyCode': 65, 'key': 'A', 'code': 'KeyA' },
    'B': { 'keyCode': 66, 'key': 'B', 'code': 'KeyB' },
    'C': { 'keyCode': 67, 'key': 'C', 'code': 'KeyC' },
    'D': { 'keyCode': 68, 'key': 'D', 'code': 'KeyD' },
    'E': { 'keyCode': 69, 'key': 'E', 'code': 'KeyE' },
    'F': { 'keyCode': 70, 'key': 'F', 'code': 'KeyF' },
    'G': { 'keyCode': 71, 'key': 'G', 'code': 'KeyG' },
    'H': { 'keyCode': 72, 'key': 'H', 'code': 'KeyH' },
    'I': { 'keyCode': 73, 'key': 'I', 'code': 'KeyI' },
    'J': { 'keyCode': 74, 'key': 'J', 'code': 'KeyJ' },
    'K': { 'keyCode': 75, 'key': 'K', 'code': 'KeyK' },
    'L': { 'keyCode': 76, 'key': 'L', 'code': 'KeyL' },
    'M': { 'keyCode': 77, 'key': 'M', 'code': 'KeyM' },
    'N': { 'keyCode': 78, 'key': 'N', 'code': 'KeyN' },
    'O': { 'keyCode': 79, 'key': 'O', 'code': 'KeyO' },
    'P': { 'keyCode': 80, 'key': 'P', 'code': 'KeyP' },
    'Q': { 'keyCode': 81, 'key': 'Q', 'code': 'KeyQ' },
    'R': { 'keyCode': 82, 'key': 'R', 'code': 'KeyR' },
    'S': { 'keyCode': 83, 'key': 'S', 'code': 'KeyS' },
    'T': { 'keyCode': 84, 'key': 'T', 'code': 'KeyT' },
    'U': { 'keyCode': 85, 'key': 'U', 'code': 'KeyU' },
    'V': { 'keyCode': 86, 'key': 'V', 'code': 'KeyV' },
    'W': { 'keyCode': 87, 'key': 'W', 'code': 'KeyW' },
    'X': { 'keyCode': 88, 'key': 'X', 'code': 'KeyX' },
    'Y': { 'keyCode': 89, 'key': 'Y', 'code': 'KeyY' },
    'Z': { 'keyCode': 90, 'key': 'Z', 'code': 'KeyZ' },
    ':': { 'keyCode': 186, 'key': ':', 'code': 'Semicolon' },
    '<': { 'keyCode': 188, 'key': '\<', 'code': 'Comma' },
    '_': { 'keyCode': 189, 'key': '_', 'code': 'Minus' },
    '>': { 'keyCode': 190, 'key': '>', 'code': 'Period' },
    '?': { 'keyCode': 191, 'key': '?', 'code': 'Slash' },
    '~': { 'keyCode': 192, 'key': '~', 'code': 'Backquote' },
    '{': { 'keyCode': 219, 'key': '{', 'code': 'BracketLeft' },
    '|': { 'keyCode': 220, 'key': '|', 'code': 'Backslash' },
    '}': { 'keyCode': 221, 'key': '}', 'code': 'BracketRight' },
    '"': { 'keyCode': 222, 'key': '"', 'code': 'Quote' },
    'SoftLeft': { 'key': 'SoftLeft', 'code': 'SoftLeft', 'location': 4 },
    'SoftRight': { 'key': 'SoftRight', 'code': 'SoftRight', 'location': 4 },
    'Camera': { 'keyCode': 44, 'key': 'Camera', 'code': 'Camera', 'location': 4 },
    'Call': { 'key': 'Call', 'code': 'Call', 'location': 4 },
    'EndCall': { 'keyCode': 95, 'key': 'EndCall', 'code': 'EndCall', 'location': 4 },
    'VolumeDown': { 'keyCode': 182, 'key': 'VolumeDown', 'code': 'VolumeDown', 'location': 4 },
    'VolumeUp': { 'keyCode': 183, 'key': 'VolumeUp', 'code': 'VolumeUp', 'location': 4 },
};
exports.macEditingCommands = {
    'Backspace': 'deleteBackward:',
    'Tab': 'insertTab:',
    'Enter': 'insertNewline:',
    'NumpadEnter': 'insertNewline:',
    'Escape': 'cancelOperation:',
    'ArrowUp': 'moveUp:',
    'ArrowDown': 'moveDown:',
    'ArrowLeft': 'moveLeft:',
    'ArrowRight': 'moveRight:',
    'F5': 'complete:',
    'Delete': 'deleteForward:',
    'Home': 'scrollToBeginningOfDocument:',
    'End': 'scrollToEndOfDocument:',
    'PageUp': 'scrollPageUp:',
    'PageDown': 'scrollPageDown:',
    'Shift+Backspace': 'deleteBackward:',
    'Shift+Enter': 'insertNewline:',
    'Shift+NumpadEnter': 'insertNewline:',
    'Shift+Tab': 'insertBacktab:',
    'Shift+Escape': 'cancelOperation:',
    'Shift+ArrowUp': 'moveUpAndModifySelection:',
    'Shift+ArrowDown': 'moveDownAndModifySelection:',
    'Shift+ArrowLeft': 'moveLeftAndModifySelection:',
    'Shift+ArrowRight': 'moveRightAndModifySelection:',
    'Shift+F5': 'complete:',
    'Shift+Delete': 'deleteForward:',
    'Shift+Home': 'moveToBeginningOfDocumentAndModifySelection:',
    'Shift+End': 'moveToEndOfDocumentAndModifySelection:',
    'Shift+PageUp': 'pageUpAndModifySelection:',
    'Shift+PageDown': 'pageDownAndModifySelection:',
    'Shift+Numpad5': 'delete:',
    'Control+Tab': 'selectNextKeyView:',
    'Control+Enter': 'insertLineBreak:',
    'Control+NumpadEnter': 'insertLineBreak:',
    'Control+Quote': 'insertSingleQuoteIgnoringSubstitution:',
    'Control+KeyA': 'moveToBeginningOfParagraph:',
    'Control+KeyB': 'moveBackward:',
    'Control+KeyD': 'deleteForward:',
    'Control+KeyE': 'moveToEndOfParagraph:',
    'Control+KeyF': 'moveForward:',
    'Control+KeyH': 'deleteBackward:',
    'Control+KeyK': 'deleteToEndOfParagraph:',
    'Control+KeyL': 'centerSelectionInVisibleArea:',
    'Control+KeyN': 'moveDown:',
    'Control+KeyO': ['insertNewlineIgnoringFieldEditor:', 'moveBackward:'],
    'Control+KeyP': 'moveUp:',
    'Control+KeyT': 'transpose:',
    'Control+KeyV': 'pageDown:',
    'Control+KeyY': 'yank:',
    'Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
    'Control+ArrowUp': 'scrollPageUp:',
    'Control+ArrowDown': 'scrollPageDown:',
    'Control+ArrowLeft': 'moveToLeftEndOfLine:',
    'Control+ArrowRight': 'moveToRightEndOfLine:',
    'Shift+Control+Enter': 'insertLineBreak:',
    'Shift+Control+NumpadEnter': 'insertLineBreak:',
    'Shift+Control+Tab': 'selectPreviousKeyView:',
    'Shift+Control+Quote': 'insertDoubleQuoteIgnoringSubstitution:',
    'Shift+Control+KeyA': 'moveToBeginningOfParagraphAndModifySelection:',
    'Shift+Control+KeyB': 'moveBackwardAndModifySelection:',
    'Shift+Control+KeyE': 'moveToEndOfParagraphAndModifySelection:',
    'Shift+Control+KeyF': 'moveForwardAndModifySelection:',
    'Shift+Control+KeyN': 'moveDownAndModifySelection:',
    'Shift+Control+KeyP': 'moveUpAndModifySelection:',
    'Shift+Control+KeyV': 'pageDownAndModifySelection:',
    'Shift+Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
    'Shift+Control+ArrowUp': 'scrollPageUp:',
    'Shift+Control+ArrowDown': 'scrollPageDown:',
    'Shift+Control+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
    'Shift+Control+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
    'Alt+Backspace': 'deleteWordBackward:',
    'Alt+Tab': 'insertTabIgnoringFieldEditor:',
    'Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
    'Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
    'Alt+Escape': 'complete:',
    'Alt+ArrowUp': ['moveBackward:', 'moveToBeginningOfParagraph:'],
    'Alt+ArrowDown': ['moveForward:', 'moveToEndOfParagraph:'],
    'Alt+ArrowLeft': 'moveWordLeft:',
    'Alt+ArrowRight': 'moveWordRight:',
    'Alt+Delete': 'deleteWordForward:',
    'Alt+PageUp': 'pageUp:',
    'Alt+PageDown': 'pageDown:',
    'Shift+Alt+Backspace': 'deleteWordBackward:',
    'Shift+Alt+Tab': 'insertTabIgnoringFieldEditor:',
    'Shift+Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
    'Shift+Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
    'Shift+Alt+Escape': 'complete:',
    'Shift+Alt+ArrowUp': 'moveParagraphBackwardAndModifySelection:',
    'Shift+Alt+ArrowDown': 'moveParagraphForwardAndModifySelection:',
    'Shift+Alt+ArrowLeft': 'moveWordLeftAndModifySelection:',
    'Shift+Alt+ArrowRight': 'moveWordRightAndModifySelection:',
    'Shift+Alt+Delete': 'deleteWordForward:',
    'Shift+Alt+PageUp': 'pageUp:',
    'Shift+Alt+PageDown': 'pageDown:',
    'Control+Alt+KeyB': 'moveWordBackward:',
    'Control+Alt+KeyF': 'moveWordForward:',
    'Control+Alt+Backspace': 'deleteWordBackward:',
    'Shift+Control+Alt+KeyB': 'moveWordBackwardAndModifySelection:',
    'Shift+Control+Alt+KeyF': 'moveWordForwardAndModifySelection:',
    'Shift+Control+Alt+Backspace': 'deleteWordBackward:',
    'Meta+NumpadSubtract': 'cancel:',
    'Meta+Backspace': 'deleteToBeginningOfLine:',
    'Meta+ArrowUp': 'moveToBeginningOfDocument:',
    'Meta+ArrowDown': 'moveToEndOfDocument:',
    'Meta+ArrowLeft': 'moveToLeftEndOfLine:',
    'Meta+ArrowRight': 'moveToRightEndOfLine:',
    'Shift+Meta+NumpadSubtract': 'cancel:',
    'Shift+Meta+Backspace': 'deleteToBeginningOfLine:',
    'Shift+Meta+ArrowUp': 'moveToBeginningOfDocumentAndModifySelection:',
    'Shift+Meta+ArrowDown': 'moveToEndOfDocumentAndModifySelection:',
    'Shift+Meta+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
    'Shift+Meta+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
    'Meta+KeyA': 'selectAll:',
};


/***/ }),

/***/ "./src/web.ts":
/*!********************!*\
  !*** ./src/web.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const crBrowser_1 = __webpack_require__(/*! ./chromium/crBrowser */ "./src/chromium/crBrowser.ts");
const ffBrowser_1 = __webpack_require__(/*! ./firefox/ffBrowser */ "./src/firefox/ffBrowser.ts");
const wkBrowser_1 = __webpack_require__(/*! ./webkit/wkBrowser */ "./src/webkit/wkBrowser.ts");
const platform = __webpack_require__(/*! ./platform */ "./src/platform.ts");
const connect = {
    chromium: {
        connect: async (url) => {
            const transport = new platform.WebSocketTransport(url);
            return crBrowser_1.CRBrowser.connect(transport);
        }
    },
    webkit: {
        connect: async (url) => {
            const transport = new platform.WebSocketTransport(url);
            return wkBrowser_1.WKBrowser.connect(transport);
        }
    },
    firefox: {
        connect: async (url) => {
            const transport = new platform.WebSocketTransport(url);
            return ffBrowser_1.FFBrowser.connect(transport);
        }
    }
};
module.exports = connect;


/***/ }),

/***/ "./src/webkit/wkAccessibility.ts":
/*!***************************************!*\
  !*** ./src/webkit/wkAccessibility.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
async function getAccessibilityTree(session, needle) {
    const objectId = needle ? needle._remoteObject.objectId : undefined;
    const { axNode } = await session.send('Page.accessibilitySnapshot', { objectId });
    const tree = new WKAXNode(axNode);
    return {
        tree,
        needle: needle ? tree._findNeedle() : null
    };
}
exports.getAccessibilityTree = getAccessibilityTree;
const WKRoleToARIARole = new Map(Object.entries({
    'TextField': 'textbox',
}));
// WebKit localizes role descriptions on mac, but the english versions only add noise.
const WKUnhelpfulRoleDescriptions = new Map(Object.entries({
    'WebArea': 'HTML content',
    'Summary': 'summary',
    'DescriptionList': 'description list',
    'ImageMap': 'image map',
    'ListMarker': 'list marker',
    'Video': 'video playback',
    'Mark': 'highlighted',
    'contentinfo': 'content information',
    'Details': 'details',
    'DescriptionListDetail': 'description',
    'DescriptionListTerm': 'term',
    'alertdialog': 'web alert dialog',
    'dialog': 'web dialog',
    'status': 'application status',
    'tabpanel': 'tab panel',
    'application': 'web application',
}));
class WKAXNode {
    constructor(payload) {
        this._payload = payload;
        this._children = [];
        for (const payload of this._payload.children || [])
            this._children.push(new WKAXNode(payload));
    }
    children() {
        return this._children;
    }
    _findNeedle() {
        if (this._payload.found)
            return this;
        for (const child of this._children) {
            const found = child._findNeedle();
            if (found)
                return found;
        }
        return null;
    }
    isControl() {
        switch (this._payload.role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'TextField':
            case 'tree':
                return true;
            default:
                return false;
        }
    }
    _isTextControl() {
        switch (this._payload.role) {
            case 'combobox':
            case 'searchfield':
            case 'textbox':
            case 'TextField':
                return true;
        }
        return false;
    }
    _name() {
        if (this._payload.role === 'text')
            return this._payload.value || '';
        return this._payload.name || '';
    }
    isInteresting(insideControl) {
        const { role, focusable } = this._payload;
        const name = this._name();
        if (role === 'ScrollArea')
            return false;
        if (role === 'WebArea')
            return true;
        if (focusable || role === 'MenuListOption')
            return true;
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl())
            return true;
        // A non focusable child of a control is not interesting
        if (insideControl)
            return false;
        return this.isLeafNode() && !!name;
    }
    _hasRendundantTextChild() {
        if (this._children.length !== 1)
            return false;
        const child = this._children[0];
        return child._payload.role === 'text' && this._payload.name === child._payload.value;
    }
    isLeafNode() {
        if (!this._children.length)
            return true;
        // WebKit on Linux ignores everything inside text controls, normalize this behavior
        if (this._isTextControl())
            return true;
        // WebKit for mac has text nodes inside heading, li, menuitem, a, and p nodes
        if (this._hasRendundantTextChild())
            return true;
        return false;
    }
    serialize() {
        const node = {
            role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
            name: this._name(),
        };
        if ('description' in this._payload && this._payload.description !== node.name)
            node.description = this._payload.description;
        if ('roledescription' in this._payload) {
            const roledescription = this._payload.roledescription;
            if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
                node.roledescription = roledescription;
        }
        if ('value' in this._payload && this._payload.role !== 'text')
            node.value = this._payload.value;
        const userStringProperties = [
            'keyshortcuts',
            'valuetext'
        ];
        for (const userStringProperty of userStringProperties) {
            if (!(userStringProperty in this._payload))
                continue;
            node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        for (const booleanProperty of booleanProperties) {
            // WebArea and ScorllArea treat focus differently than other nodes. They report whether their frame  has focus,
            // not whether focus is specifically on the root node.
            if (booleanProperty === 'focused' && (this._payload.role === 'WebArea' || this._payload.role === 'ScrollArea'))
                continue;
            const value = this._payload[booleanProperty];
            if (!value)
                continue;
            node[booleanProperty] = value;
        }
        const tristateProperties = [
            'checked',
            'pressed',
        ];
        for (const tristateProperty of tristateProperties) {
            if (!(tristateProperty in this._payload))
                continue;
            const value = this._payload[tristateProperty];
            node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        for (const numericalProperty of numericalProperties) {
            if (!(numericalProperty in this._payload))
                continue;
            node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
        ];
        for (const tokenProperty of tokenProperties) {
            const value = this._payload[tokenProperty];
            if (!value || value === 'false')
                continue;
            node[tokenProperty] = value;
        }
        const orientationIsApplicable = new Set([
            'ScrollArea',
            'scrollbar',
            'listbox',
            'combobox',
            'menu',
            'tree',
            'separator',
            'slider',
            'tablist',
            'toolbar',
        ]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
            node.orientation = this._payload.orientation;
        return node;
    }
}


/***/ }),

/***/ "./src/webkit/wkBrowser.ts":
/*!*********************************!*\
  !*** ./src/webkit/wkBrowser.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = __webpack_require__(/*! ../browser */ "./src/browser.ts");
const browserContext_1 = __webpack_require__(/*! ../browserContext */ "./src/browserContext.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const transport_1 = __webpack_require__(/*! ../transport */ "./src/transport.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const wkConnection_1 = __webpack_require__(/*! ./wkConnection */ "./src/webkit/wkConnection.ts");
const wkPageProxy_1 = __webpack_require__(/*! ./wkPageProxy */ "./src/webkit/wkPageProxy.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.4 Safari/605.1.15';
class WKBrowser extends platform.EventEmitter {
    constructor(transport) {
        super();
        this._contexts = new Map();
        this._pageProxies = new Map();
        this._connection = new wkConnection_1.WKConnection(transport, this._onDisconnect.bind(this));
        this._browserSession = this._connection.browserSession;
        this._defaultContext = this._createBrowserContext(undefined, {});
        this._eventListeners = [
            helper_1.helper.addEventListener(this._browserSession, 'Browser.pageProxyCreated', this._onPageProxyCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Browser.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Browser.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)),
            helper_1.helper.addEventListener(this._browserSession, wkConnection_1.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this)),
        ];
        this._firstPageProxyPromise = new Promise(resolve => this._firstPageProxyCallback = resolve);
    }
    static async connect(transport, slowMo = 0) {
        const browser = new WKBrowser(transport_1.SlowMoTransport.wrap(transport, slowMo));
        return browser;
    }
    _onDisconnect() {
        for (const context of this.contexts())
            context._browserClosed();
        for (const pageProxy of this._pageProxies.values())
            pageProxy.dispose();
        this._pageProxies.clear();
        this.emit(events_1.Events.Browser.Disconnected);
    }
    async newContext(options = {}) {
        const { browserContextId } = await this._browserSession.send('Browser.createContext');
        options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
        const context = this._createBrowserContext(browserContextId, options);
        if (options.ignoreHTTPSErrors)
            await this._browserSession.send('Browser.setIgnoreCertificateErrors', { browserContextId, ignore: true });
        if (options.locale)
            await this._browserSession.send('Browser.setLanguages', { browserContextId, languages: [options.locale] });
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _waitForFirstPageTarget() {
        helper_1.assert(!this._pageProxies.size);
        return this._firstPageProxyPromise;
    }
    _onPageProxyCreated(event) {
        const { pageProxyInfo } = event;
        const pageProxyId = pageProxyInfo.pageProxyId;
        let context = null;
        if (pageProxyInfo.browserContextId) {
            // FIXME: we don't know about the default context id, so assume that all targets from
            // unknown contexts are created in the 'default' context which can in practice be represented
            // by multiple actual contexts in WebKit. Solving this properly will require adding context
            // lifecycle events.
            context = this._contexts.get(pageProxyInfo.browserContextId);
        }
        if (!context)
            context = this._defaultContext;
        const pageProxySession = new wkConnection_1.WKSession(this._connection, pageProxyId, `The page has been closed.`, (message) => {
            this._connection.rawSend({ ...message, pageProxyId });
        });
        const pageProxy = new wkPageProxy_1.WKPageProxy(pageProxySession, context, () => {
            if (!pageProxyInfo.openerId)
                return null;
            const opener = this._pageProxies.get(pageProxyInfo.openerId);
            if (!opener)
                return null;
            return opener;
        });
        this._pageProxies.set(pageProxyId, pageProxy);
        if (pageProxyInfo.openerId) {
            const opener = this._pageProxies.get(pageProxyInfo.openerId);
            if (opener)
                opener.onPopupCreated(pageProxy);
        }
        if (this._firstPageProxyCallback) {
            this._firstPageProxyCallback();
            this._firstPageProxyCallback = undefined;
        }
    }
    _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const pageProxy = this._pageProxies.get(pageProxyId);
        pageProxy.didClose();
        pageProxy.dispose();
        this._pageProxies.delete(pageProxyId);
    }
    _onPageProxyMessageReceived(event) {
        const pageProxy = this._pageProxies.get(event.pageProxyId);
        pageProxy.dispatchMessageToSession(event.message);
    }
    _onProvisionalLoadFailed(event) {
        const pageProxy = this._pageProxies.get(event.pageProxyId);
        pageProxy.handleProvisionalLoadFailed(event);
    }
    isConnected() {
        return !this._connection.isClosed();
    }
    async close() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        const disconnected = new Promise(f => this.once(events_1.Events.Browser.Disconnected, f));
        await Promise.all(this.contexts().map(context => context.close()));
        this._connection.close();
        await disconnected;
    }
    _createBrowserContext(browserContextId, options) {
        browserContext_1.BrowserContext.validateOptions(options);
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const pageProxies = Array.from(this._pageProxies.values()).filter(proxy => proxy._browserContext === context);
                return await Promise.all(pageProxies.map(proxy => proxy.page()));
            },
            existingPages: () => {
                const pages = [];
                for (const pageProxy of this._pageProxies.values()) {
                    if (pageProxy._browserContext !== context)
                        continue;
                    const page = pageProxy.existingPage();
                    if (page)
                        pages.push(page);
                }
                return pages;
            },
            newPage: async () => {
                const { pageProxyId } = await this._browserSession.send('Browser.createPage', { browserContextId });
                const pageProxy = this._pageProxies.get(pageProxyId);
                return await pageProxy.page();
            },
            close: async () => {
                helper_1.assert(browserContextId, 'Non-incognito profiles cannot be closed!');
                await this._browserSession.send('Browser.deleteContext', { browserContextId: browserContextId });
                this._contexts.delete(browserContextId);
            },
            cookies: async () => {
                const { cookies } = await this._browserSession.send('Browser.getAllCookies', { browserContextId });
                return cookies.map((c) => ({
                    ...c,
                    expires: c.expires === 0 ? -1 : c.expires
                }));
            },
            clearCookies: async () => {
                await this._browserSession.send('Browser.deleteAllCookies', { browserContextId });
            },
            setCookies: async (cookies) => {
                const cc = cookies.map(c => ({ ...c, session: c.expires === -1 || c.expires === undefined }));
                await this._browserSession.send('Browser.setCookies', { cookies: cc, browserContextId });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geolocation'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._browserSession.send('Browser.grantPermissions', { origin, browserContextId, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._browserSession.send('Browser.resetPermissions', { browserContextId });
            },
            setGeolocation: async (geolocation) => {
                const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : undefined;
                await this._browserSession.send('Browser.setGeolocationOverride', { browserContextId, geolocation: payload });
            }
        }, options);
        return context;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugFunction = debugFunction;
    }
}
exports.WKBrowser = WKBrowser;


/***/ }),

/***/ "./src/webkit/wkConnection.ts":
/*!************************************!*\
  !*** ./src/webkit/wkConnection.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
// WKPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
// We emulate kPageProxyMessageReceived message to unify it with Browser.pageProxyCreated
// and Browser.pageProxyDestroyed for easier management.
exports.kPageProxyMessageReceived = 'kPageProxyMessageReceived';
class WKConnection {
    constructor(transport, onDisconnect) {
        this._lastId = 0;
        this._closed = false;
        this._debugFunction = platform.debug('pw:protocol');
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this.browserSession = new WKSession(this, '', 'Browser has been closed.', (message) => {
            this.rawSend(message);
        });
    }
    nextMessageId() {
        return ++this._lastId;
    }
    rawSend(message) {
        message = JSON.stringify(message);
        this._debugFunction('SEND ► ' + message);
        this._transport.send(message);
    }
    _dispatchMessage(message) {
        this._debugFunction('◀ RECV ' + message);
        const object = JSON.parse(message);
        if (object.id === exports.kBrowserCloseMessageId)
            return;
        if (object.pageProxyId) {
            const payload = { message: object, pageProxyId: object.pageProxyId };
            this.browserSession.dispatchMessage({ method: exports.kPageProxyMessageReceived, params: payload });
            return;
        }
        this.browserSession.dispatchMessage(object);
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        this.browserSession.dispose();
        this._onDisconnect();
    }
    isClosed() {
        return this._closed;
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
}
exports.WKConnection = WKConnection;
class WKSession extends platform.EventEmitter {
    constructor(connection, sessionId, errorText, rawSend) {
        super();
        this._disposed = false;
        this._callbacks = new Map();
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    async send(method, params) {
        if (this._disposed)
            throw new Error(`Protocol error (${method}): ${this.errorText}`);
        const id = this.connection.nextMessageId();
        const messageObj = { id, method, params };
        platform.debug('pw:wrapped:' + this.sessionId)('SEND ► ' + JSON.stringify(messageObj, null, 2));
        this._rawSend(messageObj);
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    isDisposed() {
        return this._disposed;
    }
    dispose() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): ${this.errorText}`));
        this._callbacks.clear();
        this._disposed = true;
    }
    dispatchMessage(object) {
        platform.debug('pw:wrapped:' + this.sessionId)('◀ RECV ' + JSON.stringify(object, null, 2));
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else if (object.id) {
            // Response might come after session has been disposed and rejected all callbacks.
            helper_1.assert(this.isDisposed());
        }
        else {
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
}
exports.WKSession = WKSession;
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${JSON.stringify(object.error.data)}`;
    return rewriteError(error, message);
}
exports.createProtocolError = createProtocolError;
function rewriteError(error, message) {
    error.message = message;
    return error;
}
exports.rewriteError = rewriteError;
function isSwappedOutError(e) {
    return e.message.includes('Target was swapped out.');
}
exports.isSwappedOutError = isSwappedOutError;


/***/ }),

/***/ "./src/webkit/wkExecutionContext.ts":
/*!******************************************!*\
  !*** ./src/webkit/wkExecutionContext.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const wkConnection_1 = __webpack_require__(/*! ./wkConnection */ "./src/webkit/wkConnection.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const wkProtocolHelper_1 = __webpack_require__(/*! ./wkProtocolHelper */ "./src/webkit/wkProtocolHelper.ts");
const js = __webpack_require__(/*! ../javascript */ "./src/javascript.ts");
exports.EVALUATION_SCRIPT_URL = '__playwright_evaluation_script__';
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
class WKExecutionContext {
    constructor(session, contextId) {
        this._contextDestroyedCallback = () => { };
        this._session = session;
        this._contextId = contextId;
        this._executionContextDestroyedPromise = new Promise((resolve, reject) => {
            this._contextDestroyedCallback = resolve;
        });
    }
    _dispose() {
        this._contextDestroyedCallback();
    }
    async evaluate(context, returnByValue, pageFunction, ...args) {
        try {
            let response = await this._evaluateRemoteObject(pageFunction, args);
            if (response.result.type === 'object' && response.result.className === 'Promise') {
                response = await Promise.race([
                    this._executionContextDestroyedPromise.then(() => contextDestroyedResult),
                    this._session.send('Runtime.awaitPromise', {
                        promiseObjectId: response.result.objectId,
                        returnByValue: false
                    })
                ]);
            }
            if (response.wasThrown)
                throw new Error('Evaluation failed: ' + response.result.description);
            if (!returnByValue)
                return context._createHandle(response.result);
            if (response.result.objectId)
                return await this._returnObjectByValue(response.result.objectId);
            return wkProtocolHelper_1.valueFromRemoteObject(response.result);
        }
        catch (error) {
            if (wkConnection_1.isSwappedOutError(error) || error.message.includes('Missing injected script for given'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    async _evaluateRemoteObject(pageFunction, args) {
        if (helper_1.helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + '\n' + suffix;
            return await this._session.send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue: false,
                emulateUserGesture: true
            });
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        try {
            const callParams = this._serializeFunctionAndArguments(pageFunction, args);
            const thisObjectId = await this._contextGlobalObjectId();
            return await this._session.send('Runtime.callFunctionOn', {
                functionDeclaration: callParams.functionText + '\n' + suffix + '\n',
                objectId: thisObjectId,
                arguments: callParams.callArguments,
                returnByValue: false,
                emulateUserGesture: true
            });
        }
        catch (err) {
            if (err instanceof TypeError && err.message.startsWith('Converting circular structure to JSON'))
                err.message += ' Are you passing a nested JSHandle?';
            throw err;
        }
    }
    _serializeFunctionAndArguments(pageFunction, args) {
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (e1) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText = 'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (e2) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        let serializableArgs;
        if (args.some(isUnserializable)) {
            serializableArgs = [];
            const paramStrings = [];
            for (const arg of args) {
                if (isUnserializable(arg)) {
                    paramStrings.push(unserializableToString(arg));
                }
                else {
                    paramStrings.push('arguments[' + serializableArgs.length + ']');
                    serializableArgs.push(arg);
                }
            }
            functionText = `() => (${functionText})(${paramStrings.join(',')})`;
        }
        else {
            serializableArgs = args;
        }
        const serialized = serializableArgs.map((arg) => this._convertArgument(arg));
        return { functionText, callArguments: serialized };
        function unserializableToString(arg) {
            if (Object.is(arg, -0))
                return '-0';
            if (Object.is(arg, Infinity))
                return 'Infinity';
            if (Object.is(arg, -Infinity))
                return '-Infinity';
            if (Object.is(arg, NaN))
                return 'NaN';
            if (arg instanceof js.JSHandle) {
                const remoteObj = toRemoteObject(arg);
                if (!remoteObj.objectId)
                    return wkProtocolHelper_1.valueFromRemoteObject(remoteObj);
            }
            throw new Error('Unsupported value: ' + arg + ' (' + (typeof arg) + ')');
        }
        function isUnserializable(arg) {
            if (typeof arg === 'bigint')
                return true;
            if (Object.is(arg, -0))
                return true;
            if (Object.is(arg, Infinity))
                return true;
            if (Object.is(arg, -Infinity))
                return true;
            if (Object.is(arg, NaN))
                return true;
            if (arg instanceof js.JSHandle) {
                const remoteObj = toRemoteObject(arg);
                if (!remoteObj.objectId)
                    return !Object.is(wkProtocolHelper_1.valueFromRemoteObject(remoteObj), remoteObj.value);
            }
            return false;
        }
    }
    _contextGlobalObjectId() {
        if (!this._globalObjectIdPromise) {
            this._globalObjectIdPromise = this._session.send('Runtime.evaluate', {
                expression: 'this',
                contextId: this._contextId
            }).then(response => {
                return response.result.objectId;
            });
        }
        return this._globalObjectIdPromise;
    }
    async _returnObjectByValue(objectId) {
        try {
            const serializeResponse = await this._session.send('Runtime.callFunctionOn', {
                // Serialize object using standard JSON implementation to correctly pass 'undefined'.
                functionDeclaration: 'function(){return this}\n' + suffix + '\n',
                objectId: objectId,
                returnByValue: true
            });
            if (serializeResponse.wasThrown)
                return undefined;
            return serializeResponse.result.value;
        }
        catch (e) {
            if (wkConnection_1.isSwappedOutError(e))
                return contextDestroyedResult;
            return undefined;
        }
    }
    async getProperties(handle) {
        const objectId = toRemoteObject(handle).objectId;
        if (!objectId)
            return new Map();
        const response = await this._session.send('Runtime.getProperties', {
            objectId,
            ownProperties: true
        });
        const result = new Map();
        for (const property of response.properties) {
            if (!property.enumerable)
                continue;
            result.set(property.name, handle._context._createHandle(property.value));
        }
        return result;
    }
    async releaseHandle(handle) {
        await wkProtocolHelper_1.releaseObject(this._session, toRemoteObject(handle));
    }
    async handleJSONValue(handle) {
        const remoteObject = toRemoteObject(handle);
        if (remoteObject.objectId) {
            const response = await this._session.send('Runtime.callFunctionOn', {
                functionDeclaration: 'function() { return this; }',
                objectId: remoteObject.objectId,
                returnByValue: true
            });
            return wkProtocolHelper_1.valueFromRemoteObject(response.result);
        }
        return wkProtocolHelper_1.valueFromRemoteObject(remoteObject);
    }
    handleToString(handle, includeType) {
        const object = toRemoteObject(handle);
        if (object.objectId) {
            let type = object.subtype || object.type;
            // FIXME: promise doesn't have special subtype in WebKit.
            if (object.className === 'Promise')
                type = 'promise';
            return 'JSHandle@' + type;
        }
        return (includeType ? 'JSHandle:' : '') + wkProtocolHelper_1.valueFromRemoteObject(object);
    }
    _convertArgument(arg) {
        const objectHandle = arg && (arg instanceof js.JSHandle) ? arg : null;
        if (objectHandle) {
            if (objectHandle._context._delegate !== this)
                throw new Error('JSHandles can be evaluated only in the context they were created!');
            if (objectHandle._disposed)
                throw new Error('JSHandle is disposed!');
            const remoteObject = toRemoteObject(arg);
            if (!remoteObject.objectId)
                return { value: wkProtocolHelper_1.valueFromRemoteObject(remoteObject) };
            return { objectId: remoteObject.objectId };
        }
        return { value: arg };
    }
}
exports.WKExecutionContext = WKExecutionContext;
const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;
const contextDestroyedResult = {
    wasThrown: true,
    result: {
        description: 'Protocol error: Execution context was destroyed, most likely because of a navigation.'
    }
};
function toRemoteObject(handle) {
    return handle._remoteObject;
}


/***/ }),

/***/ "./src/webkit/wkInput.ts":
/*!*******************************!*\
  !*** ./src/webkit/wkInput.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const input = __webpack_require__(/*! ../input */ "./src/input.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const usKeyboardLayout_1 = __webpack_require__(/*! ../usKeyboardLayout */ "./src/usKeyboardLayout.ts");
function toModifiersMask(modifiers) {
    // From Source/WebKit/Shared/WebEvent.h
    let mask = 0;
    if (modifiers.has('Shift'))
        mask |= 1;
    if (modifiers.has('Control'))
        mask |= 2;
    if (modifiers.has('Alt'))
        mask |= 4;
    if (modifiers.has('Meta'))
        mask |= 8;
    return mask;
}
class RawKeyboardImpl {
    constructor(session) {
        this._pageProxySession = session;
    }
    setSession(session) {
        this._session = session;
    }
    async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
        const parts = [];
        for (const modifier of (['Shift', 'Control', 'Alt', 'Meta'])) {
            if (modifiers.has(modifier))
                parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join('+');
        let commands = usKeyboardLayout_1.macEditingCommands[shortcut];
        if (helper_1.helper.isString(commands))
            commands = [commands];
        await this._pageProxySession.send('Input.dispatchKeyEvent', {
            type: 'keyDown',
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCode,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            macCommands: commands,
            isKeypad: location === input.keypadLocation
        });
    }
    async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
        await this._pageProxySession.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCode,
            code,
            isKeypad: location === input.keypadLocation
        });
    }
    async sendText(text) {
        await this._session.send('Page.insertText', { text });
    }
}
exports.RawKeyboardImpl = RawKeyboardImpl;
class RawMouseImpl {
    constructor(session) {
        this._pageProxySession = session;
    }
    async move(x, y, button, buttons, modifiers) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'move',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers)
        });
    }
    async down(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'down',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
    async up(x, y, button, buttons, modifiers, clickCount) {
        await this._pageProxySession.send('Input.dispatchMouseEvent', {
            type: 'up',
            button,
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
        });
    }
}
exports.RawMouseImpl = RawMouseImpl;


/***/ }),

/***/ "./src/webkit/wkInterceptableRequest.ts":
/*!**********************************************!*\
  !*** ./src/webkit/wkInterceptableRequest.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const network = __webpack_require__(/*! ../network */ "./src/network.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const errorReasons = {
    'aborted': 'Cancellation',
    'accessdenied': 'AccessControl',
    'addressunreachable': 'General',
    'blockedbyclient': 'Cancellation',
    'blockedbyresponse': 'General',
    'connectionaborted': 'General',
    'connectionclosed': 'General',
    'connectionfailed': 'General',
    'connectionrefused': 'General',
    'connectionreset': 'General',
    'internetdisconnected': 'General',
    'namenotresolved': 'General',
    'timedout': 'Timeout',
    'failed': 'General',
};
class WKInterceptableRequest {
    constructor(session, allowInterception, frame, event, redirectChain, documentId) {
        this._interceptedCallback = () => { };
        this._session = session;
        this._requestId = event.requestId;
        this.request = new network.Request(allowInterception ? this : null, frame, redirectChain, documentId, event.request.url, event.type ? event.type.toLowerCase() : 'Unknown', event.request.method, event.request.postData, headersObject(event.request.headers));
        this._interceptedPromise = new Promise(f => this._interceptedCallback = f);
    }
    async abort(errorCode) {
        const reason = errorReasons[errorCode];
        helper_1.assert(reason, 'Unknown error code: ' + errorCode);
        await this._interceptedPromise;
        await this._session.send('Network.interceptAsError', { requestId: this._requestId, reason }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
    async fulfill(response) {
        await this._interceptedPromise;
        const base64Encoded = !!response.body && !helper_1.helper.isString(response.body);
        const responseBody = response.body ? (base64Encoded ? response.body.toString('base64') : response.body) : undefined;
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers))
                responseHeaders[header.toLowerCase()] = String(response.headers[header]);
        }
        if (response.contentType)
            responseHeaders['content-type'] = response.contentType;
        if (responseBody && !('content-length' in responseHeaders))
            responseHeaders['content-length'] = String(platform.Buffer.byteLength(responseBody));
        await this._session.send('Network.interceptWithResponse', {
            requestId: this._requestId,
            status: response.status || 200,
            statusText: network.STATUS_TEXTS[String(response.status || 200)],
            mimeType: response.contentType || (base64Encoded ? 'application/octet-stream' : 'text/plain'),
            headers: responseHeaders,
            base64Encoded,
            content: responseBody
        }).catch(error => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
    async continue(overrides) {
        await this._interceptedPromise;
        await this._session.send('Network.interceptContinue', {
            requestId: this._requestId,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
        }).catch((error) => {
            // In certain cases, protocol will return error if the request was already canceled
            // or the page was closed. We should tolerate these errors.
            helper_1.debugError(error);
        });
    }
    createResponse(responsePayload) {
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', { requestId: this._requestId });
            return platform.Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, headersObject(responsePayload.headers), getResponseBody);
    }
}
exports.WKInterceptableRequest = WKInterceptableRequest;
function headersObject(headers) {
    const result = {};
    for (const key of Object.keys(headers))
        result[key.toLowerCase()] = headers[key];
    return result;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/webkit/wkPage.ts":
/*!******************************!*\
  !*** ./src/webkit/wkPage.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const dom = __webpack_require__(/*! ../dom */ "./src/dom.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const wkExecutionContext_1 = __webpack_require__(/*! ./wkExecutionContext */ "./src/webkit/wkExecutionContext.ts");
const wkInterceptableRequest_1 = __webpack_require__(/*! ./wkInterceptableRequest */ "./src/webkit/wkInterceptableRequest.ts");
const wkWorkers_1 = __webpack_require__(/*! ./wkWorkers */ "./src/webkit/wkWorkers.ts");
const page_1 = __webpack_require__(/*! ../page */ "./src/page.ts");
const dialog = __webpack_require__(/*! ../dialog */ "./src/dialog.ts");
const wkInput_1 = __webpack_require__(/*! ./wkInput */ "./src/webkit/wkInput.ts");
const platform = __webpack_require__(/*! ../platform */ "./src/platform.ts");
const wkAccessibility_1 = __webpack_require__(/*! ./wkAccessibility */ "./src/webkit/wkAccessibility.ts");
const wkProvisionalPage_1 = __webpack_require__(/*! ./wkProvisionalPage */ "./src/webkit/wkProvisionalPage.ts");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
const BINDING_CALL_MESSAGE = '__playwright_binding_call__';
class WKPage {
    constructor(browserContext, pageProxySession, openerResolver) {
        this._provisionalPage = null;
        this._requestIdToRequest = new Map();
        this._sessionListeners = [];
        this._bootstrapScripts = [];
        this._pageProxySession = pageProxySession;
        this._openerResolver = openerResolver;
        this.rawKeyboard = new wkInput_1.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new wkInput_1.RawMouseImpl(pageProxySession);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._workers = new wkWorkers_1.WKWorkers(this._page);
        this._session = undefined;
        this._page.on(events_1.Events.Page.FrameDetached, frame => this._removeContextsForFrame(frame, false));
    }
    async _initializePageProxySession() {
        const promises = [
            this._pageProxySession.send('Dialog.enable'),
            this._pageProxySession.send('Emulation.setActiveAndFocused', { active: true }),
            this.authenticate(this._page._state.credentials)
        ];
        const contextOptions = this._page.context()._options;
        if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send('Emulation.setJavaScriptEnabled', { enabled: false }));
        if (this._page._state.viewportSize || contextOptions.viewport)
            promises.push(this._updateViewport(true /* updateTouch */));
        await Promise.all(promises);
    }
    _setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
    }
    async initialize(session) {
        this._setSession(session);
        await Promise.all([
            this._initializePageProxySession(),
            this._initializeSession(this._session, ({ frameTree }) => this._handleFrameTree(frameTree)),
        ]);
    }
    // This method is called for provisional targets as well. The session passed as the parameter
    // may be different from the current session and may be destroyed without becoming current.
    async _initializeSession(session, resourceTreeHandler) {
        await this._initializeSessionMayThrow(session, resourceTreeHandler).catch(e => {
            if (session.isDisposed())
                return;
            // Swallow initialization errors due to newer target swap in,
            // since we will reinitialize again.
            if (this._session === session)
                throw e;
        });
    }
    async _initializeSessionMayThrow(session, resourceTreeHandler) {
        const [, frameTree] = await Promise.all([
            // Page agent must be enabled before Runtime.
            session.send('Page.enable'),
            session.send('Page.getResourceTree'),
        ]);
        resourceTreeHandler(frameTree);
        const promises = [
            // Resource tree should be received before first execution context.
            session.send('Runtime.enable'),
            session.send('Page.createUserWorld', { name: UTILITY_WORLD_NAME }).catch(_ => { }),
            session.send('Console.enable'),
            session.send('Network.enable'),
            this._workers.initializeSession(session)
        ];
        if (this._page._state.interceptNetwork)
            promises.push(session.send('Network.setInterceptionEnabled', { enabled: true, interceptRequests: true }));
        if (this._page._state.offlineMode)
            promises.push(session.send('Network.setEmulateOfflineState', { offline: true }));
        if (this._page._state.cacheEnabled === false)
            promises.push(session.send('Network.setResourceCachingDisabled', { disabled: true }));
        const contextOptions = this._page.context()._options;
        if (contextOptions.userAgent)
            promises.push(session.send('Page.overrideUserAgent', { value: contextOptions.userAgent }));
        if (this._page._state.mediaType || this._page._state.colorScheme)
            promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme));
        if (this._bootstrapScripts.length) {
            const source = this._bootstrapScripts.join(';');
            promises.push(session.send('Page.setBootstrapScript', { source }));
        }
        if (contextOptions.bypassCSP)
            promises.push(session.send('Page.setBypassCSP', { enabled: true }));
        if (this._page._state.extraHTTPHeaders || contextOptions.locale) {
            const headers = this._page._state.extraHTTPHeaders || {};
            if (contextOptions.locale)
                headers['Accept-Language'] = contextOptions.locale;
            promises.push(session.send('Network.setExtraHTTPHeaders', { headers }));
        }
        if (this._page._state.hasTouch)
            promises.push(session.send('Page.setTouchEmulationEnabled', { enabled: true }));
        if (contextOptions.timezoneId) {
            promises.push(session.send('Page.setTimeZone', { timeZone: contextOptions.timezoneId }).
                catch(e => { throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`); }));
        }
        await Promise.all(promises);
    }
    initializeProvisionalPage(provisionalSession) {
        helper_1.assert(!this._provisionalPage);
        this._provisionalPage = new wkProvisionalPage_1.WKProvisionalPage(provisionalSession, this);
        return this._provisionalPage.initializationPromise;
    }
    onProvisionalLoadCommitted(session) {
        helper_1.assert(this._provisionalPage);
        helper_1.assert(this._provisionalPage._session === session);
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(session);
    }
    onSessionDestroyed(session, crashed) {
        if (this._provisionalPage && this._provisionalPage._session === session) {
            this._provisionalPage.dispose();
            this._provisionalPage = null;
            return;
        }
        if (this._session === session && crashed)
            this.didClose(crashed);
    }
    didClose(crashed) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        if (crashed)
            this._page._didCrash();
        else
            this._page._didClose();
    }
    dispose() {
        if (this._provisionalPage) {
            this._provisionalPage.dispose();
            this._provisionalPage = null;
        }
        this._page._didDisconnect();
    }
    _addSessionListeners() {
        this._sessionListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(this._session, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.loadEventFired', event => this._onLifecycleEvent(event.frameId, 'load')),
            helper_1.helper.addEventListener(this._session, 'Page.domContentEventFired', event => this._onLifecycleEvent(event.frameId, 'domcontentloaded')),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(this._session, 'Console.messageAdded', event => this._onConsoleMessage(event)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Dialog.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(this._session, 'Network.requestWillBeSent', e => this._onRequestWillBeSent(this._session, e)),
            helper_1.helper.addEventListener(this._session, 'Network.requestIntercepted', e => this._onRequestIntercepted(e)),
            helper_1.helper.addEventListener(this._session, 'Network.responseReceived', e => this._onResponseReceived(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFinished', e => this._onLoadingFinished(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFailed', e => this._onLoadingFailed(e)),
        ];
    }
    async _updateState(method, params) {
        await this._forAllSessions(session => session.send(method, params).then());
    }
    async _forAllSessions(callback) {
        const sessions = [
            this._session
        ];
        // If the state changes during provisional load, push it to the provisional page
        // as well to always be in sync with the backend.
        if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
        await Promise.all(sessions.map(session => callback(session).catch(helper_1.debugError)));
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        helper_1.assert(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
            this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
    }
    _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame) {
                context._delegate._dispose();
                this._contextIdToContext.delete(contextId);
                if (notifyFrame)
                    frame._contextDestroyed(context);
            }
        }
    }
    _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
            return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
            return;
        const delegate = new wkExecutionContext_1.WKExecutionContext(this._session, contextPayload.id);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (contextPayload.type === 'normal')
            frame._contextCreated('main', context);
        else if (contextPayload.type === 'user' && contextPayload.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        if (contextPayload.type === 'normal' && frame === this._page.mainFrame())
            this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
    }
    async navigateFrame(frame, url, referrer) {
        if (this._pageProxySession.isDisposed())
            throw new Error('Target closed');
        const pageProxyId = this._pageProxySession.sessionId;
        const result = await this._pageProxySession.connection.browserSession.send('Browser.navigate', { url, pageProxyId, frameId: frame._id, referrer });
        return { newDocumentId: result.loaderId };
    }
    _onConsoleMessage(event) {
        // Note: do no introduce await in this function, otherwise we lose the ordering.
        // For example, frame.setContent relies on this.
        const { type, level, text, parameters, url, line: lineNumber, column: columnNumber, source } = event.message;
        if (level === 'debug' && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
            const parsedObjectId = JSON.parse(parameters[1].objectId);
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            this._page._onBindingCalled(parameters[2].value, context);
            return;
        }
        if (level === 'error' && source === 'javascript') {
            const error = new Error(text);
            error.stack = 'Error: ' + error.message; // Nullify stack. Stack is supposed to contain error message as the first line.
            this._page.emit(events_1.Events.Page.PageError, error);
            return;
        }
        let derivedType = type || '';
        if (type === 'log')
            derivedType = level;
        else if (type === 'timing')
            derivedType = 'timeEnd';
        const handles = (parameters || []).map(p => {
            let context = null;
            if (p.objectId) {
                const objectId = JSON.parse(p.objectId);
                context = this._contextIdToContext.get(objectId.injectedScriptId);
            }
            else {
                context = this._contextIdToContext.get(this._mainFrameContextId);
            }
            return context._createHandle(p);
        });
        this._page._addConsoleMessage(derivedType, handles, { url, lineNumber: (lineNumber || 1) - 1, columnNumber: (columnNumber || 1) - 1 }, handles.length ? undefined : text);
    }
    _onDialog(event) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(event.type, event.message, async (accept, promptText) => {
            await this._pageProxySession.send('Dialog.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    async _onFileChooserOpened(event) {
        const context = await this._page._frameManager.frame(event.frameId)._mainContext();
        const handle = context._createHandle(event.element).asElement();
        this._page._onFileChooserOpened(handle);
    }
    static async _setEmulateMedia(session, mediaType, colorScheme) {
        const promises = [];
        promises.push(session.send('Page.setEmulatedMedia', { media: mediaType || '' }));
        if (colorScheme !== null) {
            let appearance = '';
            switch (colorScheme) {
                case 'light':
                    appearance = 'Light';
                    break;
                case 'dark':
                    appearance = 'Dark';
                    break;
            }
            promises.push(session.send('Page.setForcedAppearance', { appearance }));
        }
        await Promise.all(promises);
    }
    async setExtraHTTPHeaders(headers) {
        const copy = { ...headers };
        const locale = this._page.context()._options.locale;
        if (locale)
            copy['Accept-Language'] = locale;
        await this._updateState('Network.setExtraHTTPHeaders', { headers: copy });
    }
    async setEmulateMedia(mediaType, colorScheme) {
        await this._forAllSessions(session => WKPage._setEmulateMedia(session, mediaType, colorScheme));
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._updateViewport(false /* updateTouch */);
    }
    async _updateViewport(updateTouch) {
        let viewport = this._page.context()._options.viewport || { width: 0, height: 0 };
        const viewportSize = this._page._state.viewportSize;
        if (viewportSize)
            viewport = { ...viewport, ...viewportSize };
        const promises = [
            this._pageProxySession.send('Emulation.setDeviceMetricsOverride', {
                width: viewport.width,
                height: viewport.height,
                fixedLayout: !!viewport.isMobile,
                deviceScaleFactor: viewport.deviceScaleFactor || 1
            }),
        ];
        if (updateTouch)
            promises.push(this._updateState('Page.setTouchEmulationEnabled', { enabled: !!viewport.isMobile }));
        await Promise.all(promises);
    }
    async setCacheEnabled(enabled) {
        const disabled = !enabled;
        await this._updateState('Network.setResourceCachingDisabled', { disabled });
    }
    async setRequestInterception(enabled) {
        await this._updateState('Network.setInterceptionEnabled', { enabled, interceptRequests: enabled });
    }
    async setOfflineMode(offline) {
        await this._updateState('Network.setEmulateOfflineState', { offline });
    }
    async authenticate(credentials) {
        await this._pageProxySession.send('Emulation.setAuthCredentials', { ...(credentials || { username: '', password: '' }) });
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        return await this._openerResolver();
    }
    async reload() {
        await this._session.send('Page.reload');
    }
    goBack() {
        return this._session.send('Page.goBack').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
                return false;
            throw error;
        });
    }
    goForward() {
        return this._session.send('Page.goForward').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
                return false;
            throw error;
        });
    }
    async exposeBinding(name, bindingFunction) {
        const script = `self.${name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${bindingFunction}`;
        this._bootstrapScripts.unshift(script);
        await this._setBootstrapScripts();
        await Promise.all(this._page.frames().map(frame => frame.evaluate(script).catch(helper_1.debugError)));
    }
    async evaluateOnNewDocument(script) {
        this._bootstrapScripts.push(script);
        await this._setBootstrapScripts();
    }
    async _setBootstrapScripts() {
        const source = this._bootstrapScripts.join(';');
        await this._updateState('Page.setBootstrapScript', { source });
    }
    async closePage(runBeforeUnload) {
        this._pageProxySession.send('Target.close', {
            targetId: this._session.sessionId,
            runBeforeUnload
        }).catch(helper_1.debugError);
    }
    getBoundingBoxForScreenshot(handle) {
        return handle.boundingBox();
    }
    canScreenshotOutsideViewport() {
        return false;
    }
    async setBackgroundColor(color) {
        // TODO: line below crashes, sort it out.
        await this._session.send('Page.setDefaultBackgroundColorOverride', { color });
    }
    async takeScreenshot(format, options, viewportSize) {
        const rect = options.clip || { x: 0, y: 0, width: viewportSize.width, height: viewportSize.height };
        const result = await this._session.send('Page.snapshotRect', { ...rect, coordinateSystem: options.fullPage ? 'Page' : 'Viewport' });
        const prefix = 'data:image/png;base64,';
        let buffer = platform.Buffer.from(result.dataURL.substr(prefix.length), 'base64');
        if (format === 'jpeg')
            buffer = platform.pngToJpeg(buffer);
        return buffer;
    }
    async resetViewport(oldSize) {
        await this._pageProxySession.send('Emulation.setDeviceMetricsOverride', { ...oldSize, fixedLayout: false, deviceScaleFactor: 0 });
    }
    async getContentFrame(handle) {
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId
        });
        if (!nodeInfo.contentFrameId)
            return null;
        return this._page._frameManager.frame(nodeInfo.contentFrameId);
    }
    async getOwnerFrame(handle) {
        const remoteObject = toRemoteObject(handle);
        if (!remoteObject.objectId)
            return null;
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: remoteObject.objectId
        });
        return nodeInfo.ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._session.send('DOM.scrollIntoViewIfNeeded', {
            objectId: toRemoteObject(handle).objectId,
            rect,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                e.message = 'Node is either not visible or not an HTMLElement';
            throw e;
        });
    }
    async getContentQuads(handle) {
        const result = await this._session.send('DOM.getContentQuads', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] }
        ]);
    }
    async layoutViewport() {
        return this._page.evaluate(() => ({ width: innerWidth, height: innerHeight }));
    }
    async setInputFiles(handle, files) {
        const objectId = toRemoteObject(handle).objectId;
        await this._session.send('DOM.setInputFiles', { objectId, files });
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.send('DOM.resolveNode', {
            objectId: toRemoteObject(handle).objectId,
            executionContextId: to._delegate._contextId
        }).catch(helper_1.debugError);
        if (!result || result.object.subtype === 'null')
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.object);
    }
    async getAccessibilityTree(needle) {
        return wkAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const context = await parent._utilityContext();
        const handles = await context._$$('iframe');
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        await Promise.all(items.map(item => item === result ? Promise.resolve() : item.handle.dispose()));
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
    _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith('data:'))
            return;
        let redirectChain = [];
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse);
                redirectChain = request.request._redirectChain;
            }
        }
        const frame = this._page._frameManager.frame(event.frameId);
        // TODO(einbinder) this will fail if we are an XHR document request
        const isNavigationRequest = event.type === 'Document';
        const documentId = isNavigationRequest ? event.loaderId : undefined;
        const request = new wkInterceptableRequest_1.WKInterceptableRequest(session, !!this._page._state.interceptNetwork, frame, event, redirectChain, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _handleRequestRedirect(request, responsePayload) {
        const response = request.createResponse(responsePayload);
        request.request._redirectChain.push(request.request);
        response._requestFinished(new Error('Response body is unavailable for redirect responses'));
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
    }
    _onRequestIntercepted(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
            request._interceptedCallback();
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = request.createResponse(event.response);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestFinished(request.request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes('cancelled'));
    }
}
exports.WKPage = WKPage;
function toRemoteObject(handle) {
    return handle._remoteObject;
}


/***/ }),

/***/ "./src/webkit/wkPageProxy.ts":
/*!***********************************!*\
  !*** ./src/webkit/wkPageProxy.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const wkConnection_1 = __webpack_require__(/*! ./wkConnection */ "./src/webkit/wkConnection.ts");
const wkPage_1 = __webpack_require__(/*! ./wkPage */ "./src/webkit/wkPage.ts");
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const events_1 = __webpack_require__(/*! ../events */ "./src/events.ts");
const isPovisionalSymbol = Symbol('isPovisional');
class WKPageProxy {
    constructor(pageProxySession, browserContext, openerResolver) {
        this._pagePromise = null;
        this._wkPage = null;
        this._pagePausedOnStart = false;
        this._sessions = new Map();
        this._pageProxySession = pageProxySession;
        this._browserContext = browserContext;
        this._openerResolver = openerResolver;
        this._firstTargetPromise = new Promise(r => this._firstTargetCallback = r);
        this._eventListeners = [
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetCreated', this._onTargetCreated.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.dispatchMessageFromTarget', this._onDispatchMessageFromTarget.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.didCommitProvisionalTarget', this._onDidCommitProvisionalTarget.bind(this)),
        ];
    }
    didClose() {
        if (this._wkPage)
            this._wkPage.didClose(false);
    }
    dispose() {
        this._pageProxySession.dispose();
        helper_1.helper.removeEventListeners(this._eventListeners);
        for (const session of this._sessions.values())
            session.dispose();
        this._sessions.clear();
        if (this._wkPage)
            this._wkPage.dispose();
    }
    dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
    }
    _isProvisionalCrossProcessLoadInProgress() {
        for (const anySession of this._sessions.values()) {
            if (anySession[isPovisionalSymbol])
                return true;
        }
        return false;
    }
    handleProvisionalLoadFailed(event) {
        if (!this._wkPage)
            return;
        if (!this._isProvisionalCrossProcessLoadInProgress())
            return;
        let errorText = event.error;
        if (errorText.includes('cancelled'))
            errorText += '; maybe frame was detached?';
        this._wkPage._page._frameManager.provisionalLoadFailed(this._wkPage._page.mainFrame(), event.loaderId, errorText);
    }
    async page() {
        if (!this._pagePromise)
            this._pagePromise = this._initializeWKPage();
        return this._pagePromise;
    }
    existingPage() {
        return this._wkPage ? this._wkPage._page : undefined;
    }
    onPopupCreated(popupPageProxy) {
        if (this._wkPage)
            popupPageProxy.page().then(page => this._wkPage._page.emit(events_1.Events.Page.Popup, page));
    }
    async _initializeWKPage() {
        await this._firstTargetPromise;
        let session;
        for (const anySession of this._sessions.values()) {
            if (!anySession[isPovisionalSymbol]) {
                session = anySession;
                break;
            }
        }
        helper_1.assert(session, 'One non-provisional target session must exist');
        this._wkPage = new wkPage_1.WKPage(this._browserContext, this._pageProxySession, async () => {
            const pageProxy = this._openerResolver();
            if (!pageProxy)
                return null;
            return await pageProxy.page();
        });
        await this._wkPage.initialize(session);
        if (this._pagePausedOnStart) {
            this._resumeTarget(session.sessionId);
            this._pagePausedOnStart = false;
        }
        return this._wkPage._page;
    }
    _onTargetCreated(event) {
        const { targetInfo } = event;
        const session = new wkConnection_1.WKSession(this._pageProxySession.connection, targetInfo.targetId, `The ${targetInfo.type} has been closed.`, (message) => {
            this._pageProxySession.send('Target.sendMessageToTarget', {
                message: JSON.stringify(message), targetId: targetInfo.targetId
            }).catch(e => {
                session.dispatchMessage({ id: message.id, error: { message: e.message } });
            });
        });
        helper_1.assert(targetInfo.type === 'page', 'Only page targets are expected in WebKit, received: ' + targetInfo.type);
        this._sessions.set(targetInfo.targetId, session);
        if (this._firstTargetCallback) {
            this._firstTargetCallback();
            this._firstTargetCallback = undefined;
        }
        if (targetInfo.isProvisional) {
            session[isPovisionalSymbol] = true;
            if (this._wkPage) {
                const provisionalPageInitialized = this._wkPage.initializeProvisionalPage(session);
                if (targetInfo.isPaused)
                    provisionalPageInitialized.then(() => this._resumeTarget(targetInfo.targetId));
            }
            else if (targetInfo.isPaused) {
                this._resumeTarget(targetInfo.targetId);
            }
        }
        else if (this._pagePromise) {
            helper_1.assert(!this._pagePausedOnStart);
            // This is the first time page target is created, will resume
            // after finishing intialization.
            this._pagePausedOnStart = !!targetInfo.isPaused;
        }
        else if (targetInfo.isPaused) {
            this._resumeTarget(targetInfo.targetId);
        }
    }
    _resumeTarget(targetId) {
        this._pageProxySession.send('Target.resume', { targetId }).catch(helper_1.debugError);
    }
    _onTargetDestroyed(event) {
        const { targetId, crashed } = event;
        const session = this._sessions.get(targetId);
        helper_1.assert(session, 'Unknown target destroyed: ' + targetId);
        session.dispose();
        this._sessions.delete(targetId);
        if (this._wkPage)
            this._wkPage.onSessionDestroyed(session, crashed);
    }
    _onDispatchMessageFromTarget(event) {
        const { targetId, message } = event;
        const session = this._sessions.get(targetId);
        helper_1.assert(session, 'Unknown target: ' + targetId);
        session.dispatchMessage(JSON.parse(message));
    }
    _onDidCommitProvisionalTarget(event) {
        const { oldTargetId, newTargetId } = event;
        const newSession = this._sessions.get(newTargetId);
        helper_1.assert(newSession, 'Unknown new target: ' + newTargetId);
        const oldSession = this._sessions.get(oldTargetId);
        helper_1.assert(oldSession, 'Unknown old target: ' + oldTargetId);
        // TODO: make some calls like screenshot catch swapped out error and retry.
        oldSession.errorText = 'Target was swapped out.';
        newSession[isPovisionalSymbol] = undefined;
        if (this._wkPage)
            this._wkPage.onProvisionalLoadCommitted(newSession);
    }
}
exports.WKPageProxy = WKPageProxy;


/***/ }),

/***/ "./src/webkit/wkProtocolHelper.ts":
/*!****************************************!*\
  !*** ./src/webkit/wkProtocolHelper.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
function valueFromRemoteObject(remoteObject) {
    helper_1.assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.type === 'number') {
        if (remoteObject.value === null) {
            switch (remoteObject.description) {
                case 'NaN':
                    return NaN;
                case 'Infinity':
                    return Infinity;
                case '-Infinity':
                    return -Infinity;
                default:
                    throw new Error('Unsupported unserializable value: ' + remoteObject.description);
            }
        }
        else if (remoteObject.value === 0) {
            switch (remoteObject.description) {
                case '-0':
                    return -0;
            }
        }
    }
    return remoteObject.value;
}
exports.valueFromRemoteObject = valueFromRemoteObject;
async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId)
        return;
    await client.send('Runtime.releaseObject', { objectId: remoteObject.objectId }).catch(error => {
        // Exceptions might happen in case of a page been navigated or closed.
        // Swallow these since they are harmless and we don't leak anything in this case.
        helper_1.debugError(error);
    });
}
exports.releaseObject = releaseObject;


/***/ }),

/***/ "./src/webkit/wkProvisionalPage.ts":
/*!*****************************************!*\
  !*** ./src/webkit/wkProvisionalPage.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
class WKProvisionalPage {
    constructor(session, page) {
        this._sessionListeners = [];
        this._mainFrameId = null;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
            return (payload) => {
                // Pretend that the events happened in the same process.
                if (payload.frameId)
                    payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
                handler(payload);
            };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [
            helper_1.helper.addEventListener(session, 'Network.requestWillBeSent', overrideFrameId(e => wkPage._onRequestWillBeSent(session, e))),
            helper_1.helper.addEventListener(session, 'Network.requestIntercepted', overrideFrameId(e => wkPage._onRequestIntercepted(e))),
            helper_1.helper.addEventListener(session, 'Network.responseReceived', overrideFrameId(e => wkPage._onResponseReceived(e))),
            helper_1.helper.addEventListener(session, 'Network.loadingFinished', overrideFrameId(e => wkPage._onLoadingFinished(e))),
            helper_1.helper.addEventListener(session, 'Network.loadingFailed', overrideFrameId(e => wkPage._onLoadingFailed(e))),
        ];
        this.initializationPromise = this._wkPage._initializeSession(session, ({ frameTree }) => this._handleFrameTree(frameTree));
    }
    dispose() {
        helper_1.helper.removeEventListeners(this._sessionListeners);
    }
    commit() {
        helper_1.assert(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
    }
    _handleFrameTree(frameTree) {
        helper_1.assert(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
    }
}
exports.WKProvisionalPage = WKProvisionalPage;


/***/ }),

/***/ "./src/webkit/wkWorkers.ts":
/*!*********************************!*\
  !*** ./src/webkit/wkWorkers.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2019 Microsoft Corporation All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = __webpack_require__(/*! ../helper */ "./src/helper.ts");
const page_1 = __webpack_require__(/*! ../page */ "./src/page.ts");
const wkConnection_1 = __webpack_require__(/*! ./wkConnection */ "./src/webkit/wkConnection.ts");
const wkExecutionContext_1 = __webpack_require__(/*! ./wkExecutionContext */ "./src/webkit/wkExecutionContext.ts");
class WKWorkers {
    constructor(page) {
        this._sessionListeners = [];
        this._workerSessions = new Map();
        this._page = page;
    }
    setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [
            helper_1.helper.addEventListener(session, 'Worker.workerCreated', (event) => {
                const worker = new page_1.Worker(event.url);
                const workerSession = new wkConnection_1.WKSession(session.connection, event.workerId, 'Most likely the worker has been closed.', (message) => {
                    session.send('Worker.sendMessageToWorker', {
                        workerId: event.workerId,
                        message: JSON.stringify(message)
                    }).catch(e => {
                        workerSession.dispatchMessage({ id: message.id, error: { message: e.message } });
                    });
                });
                this._workerSessions.set(event.workerId, workerSession);
                worker._createExecutionContext(new wkExecutionContext_1.WKExecutionContext(workerSession, undefined));
                this._page._addWorker(event.workerId, worker);
                workerSession.on('Console.messageAdded', event => this._onConsoleMessage(worker, event));
                Promise.all([
                    workerSession.send('Runtime.enable'),
                    workerSession.send('Console.enable'),
                    session.send('Worker.initialized', { workerId: event.workerId })
                ]).catch(e => {
                    // Worker can go as we are initializing it.
                    this._page._removeWorker(event.workerId);
                });
            }),
            helper_1.helper.addEventListener(session, 'Worker.dispatchMessageFromWorker', (event) => {
                const workerSession = this._workerSessions.get(event.workerId);
                if (!workerSession)
                    return;
                workerSession.dispatchMessage(JSON.parse(event.message));
            }),
            helper_1.helper.addEventListener(session, 'Worker.workerTerminated', (event) => {
                const workerSession = this._workerSessions.get(event.workerId);
                if (!workerSession)
                    return;
                workerSession.dispose();
                this._workerSessions.delete(event.workerId);
                this._page._removeWorker(event.workerId);
            })
        ];
    }
    clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
    }
    async initializeSession(session) {
        await session.send('Worker.enable');
    }
    async _onConsoleMessage(worker, event) {
        const { type, level, text, parameters, url, line: lineNumber, column: columnNumber } = event.message;
        let derivedType = type || '';
        if (type === 'log')
            derivedType = level;
        else if (type === 'timing')
            derivedType = 'timeEnd';
        const handles = (parameters || []).map(p => {
            return worker._existingExecutionContext._createHandle(p);
        });
        this._page._addConsoleMessage(derivedType, handles, { url, lineNumber: (lineNumber || 1) - 1, columnNumber: (columnNumber || 1) - 1 }, handles.length ? undefined : text);
    }
}
exports.WKWorkers = WKWorkers;


/***/ }),

/***/ "events":
/*!************************!*\
  !*** external "dummy" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window["dummy"]; }());

/***/ })

/******/ });
//# sourceMappingURL=web.js.map