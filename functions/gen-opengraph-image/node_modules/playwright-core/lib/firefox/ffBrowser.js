"use strict";
/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("../browser");
const browserContext_1 = require("../browserContext");
const events_1 = require("../events");
const helper_1 = require("../helper");
const ffConnection_1 = require("./ffConnection");
const ffPage_1 = require("./ffPage");
const platform = require("../platform");
const transport_1 = require("../transport");
class FFBrowser extends platform.EventEmitter {
    constructor(connection) {
        super();
        this._connection = connection;
        this._targets = new Map();
        this._defaultContext = this._createBrowserContext(null, {});
        this._contexts = new Map();
        this._connection.on(ffConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this.contexts())
                context._browserClosed();
            this.emit(events_1.Events.Browser.Disconnected);
        });
        this._eventListeners = [
            helper_1.helper.addEventListener(this._connection, 'Target.targetCreated', this._onTargetCreated.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.targetInfoChanged', this._onTargetInfoChanged.bind(this)),
            helper_1.helper.addEventListener(this._connection, 'Target.attachedToTarget', this._onAttachedToTarget.bind(this)),
        ];
    }
    static async connect(transport, slowMo) {
        const connection = new ffConnection_1.FFConnection(transport_1.SlowMoTransport.wrap(transport, slowMo));
        const browser = new FFBrowser(connection);
        await connection.send('Target.enable');
        return browser;
    }
    isConnected() {
        return !this._connection._closed;
    }
    async newContext(options = {}) {
        const viewport = options.viewport ? {
            viewportSize: { width: options.viewport.width, height: options.viewport.height },
            isMobile: !!options.viewport.isMobile,
            deviceScaleFactor: options.viewport.deviceScaleFactor || 1,
            hasTouch: !!options.viewport.isMobile,
        } : undefined;
        const { browserContextId } = await this._connection.send('Target.createBrowserContext', {
            userAgent: options.userAgent,
            bypassCSP: options.bypassCSP,
            javaScriptDisabled: options.javaScriptEnabled === false ? true : undefined,
            viewport,
        });
        // TODO: move ignoreHTTPSErrors to browser context level.
        if (options.ignoreHTTPSErrors)
            await this._connection.send('Browser.setIgnoreHTTPSErrors', { enabled: true });
        const context = this._createBrowserContext(browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this._allTargets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise(x => resolve = x);
        this.on('targetchanged', check);
        try {
            if (!timeout)
                return await targetPromise;
            return await helper_1.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener('targetchanged', check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    _allTargets() {
        return Array.from(this._targets.values());
    }
    async _onTargetCreated(payload) {
        const { targetId, url, browserContextId, openerId, type } = payload;
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        const target = new Target(this._connection, this, context, targetId, type, url, openerId);
        this._targets.set(targetId, target);
    }
    _onTargetDestroyed(payload) {
        const { targetId } = payload;
        const target = this._targets.get(targetId);
        this._targets.delete(targetId);
        target._didClose();
    }
    _onTargetInfoChanged(payload) {
        const { targetId, url } = payload;
        const target = this._targets.get(targetId);
        target._url = url;
    }
    async _onAttachedToTarget(payload) {
        const { targetId } = payload.targetInfo;
        const target = this._targets.get(targetId);
        target._initPagePromise(this._connection.getSession(payload.sessionId));
        const opener = target.opener();
        if (opener && opener._pagePromise) {
            const openerPage = await opener._pagePromise;
            if (openerPage.listenerCount(events_1.Events.Page.Popup)) {
                const popupPage = await target.page();
                openerPage.emit(events_1.Events.Page.Popup, popupPage);
            }
        }
    }
    async close() {
        await Promise.all(this.contexts().map(context => context.close()));
        helper_1.helper.removeEventListeners(this._eventListeners);
        const disconnected = new Promise(f => this.once(events_1.Events.Browser.Disconnected, f));
        this._connection.close();
        await disconnected;
    }
    _createBrowserContext(browserContextId, options) {
        browserContext_1.BrowserContext.validateOptions(options);
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const targets = this._allTargets().filter(target => target.context() === context && target.type() === 'page');
                const pages = await Promise.all(targets.map(target => target.page()));
                return pages.filter(page => !!page);
            },
            existingPages: () => {
                const pages = [];
                for (const target of this._allTargets()) {
                    if (target.context() === context && target._ffPage)
                        pages.push(target._ffPage._page);
                }
                return pages;
            },
            newPage: async () => {
                const { targetId } = await this._connection.send('Target.newPage', {
                    browserContextId: browserContextId || undefined
                });
                const target = this._targets.get(targetId);
                return target.page();
            },
            close: async () => {
                helper_1.assert(browserContextId, 'Non-incognito profiles cannot be closed!');
                await this._connection.send('Target.removeBrowserContext', { browserContextId });
                this._contexts.delete(browserContextId);
            },
            cookies: async () => {
                const { cookies } = await this._connection.send('Browser.getCookies', { browserContextId: browserContextId || undefined });
                return cookies.map(c => {
                    const copy = { ...c };
                    delete copy.size;
                    return copy;
                });
            },
            clearCookies: async () => {
                await this._connection.send('Browser.clearCookies', { browserContextId: browserContextId || undefined });
            },
            setCookies: async (cookies) => {
                await this._connection.send('Browser.setCookies', { browserContextId: browserContextId || undefined, cookies });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geo'],
                    ['microphone', 'microphone'],
                    ['camera', 'camera'],
                    ['notifications', 'desktop-notifications'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._connection.send('Browser.grantPermissions', { origin, browserContextId: browserContextId || undefined, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._connection.send('Browser.resetPermissions', { browserContextId: browserContextId || undefined });
            },
            setGeolocation: async (geolocation) => {
                throw new Error('Geolocation emulation is not supported in Firefox');
            }
        }, options);
        return context;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugProtocol = debugFunction;
    }
}
exports.FFBrowser = FFBrowser;
class Target {
    constructor(connection, browser, context, targetId, type, url, openerId) {
        this._ffPage = null;
        this._browser = browser;
        this._context = context;
        this._connection = connection;
        this._targetId = targetId;
        this._type = type;
        this._url = url;
        this._openerId = openerId;
    }
    _didClose() {
        if (this._ffPage)
            this._ffPage.didClose();
    }
    opener() {
        return this._openerId ? this._browser._targets.get(this._openerId) : null;
    }
    type() {
        return this._type;
    }
    url() {
        return this._url;
    }
    context() {
        return this._context;
    }
    async page() {
        if (this._type !== 'page')
            throw new Error(`Cannot create page for "${this._type}" target`);
        if (!this._pagePromise)
            await this._connection.send('Target.attachToTarget', { targetId: this._targetId });
        return this._pagePromise;
    }
    _initPagePromise(session) {
        this._pagePromise = new Promise(async (f) => {
            this._ffPage = new ffPage_1.FFPage(session, this._context, async () => {
                const openerTarget = this.opener();
                if (!openerTarget)
                    return null;
                return await openerTarget.page();
            });
            const page = this._ffPage._page;
            session.once(ffConnection_1.FFSessionEvents.Disconnected, () => page._didDisconnect());
            await this._ffPage._initialize().catch(helper_1.debugError);
            f(page);
        });
    }
    browser() {
        return this._browser;
    }
}
//# sourceMappingURL=ffBrowser.js.map