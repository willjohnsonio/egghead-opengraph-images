/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as frames from '../frames';
import * as dom from '../dom';
import { FFSession } from './ffConnection';
import { Page, PageDelegate } from '../page';
import { FFNetworkManager } from './ffNetworkManager';
import { Protocol } from './protocol';
import { RawMouseImpl, RawKeyboardImpl } from './ffInput';
import { BrowserContext } from '../browserContext';
import * as network from '../network';
import * as types from '../types';
import * as platform from '../platform';
export declare class FFPage implements PageDelegate {
    readonly rawMouse: RawMouseImpl;
    readonly rawKeyboard: RawKeyboardImpl;
    readonly _session: FFSession;
    readonly _page: Page;
    readonly _networkManager: FFNetworkManager;
    private readonly _openerResolver;
    private readonly _contextIdToContext;
    private _eventListeners;
    private _workers;
    constructor(session: FFSession, browserContext: BrowserContext, openerResolver: () => Promise<Page | null>);
    _initialize(): Promise<void>;
    _onExecutionContextCreated(payload: Protocol.Runtime.executionContextCreatedPayload): void;
    _onExecutionContextDestroyed(payload: Protocol.Runtime.executionContextDestroyedPayload): void;
    private _removeContextsForFrame;
    _onNavigationStarted(): void;
    _onNavigationAborted(params: Protocol.Page.navigationAbortedPayload): void;
    _onNavigationCommitted(params: Protocol.Page.navigationCommittedPayload): void;
    _onSameDocumentNavigation(params: Protocol.Page.sameDocumentNavigationPayload): void;
    _onFrameAttached(params: Protocol.Page.frameAttachedPayload): void;
    _onFrameDetached(params: Protocol.Page.frameDetachedPayload): void;
    _onEventFired(payload: Protocol.Page.eventFiredPayload): void;
    _onUncaughtError(params: Protocol.Page.uncaughtErrorPayload): void;
    _onConsole(payload: Protocol.Runtime.consolePayload): void;
    _onDialogOpened(params: Protocol.Page.dialogOpenedPayload): void;
    _onBindingCalled(event: Protocol.Page.bindingCalledPayload): void;
    _onFileChooserOpened(payload: Protocol.Page.fileChooserOpenedPayload): Promise<void>;
    _onWorkerCreated(event: Protocol.Page.workerCreatedPayload): Promise<void>;
    _onWorkerDestroyed(event: Protocol.Page.workerDestroyedPayload): Promise<void>;
    _onDispatchMessageFromWorker(event: Protocol.Page.dispatchMessageFromWorkerPayload): Promise<void>;
    _onCrashed(event: Protocol.Page.crashedPayload): Promise<void>;
    exposeBinding(name: string, bindingFunction: string): Promise<void>;
    didClose(): void;
    navigateFrame(frame: frames.Frame, url: string, referer: string | undefined): Promise<frames.GotoResult>;
    setExtraHTTPHeaders(headers: network.Headers): Promise<void>;
    setViewportSize(viewportSize: types.Size): Promise<void>;
    setEmulateMedia(mediaType: types.MediaType | null, colorScheme: types.ColorScheme | null): Promise<void>;
    setCacheEnabled(enabled: boolean): Promise<void>;
    setRequestInterception(enabled: boolean): Promise<void>;
    setOfflineMode(enabled: boolean): Promise<void>;
    authenticate(credentials: types.Credentials | null): Promise<void>;
    setFileChooserIntercepted(enabled: boolean): Promise<void>;
    opener(): Promise<Page | null>;
    reload(): Promise<void>;
    goBack(): Promise<boolean>;
    goForward(): Promise<boolean>;
    evaluateOnNewDocument(source: string): Promise<void>;
    closePage(runBeforeUnload: boolean): Promise<void>;
    getBoundingBoxForScreenshot(handle: dom.ElementHandle<Node>): Promise<types.Rect | null>;
    canScreenshotOutsideViewport(): boolean;
    setBackgroundColor(color?: {
        r: number;
        g: number;
        b: number;
        a: number;
    }): Promise<void>;
    takeScreenshot(format: 'png' | 'jpeg', options: types.ScreenshotOptions, viewportSize: types.Size): Promise<platform.BufferType>;
    resetViewport(): Promise<void>;
    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;
    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;
    isElementHandle(remoteObject: any): boolean;
    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;
    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<void>;
    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;
    layoutViewport(): Promise<{
        width: number;
        height: number;
    }>;
    setInputFiles(handle: dom.ElementHandle<HTMLInputElement>, files: types.FilePayload[]): Promise<void>;
    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;
    getAccessibilityTree(needle?: dom.ElementHandle): Promise<{
        tree: import("../accessibility").AXNode;
        needle: import("../accessibility").AXNode | null;
    }>;
    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;
}
export declare function normalizeWaitUntil(waitUntil: frames.LifecycleEvent | frames.LifecycleEvent[]): frames.LifecycleEvent[];
