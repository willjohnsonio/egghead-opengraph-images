"use strict";
/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("../helper");
const dom = require("../dom");
const ffConnection_1 = require("./ffConnection");
const ffExecutionContext_1 = require("./ffExecutionContext");
const page_1 = require("../page");
const ffNetworkManager_1 = require("./ffNetworkManager");
const events_1 = require("../events");
const dialog = require("../dialog");
const ffInput_1 = require("./ffInput");
const ffAccessibility_1 = require("./ffAccessibility");
const platform = require("../platform");
const screenshotter_1 = require("../screenshotter");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
class FFPage {
    constructor(session, browserContext, openerResolver) {
        this._workers = new Map();
        this._session = session;
        this._openerResolver = openerResolver;
        this.rawKeyboard = new ffInput_1.RawKeyboardImpl(session);
        this.rawMouse = new ffInput_1.RawMouseImpl(session);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new ffNetworkManager_1.FFNetworkManager(session, this._page);
        this._page.on(events_1.Events.Page.FrameDetached, frame => this._removeContextsForFrame(frame));
        this._eventListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.eventFired', this._onEventFired.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', this._onFrameAttached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', this._onFrameDetached.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationAborted', this._onNavigationAborted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationCommitted', this._onNavigationCommitted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.navigationStarted', this._onNavigationStarted.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.sameDocumentNavigation', this._onSameDocumentNavigation.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', this._onExecutionContextCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextDestroyed', this._onExecutionContextDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.uncaughtError', this._onUncaughtError.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Runtime.console', this._onConsole.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dialogOpened', this._onDialogOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.bindingCalled', this._onBindingCalled.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', this._onFileChooserOpened.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerCreated', this._onWorkerCreated.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.workerDestroyed', this._onWorkerDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.dispatchMessageFromWorker', this._onDispatchMessageFromWorker.bind(this)),
            helper_1.helper.addEventListener(this._session, 'Page.crashed', this._onCrashed.bind(this)),
        ];
    }
    async _initialize() {
        await Promise.all([
            this._session.send('Page.addScriptToEvaluateOnNewDocument', {
                script: '',
                worldName: UTILITY_WORLD_NAME,
            }),
            new Promise(f => this._session.once('Page.ready', f)),
        ]);
    }
    _onExecutionContextCreated(payload) {
        const { executionContextId, auxData } = payload;
        const frame = this._page._frameManager.frame(auxData ? auxData.frameId : null);
        if (!frame)
            return;
        const delegate = new ffExecutionContext_1.FFExecutionContext(this._session, executionContextId);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (auxData.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        else if (!auxData.name)
            frame._contextCreated('main', context);
        this._contextIdToContext.set(executionContextId, context);
    }
    _onExecutionContextDestroyed(payload) {
        const { executionContextId } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame)
                this._contextIdToContext.delete(contextId);
        }
    }
    _onNavigationStarted() {
    }
    _onNavigationAborted(params) {
        const frame = this._page._frameManager.frame(params.frameId);
        for (const watcher of frame._documentWatchers)
            watcher(params.navigationId, new Error(params.errorText));
    }
    _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
            if (worker.frameId === params.frameId)
                this._onWorkerDestroyed({ workerId });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || '', params.navigationId || '', false);
    }
    _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
    }
    _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
    }
    _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
    }
    _onEventFired(payload) {
        const { frameId, name } = payload;
        if (name === 'load')
            this._page._frameManager.frameLifecycleEvent(frameId, 'load');
        if (name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(frameId, 'domcontentloaded');
    }
    _onUncaughtError(params) {
        const error = new Error(params.message);
        error.stack = params.stack;
        this._page.emit(events_1.Events.Page.PageError, error);
    }
    _onConsole(payload) {
        const { type, args, executionContextId, location } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        this._page._addConsoleMessage(type, args.map(arg => context._createHandle(arg)), location);
    }
    _onDialogOpened(params) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(params.type, params.message, async (accept, promptText) => {
            await this._session.send('Page.handleDialog', { dialogId: params.dialogId, accept, promptText }).catch(helper_1.debugError);
        }, params.defaultValue));
    }
    _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        this._page._onBindingCalled(event.payload, context);
    }
    async _onFileChooserOpened(payload) {
        const { executionContextId, element } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        const handle = context._createHandle(element).asElement();
        this._page._onFileChooserOpened(handle);
    }
    async _onWorkerCreated(event) {
        const workerId = event.workerId;
        const worker = new page_1.Worker(event.url);
        const workerSession = new ffConnection_1.FFSession(this._session._connection, 'worker', workerId, (message) => {
            this._session.send('Page.sendMessageToWorker', {
                frameId: event.frameId,
                workerId: workerId,
                message: JSON.stringify(message)
            }).catch(e => {
                workerSession.dispatchMessage({ id: message.id, method: '', params: {}, error: { message: e.message, data: undefined } });
            });
        });
        this._workers.set(workerId, { session: workerSession, frameId: event.frameId });
        this._page._addWorker(workerId, worker);
        workerSession.once('Runtime.executionContextCreated', event => {
            worker._createExecutionContext(new ffExecutionContext_1.FFExecutionContext(workerSession, event.executionContextId));
        });
        workerSession.on('Runtime.console', event => {
            const { type, args, location } = event;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map(arg => context._createHandle(arg)), location);
        });
        // Note: we receive worker exceptions directly from the page.
    }
    async _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
            return;
        worker.session._onClosed();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
    }
    async _onDispatchMessageFromWorker(event) {
        const worker = this._workers.get(event.workerId);
        if (!worker)
            return;
        worker.session.dispatchMessage(JSON.parse(event.message));
    }
    async _onCrashed(event) {
        this._page._didCrash();
    }
    async exposeBinding(name, bindingFunction) {
        await this._session.send('Page.addBinding', { name: name });
        await this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: bindingFunction });
        await Promise.all(this._page.frames().map(frame => frame.evaluate(bindingFunction).catch(helper_1.debugError)));
    }
    didClose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referer) {
        const response = await this._session.send('Page.navigate', { url, referer, frameId: frame._id });
        return { newDocumentId: response.navigationId || undefined };
    }
    async setExtraHTTPHeaders(headers) {
        const array = [];
        for (const [name, value] of Object.entries(headers))
            array.push({ name, value });
        await this._session.send('Network.setExtraHTTPHeaders', { headers: array });
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._session.send('Page.setViewportSize', {
            viewportSize: {
                width: viewportSize.width,
                height: viewportSize.height,
            },
        });
    }
    async setEmulateMedia(mediaType, colorScheme) {
        await this._session.send('Page.setEmulatedMedia', {
            type: mediaType === null ? undefined : mediaType,
            colorScheme: colorScheme === null ? undefined : colorScheme
        });
    }
    async setCacheEnabled(enabled) {
        await this._session.send('Page.setCacheDisabled', { cacheDisabled: !enabled });
    }
    async setRequestInterception(enabled) {
        await this._networkManager.setRequestInterception(enabled);
    }
    async setOfflineMode(enabled) {
        throw new Error('Offline mode not implemented in Firefox');
    }
    async authenticate(credentials) {
        await this._session.send('Network.setAuthCredentials', credentials || { username: null, password: null });
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        return await this._openerResolver();
    }
    async reload() {
        await this._session.send('Page.reload', { frameId: this._page.mainFrame()._id });
    }
    async goBack() {
        const { navigationId } = await this._session.send('Page.goBack', { frameId: this._page.mainFrame()._id });
        return navigationId !== null;
    }
    async goForward() {
        const { navigationId } = await this._session.send('Page.goForward', { frameId: this._page.mainFrame()._id });
        return navigationId !== null;
    }
    async evaluateOnNewDocument(source) {
        await this._session.send('Page.addScriptToEvaluateOnNewDocument', { script: source });
    }
    async closePage(runBeforeUnload) {
        await this._session.send('Page.close', { runBeforeUnload });
    }
    async getBoundingBoxForScreenshot(handle) {
        const frameId = handle._context.frame._id;
        const response = await this._session.send('Page.getBoundingBox', {
            frameId,
            objectId: handle._remoteObject.objectId,
        });
        return response.boundingBox;
    }
    canScreenshotOutsideViewport() {
        return true;
    }
    async setBackgroundColor(color) {
        if (color)
            throw new Error('Not implemented');
    }
    async takeScreenshot(format, options, viewportSize) {
        const { data } = await this._session.send('Page.screenshot', {
            mimeType: ('image/' + format),
            fullPage: options.fullPage,
            clip: options.clip,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('document.documentElement is null'))
                e.message = screenshotter_1.kScreenshotDuringNavigationError;
            throw e;
        });
        return platform.Buffer.from(data, 'base64');
    }
    async resetViewport() {
        await this._session.send('Page.setViewportSize', { viewportSize: null });
    }
    async getContentFrame(handle) {
        const { contentFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        });
        if (!contentFrameId)
            return null;
        return this._page._frameManager.frame(contentFrameId);
    }
    async getOwnerFrame(handle) {
        const { ownerFrameId } = await this._session.send('Page.describeNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        });
        return ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._session.send('Page.scrollIntoViewIfNeeded', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
            rect,
        });
    }
    async getContentQuads(handle) {
        const result = await this._session.send('Page.getContentQuads', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [quad.p1, quad.p2, quad.p3, quad.p4]);
    }
    async layoutViewport() {
        return this._page.evaluate(() => ({ width: innerWidth, height: innerHeight }));
    }
    async setInputFiles(handle, files) {
        await handle.evaluate(dom.setFileInputFunction, files);
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.send('Page.adoptNode', {
            frameId: handle._context.frame._id,
            objectId: toRemoteObject(handle).objectId,
            executionContextId: to._delegate._executionContextId
        });
        if (!result.remoteObject)
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.remoteObject);
    }
    async getAccessibilityTree(needle) {
        return ffAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const context = await parent._utilityContext();
        const handles = await context._$$('iframe');
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        await Promise.all(items.map(item => item === result ? Promise.resolve() : item.handle.dispose()));
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
}
exports.FFPage = FFPage;
function normalizeWaitUntil(waitUntil) {
    if (!Array.isArray(waitUntil))
        waitUntil = [waitUntil];
    for (const condition of waitUntil) {
        if (condition !== 'load' && condition !== 'domcontentloaded')
            throw new Error('Unknown waitUntil condition: ' + condition);
    }
    return waitUntil;
}
exports.normalizeWaitUntil = normalizeWaitUntil;
function toRemoteObject(handle) {
    return handle._remoteObject;
}
//# sourceMappingURL=ffPage.js.map