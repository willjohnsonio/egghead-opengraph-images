/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as platform from '../platform';
import { ConnectionTransport } from '../transport';
import { Protocol } from './protocol';
export declare const ConnectionEvents: {
    Disconnected: symbol;
};
export declare const kBrowserCloseMessageId = -9999;
export declare class FFConnection extends platform.EventEmitter {
    private _lastId;
    private _callbacks;
    private _transport;
    private _sessions;
    _debugProtocol: (message: string) => void;
    _closed: boolean;
    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    constructor(transport: ConnectionTransport);
    static fromSession(session: FFSession): FFConnection;
    session(sessionId: string): FFSession | null;
    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;
    nextMessageId(): number;
    _rawSend(message: any): void;
    _onMessage(message: string): Promise<void>;
    _onClose(): void;
    close(): void;
    getSession(sessionId: string): FFSession | null;
}
export declare const FFSessionEvents: {
    Disconnected: symbol;
};
export declare class FFSession extends platform.EventEmitter {
    _connection: FFConnection;
    _disposed: boolean;
    private _callbacks;
    private _targetType;
    private _sessionId;
    private _rawSend;
    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    constructor(connection: FFConnection, targetType: string, sessionId: string, rawSend: (message: any) => void);
    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;
    dispatchMessage(object: {
        id?: number;
        method: string;
        params: object;
        error: {
            message: string;
            data: any;
        };
        result?: any;
    }): void;
    _onClosed(): void;
}
