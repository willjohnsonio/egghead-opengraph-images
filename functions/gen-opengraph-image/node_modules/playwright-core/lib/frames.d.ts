/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import * as types from './types';
import * as js from './javascript';
import * as dom from './dom';
import * as network from './network';
import { ClickOptions, MultiClickOptions, PointerActionOptions } from './input';
import { Page } from './page';
import { ConsoleMessage } from './console';
declare type ContextType = 'main' | 'utility';
export declare type NavigateOptions = {
    timeout?: number;
    waitUntil?: LifecycleEvent | LifecycleEvent[];
};
export declare type WaitForNavigationOptions = NavigateOptions & {
    url?: types.URLMatch;
};
export declare type GotoOptions = NavigateOptions & {
    referer?: string;
};
export declare type GotoResult = {
    newDocumentId?: string;
};
export declare type LifecycleEvent = 'load' | 'domcontentloaded' | 'networkidle0' | 'networkidle2';
export declare type WaitForOptions = types.TimeoutOptions & {
    waitFor?: types.Visibility | 'nowait';
};
declare type ConsoleTagHandler = () => void;
export declare class FrameManager {
    private _page;
    private _frames;
    private _mainFrame;
    readonly _lifecycleWatchers: Set<() => void>;
    readonly _consoleMessageTags: Map<string, ConsoleTagHandler>;
    constructor(page: Page);
    mainFrame(): Frame;
    frames(): Frame[];
    frame(frameId: string): Frame | null;
    frameAttached(frameId: string, parentFrameId: string | null | undefined): Frame;
    frameCommittedNewDocumentNavigation(frameId: string, url: string, name: string, documentId: string, initial: boolean): void;
    frameCommittedSameDocumentNavigation(frameId: string, url: string): void;
    frameDetached(frameId: string): void;
    frameStoppedLoading(frameId: string): void;
    frameLifecycleEvent(frameId: string, event: LifecycleEvent): void;
    clearFrameLifecycle(frame: Frame): void;
    requestStarted(request: network.Request): void;
    requestReceivedResponse(response: network.Response): void;
    requestFinished(request: network.Request): void;
    requestFailed(request: network.Request, canceled: boolean): void;
    provisionalLoadFailed(frame: Frame, documentId: string, error: string): void;
    private _removeFramesRecursively;
    private _inflightRequestFinished;
    private _inflightRequestStarted;
    private _startNetworkIdleTimer;
    private _stopNetworkIdleTimer;
    interceptConsoleMessage(message: ConsoleMessage): boolean;
}
export declare class Frame {
    _id: string;
    readonly _firedLifecycleEvents: Set<LifecycleEvent>;
    _lastDocumentId: string;
    _requestWatchers: Set<(request: network.Request) => void>;
    _documentWatchers: Set<(documentId: string, error?: Error | undefined) => void>;
    _sameDocumentNavigationWatchers: Set<() => void>;
    readonly _page: Page;
    private _parentFrame;
    _url: string;
    private _detached;
    private _contextData;
    private _childFrames;
    _name: string;
    _inflightRequests: Set<network.Request>;
    readonly _networkIdleTimers: Map<LifecycleEvent, NodeJS.Timer>;
    private _setContentCounter;
    private _detachedPromise;
    private _detachedCallback;
    constructor(page: Page, id: string, parentFrame: Frame | null);
    goto(url: string, options?: GotoOptions): Promise<network.Response | null>;
    waitForNavigation(options?: WaitForNavigationOptions): Promise<network.Response | null>;
    waitForLoadState(options?: NavigateOptions): Promise<void>;
    _waitForSpecificDocument(expectedDocumentId: string): Disposable<Promise<Error | void>>;
    _waitForNewDocument(url?: types.URLMatch): Disposable<Promise<{
        error?: Error;
        documentId: string;
    }>>;
    _waitForSameDocumentNavigation(url?: types.URLMatch): Disposable<Promise<void>>;
    _waitForLifecycle(waitUntil?: LifecycleEvent | LifecycleEvent[]): Disposable<Promise<void>>;
    _trackDocumentRequests(): Disposable<Map<string, network.Request>>;
    _createFrameDestroyedPromise(): Promise<Error>;
    frameElement(): Promise<dom.ElementHandle>;
    _context(contextType: ContextType): Promise<dom.FrameExecutionContext>;
    _mainContext(): Promise<dom.FrameExecutionContext>;
    _utilityContext(): Promise<dom.FrameExecutionContext>;
    evaluateHandle: types.EvaluateHandle;
    evaluate: types.Evaluate;
    $(selector: string): Promise<dom.ElementHandle<Element> | null>;
    waitForSelector(selector: string, options?: types.TimeoutOptions & {
        visibility?: types.Visibility;
    }): Promise<dom.ElementHandle<Element> | null>;
    $wait(selector: string, options?: types.TimeoutOptions & {
        visibility?: types.Visibility;
    }): Promise<dom.ElementHandle<Element> | null>;
    $eval: types.$Eval;
    $$eval: types.$$Eval;
    $$(selector: string): Promise<dom.ElementHandle<Element>[]>;
    content(): Promise<string>;
    setContent(html: string, options?: NavigateOptions): Promise<void>;
    name(): string;
    url(): string;
    parentFrame(): Frame | null;
    childFrames(): Frame[];
    isDetached(): boolean;
    addScriptTag(options: {
        url?: string;
        path?: string;
        content?: string;
        type?: string;
    }): Promise<dom.ElementHandle>;
    addStyleTag(options: {
        url?: string;
        path?: string;
        content?: string;
    }): Promise<dom.ElementHandle>;
    private _raceWithCSPError;
    click(selector: string, options?: WaitForOptions & ClickOptions): Promise<void>;
    dblclick(selector: string, options?: WaitForOptions & MultiClickOptions): Promise<void>;
    tripleclick(selector: string, options?: WaitForOptions & MultiClickOptions): Promise<void>;
    fill(selector: string, value: string, options?: WaitForOptions): Promise<void>;
    focus(selector: string, options?: WaitForOptions): Promise<void>;
    hover(selector: string, options?: WaitForOptions & PointerActionOptions): Promise<void>;
    select(selector: string, value: string | dom.ElementHandle | types.SelectOption | string[] | dom.ElementHandle[] | types.SelectOption[] | undefined, options?: WaitForOptions): Promise<string[]>;
    type(selector: string, text: string, options?: WaitForOptions & {
        delay?: number;
    }): Promise<void>;
    check(selector: string, options?: WaitForOptions): Promise<void>;
    uncheck(selector: string, options?: WaitForOptions): Promise<void>;
    waitFor(selectorOrFunctionOrTimeout: (string | number | Function), options?: types.WaitForFunctionOptions & {
        visibility?: types.Visibility;
    }, ...args: any[]): Promise<js.JSHandle | null>;
    private _optionallyWaitForSelectorInUtilityContext;
    private _waitForSelectorInUtilityContext;
    waitForFunction(pageFunction: Function | string, options?: types.WaitForFunctionOptions, ...args: any[]): Promise<js.JSHandle>;
    title(): Promise<string>;
    _onDetached(): void;
    private _scheduleRerunnableTask;
    private _setContext;
    _contextCreated(contextType: ContextType, context: dom.FrameExecutionContext): void;
    _contextDestroyed(context: dom.FrameExecutionContext): void;
}
declare type Disposable<T> = {
    value: T;
    dispose: () => void;
};
export {};
