/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as frames from './frames';
import * as input from './input';
import * as js from './javascript';
import * as types from './types';
import { Page } from './page';
import * as platform from './platform';
export declare class FrameExecutionContext extends js.ExecutionContext {
    readonly frame: frames.Frame;
    private _injectedPromise?;
    private _injectedGeneration;
    constructor(delegate: js.ExecutionContextDelegate, frame: frames.Frame);
    _evaluate(returnByValue: boolean, pageFunction: string | Function, ...args: any[]): Promise<any>;
    _createHandle(remoteObject: any): js.JSHandle;
    _injected(): Promise<js.JSHandle>;
    _$(selector: string, scope?: ElementHandle): Promise<ElementHandle<Element> | null>;
    _$array(selector: string, scope?: ElementHandle): Promise<js.JSHandle<Element[]>>;
    _$$(selector: string, scope?: ElementHandle): Promise<ElementHandle<Element>[]>;
}
export declare class ElementHandle<T extends Node = Node> extends js.JSHandle<T> {
    readonly _context: FrameExecutionContext;
    readonly _page: Page;
    constructor(context: FrameExecutionContext, remoteObject: any);
    asElement(): ElementHandle<T> | null;
    _evaluateInUtility: types.EvaluateOn<T>;
    ownerFrame(): Promise<frames.Frame | null>;
    contentFrame(): Promise<frames.Frame | null>;
    _scrollRectIntoViewIfNeeded(rect?: types.Rect): Promise<void>;
    scrollIntoViewIfNeeded(): Promise<void>;
    private _clickablePoint;
    private _relativePoint;
    _performPointerAction(action: (point: types.Point) => Promise<void>, options?: input.PointerActionOptions): Promise<void>;
    hover(options?: input.PointerActionOptions): Promise<void>;
    click(options?: input.ClickOptions): Promise<void>;
    dblclick(options?: input.MultiClickOptions): Promise<void>;
    tripleclick(options?: input.MultiClickOptions): Promise<void>;
    select(...values: (string | ElementHandle | types.SelectOption)[]): Promise<string[]>;
    fill(value: string): Promise<void>;
    setInputFiles(...files: (string | types.FilePayload)[]): Promise<void>;
    focus(): Promise<void>;
    type(text: string, options?: {
        delay?: number;
    }): Promise<void>;
    press(key: string, options: {
        delay?: number;
        text?: string;
    } | undefined): Promise<void>;
    check(): Promise<void>;
    uncheck(): Promise<void>;
    private _setChecked;
    boundingBox(): Promise<types.Rect | null>;
    screenshot(options?: types.ElementScreenshotOptions): Promise<string | platform.BufferType>;
    $(selector: string): Promise<ElementHandle | null>;
    $$(selector: string): Promise<ElementHandle<Element>[]>;
    $eval: types.$Eval;
    $$eval: types.$$Eval;
    visibleRatio(): Promise<number>;
}
export declare type Task = (context: FrameExecutionContext) => Promise<js.JSHandle>;
export declare function waitForFunctionTask(selector: string | undefined, pageFunction: Function | string, options: types.WaitForFunctionOptions, ...args: any[]): (context: FrameExecutionContext) => Promise<ElementHandle<any> | js.JSHandle<any>>;
export declare function waitForSelectorTask(selector: string, visibility: types.Visibility, timeout: number): Task;
export declare const setFileInputFunction: (element: HTMLInputElement, payloads: types.FilePayload[]) => Promise<void>;
