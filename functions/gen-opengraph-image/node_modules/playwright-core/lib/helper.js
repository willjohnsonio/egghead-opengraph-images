"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const platform = require("./platform");
exports.debugError = platform.debug(`pw:error`);
class Helper {
    static evaluationString(fun, ...args) {
        if (Helper.isString(fun)) {
            assert(args.length === 0, 'Cannot evaluate a string with arguments');
            return fun;
        }
        return `(${fun})(${args.map(serializeArgument).join(',')})`;
        function serializeArgument(arg) {
            if (Object.is(arg, undefined))
                return 'undefined';
            return JSON.stringify(arg);
        }
    }
    static installApiHooks(className, classType) {
        const log = platform.debug('pw:api');
        for (const methodName of Reflect.ownKeys(classType.prototype)) {
            const method = Reflect.get(classType.prototype, methodName);
            if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function')
                continue;
            const isAsync = method.constructor.name === 'AsyncFunction';
            if (!isAsync && !log.enabled)
                continue;
            Reflect.set(classType.prototype, methodName, function (...args) {
                if (log.enabled) {
                    if (args.length)
                        log(`${className}.${methodName} %o`, args);
                    else
                        log(`${className}.${methodName}`);
                }
                if (!isAsync)
                    return method.call(this, ...args);
                const syncStack = {};
                Error.captureStackTrace(syncStack);
                return method.call(this, ...args).catch((e) => {
                    const stack = syncStack.stack.substring(syncStack.stack.indexOf('\n') + 1);
                    const clientStack = stack.substring(stack.indexOf('\n'));
                    if (e instanceof Error && e.stack && !e.stack.includes(clientStack))
                        e.stack += '\n  -- ASYNC --\n' + stack;
                    throw e;
                });
            });
        }
    }
    static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return { emitter, eventName, handler };
    }
    static removeEventListeners(listeners) {
        for (const listener of listeners)
            listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
    }
    static isString(obj) {
        return typeof obj === 'string' || obj instanceof String;
    }
    static isNumber(obj) {
        return typeof obj === 'number' || obj instanceof Number;
    }
    static async waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
        let eventTimeout;
        let resolveCallback = () => { };
        let rejectCallback = () => { };
        const promise = new Promise((resolve, reject) => {
            resolveCallback = resolve;
            rejectCallback = reject;
        });
        const listener = Helper.addEventListener(emitter, eventName, event => {
            try {
                if (!predicate(event))
                    return;
                resolveCallback(event);
            }
            catch (e) {
                rejectCallback(e);
            }
        });
        if (timeout) {
            eventTimeout = setTimeout(() => {
                rejectCallback(new errors_1.TimeoutError(`Timeout exceeded while waiting for ${String(eventName)}`));
            }, timeout);
        }
        function cleanup() {
            Helper.removeEventListeners([listener]);
            clearTimeout(eventTimeout);
        }
        const result = await Promise.race([promise, abortPromise]).then(r => {
            cleanup();
            return r;
        }, e => {
            cleanup();
            throw e;
        });
        if (result instanceof Error)
            throw result;
        return result;
    }
    static async waitWithTimeout(promise, taskName, timeout) {
        let reject;
        const timeoutError = new errors_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
        const timeoutPromise = new Promise((resolve, x) => reject = x);
        let timeoutTimer = null;
        if (timeout)
            timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
        try {
            return await Promise.race([promise, timeoutPromise]);
        }
        finally {
            if (timeoutTimer)
                clearTimeout(timeoutTimer);
        }
    }
    static globToRegex(glob) {
        const tokens = ['^'];
        let inGroup;
        for (let i = 0; i < glob.length; ++i) {
            const c = glob[i];
            if (escapeGlobChars.has(c)) {
                tokens.push('\\' + c);
                continue;
            }
            if (c === '*') {
                const beforeDeep = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === '*') {
                    starCount++;
                    i++;
                }
                const afterDeep = glob[i + 1];
                const isDeep = starCount > 1 &&
                    (beforeDeep === '/' || beforeDeep === undefined) &&
                    (afterDeep === '/' || afterDeep === undefined);
                if (isDeep) {
                    tokens.push('((?:[^/]*(?:\/|$))*)');
                    i++;
                }
                else {
                    tokens.push('([^/]*)');
                }
                continue;
            }
            switch (c) {
                case '?':
                    tokens.push('.');
                    break;
                case '{':
                    inGroup = true;
                    tokens.push('(');
                    break;
                case '}':
                    inGroup = false;
                    tokens.push(')');
                    break;
                case ',':
                    if (inGroup) {
                        tokens.push('|');
                        break;
                    }
                    tokens.push('\\' + c);
                    break;
                default:
                    tokens.push(c);
            }
        }
        tokens.push('$');
        return new RegExp(tokens.join(''));
    }
    static completeUserURL(urlString) {
        if (urlString.startsWith('localhost') || urlString.startsWith('127.0.0.1'))
            urlString = 'http://' + urlString;
        return urlString;
    }
}
function assert(value, message) {
    if (!value)
        throw new Error(message);
}
exports.assert = assert;
const escapeGlobChars = new Set(['/', '$', '^', '+', '.', '(', ')', '=', '!', '|']);
exports.helper = Helper;
//# sourceMappingURL=helper.js.map