"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const wkConnection_1 = require("./wkConnection");
const helper_1 = require("../helper");
const wkProtocolHelper_1 = require("./wkProtocolHelper");
const js = require("../javascript");
exports.EVALUATION_SCRIPT_URL = '__playwright_evaluation_script__';
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
class WKExecutionContext {
    constructor(session, contextId) {
        this._contextDestroyedCallback = () => { };
        this._session = session;
        this._contextId = contextId;
        this._executionContextDestroyedPromise = new Promise((resolve, reject) => {
            this._contextDestroyedCallback = resolve;
        });
    }
    _dispose() {
        this._contextDestroyedCallback();
    }
    async evaluate(context, returnByValue, pageFunction, ...args) {
        try {
            let response = await this._evaluateRemoteObject(pageFunction, args);
            if (response.result.type === 'object' && response.result.className === 'Promise') {
                response = await Promise.race([
                    this._executionContextDestroyedPromise.then(() => contextDestroyedResult),
                    this._session.send('Runtime.awaitPromise', {
                        promiseObjectId: response.result.objectId,
                        returnByValue: false
                    })
                ]);
            }
            if (response.wasThrown)
                throw new Error('Evaluation failed: ' + response.result.description);
            if (!returnByValue)
                return context._createHandle(response.result);
            if (response.result.objectId)
                return await this._returnObjectByValue(response.result.objectId);
            return wkProtocolHelper_1.valueFromRemoteObject(response.result);
        }
        catch (error) {
            if (wkConnection_1.isSwappedOutError(error) || error.message.includes('Missing injected script for given'))
                throw new Error('Execution context was destroyed, most likely because of a navigation.');
            throw error;
        }
    }
    async _evaluateRemoteObject(pageFunction, args) {
        if (helper_1.helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + '\n' + suffix;
            return await this._session.send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue: false,
                emulateUserGesture: true
            });
        }
        if (typeof pageFunction !== 'function')
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        try {
            const callParams = this._serializeFunctionAndArguments(pageFunction, args);
            const thisObjectId = await this._contextGlobalObjectId();
            return await this._session.send('Runtime.callFunctionOn', {
                functionDeclaration: callParams.functionText + '\n' + suffix + '\n',
                objectId: thisObjectId,
                arguments: callParams.callArguments,
                returnByValue: false,
                emulateUserGesture: true
            });
        }
        catch (err) {
            if (err instanceof TypeError && err.message.startsWith('Converting circular structure to JSON'))
                err.message += ' Are you passing a nested JSHandle?';
            throw err;
        }
    }
    _serializeFunctionAndArguments(pageFunction, args) {
        let functionText = pageFunction.toString();
        try {
            new Function('(' + functionText + ')');
        }
        catch (e1) {
            // This means we might have a function shorthand. Try another
            // time prefixing 'function '.
            if (functionText.startsWith('async '))
                functionText = 'async function ' + functionText.substring('async '.length);
            else
                functionText = 'function ' + functionText;
            try {
                new Function('(' + functionText + ')');
            }
            catch (e2) {
                // We tried hard to serialize, but there's a weird beast here.
                throw new Error('Passed function is not well-serializable!');
            }
        }
        let serializableArgs;
        if (args.some(isUnserializable)) {
            serializableArgs = [];
            const paramStrings = [];
            for (const arg of args) {
                if (isUnserializable(arg)) {
                    paramStrings.push(unserializableToString(arg));
                }
                else {
                    paramStrings.push('arguments[' + serializableArgs.length + ']');
                    serializableArgs.push(arg);
                }
            }
            functionText = `() => (${functionText})(${paramStrings.join(',')})`;
        }
        else {
            serializableArgs = args;
        }
        const serialized = serializableArgs.map((arg) => this._convertArgument(arg));
        return { functionText, callArguments: serialized };
        function unserializableToString(arg) {
            if (Object.is(arg, -0))
                return '-0';
            if (Object.is(arg, Infinity))
                return 'Infinity';
            if (Object.is(arg, -Infinity))
                return '-Infinity';
            if (Object.is(arg, NaN))
                return 'NaN';
            if (arg instanceof js.JSHandle) {
                const remoteObj = toRemoteObject(arg);
                if (!remoteObj.objectId)
                    return wkProtocolHelper_1.valueFromRemoteObject(remoteObj);
            }
            throw new Error('Unsupported value: ' + arg + ' (' + (typeof arg) + ')');
        }
        function isUnserializable(arg) {
            if (typeof arg === 'bigint')
                return true;
            if (Object.is(arg, -0))
                return true;
            if (Object.is(arg, Infinity))
                return true;
            if (Object.is(arg, -Infinity))
                return true;
            if (Object.is(arg, NaN))
                return true;
            if (arg instanceof js.JSHandle) {
                const remoteObj = toRemoteObject(arg);
                if (!remoteObj.objectId)
                    return !Object.is(wkProtocolHelper_1.valueFromRemoteObject(remoteObj), remoteObj.value);
            }
            return false;
        }
    }
    _contextGlobalObjectId() {
        if (!this._globalObjectIdPromise) {
            this._globalObjectIdPromise = this._session.send('Runtime.evaluate', {
                expression: 'this',
                contextId: this._contextId
            }).then(response => {
                return response.result.objectId;
            });
        }
        return this._globalObjectIdPromise;
    }
    async _returnObjectByValue(objectId) {
        try {
            const serializeResponse = await this._session.send('Runtime.callFunctionOn', {
                // Serialize object using standard JSON implementation to correctly pass 'undefined'.
                functionDeclaration: 'function(){return this}\n' + suffix + '\n',
                objectId: objectId,
                returnByValue: true
            });
            if (serializeResponse.wasThrown)
                return undefined;
            return serializeResponse.result.value;
        }
        catch (e) {
            if (wkConnection_1.isSwappedOutError(e))
                return contextDestroyedResult;
            return undefined;
        }
    }
    async getProperties(handle) {
        const objectId = toRemoteObject(handle).objectId;
        if (!objectId)
            return new Map();
        const response = await this._session.send('Runtime.getProperties', {
            objectId,
            ownProperties: true
        });
        const result = new Map();
        for (const property of response.properties) {
            if (!property.enumerable)
                continue;
            result.set(property.name, handle._context._createHandle(property.value));
        }
        return result;
    }
    async releaseHandle(handle) {
        await wkProtocolHelper_1.releaseObject(this._session, toRemoteObject(handle));
    }
    async handleJSONValue(handle) {
        const remoteObject = toRemoteObject(handle);
        if (remoteObject.objectId) {
            const response = await this._session.send('Runtime.callFunctionOn', {
                functionDeclaration: 'function() { return this; }',
                objectId: remoteObject.objectId,
                returnByValue: true
            });
            return wkProtocolHelper_1.valueFromRemoteObject(response.result);
        }
        return wkProtocolHelper_1.valueFromRemoteObject(remoteObject);
    }
    handleToString(handle, includeType) {
        const object = toRemoteObject(handle);
        if (object.objectId) {
            let type = object.subtype || object.type;
            // FIXME: promise doesn't have special subtype in WebKit.
            if (object.className === 'Promise')
                type = 'promise';
            return 'JSHandle@' + type;
        }
        return (includeType ? 'JSHandle:' : '') + wkProtocolHelper_1.valueFromRemoteObject(object);
    }
    _convertArgument(arg) {
        const objectHandle = arg && (arg instanceof js.JSHandle) ? arg : null;
        if (objectHandle) {
            if (objectHandle._context._delegate !== this)
                throw new Error('JSHandles can be evaluated only in the context they were created!');
            if (objectHandle._disposed)
                throw new Error('JSHandle is disposed!');
            const remoteObject = toRemoteObject(arg);
            if (!remoteObject.objectId)
                return { value: wkProtocolHelper_1.valueFromRemoteObject(remoteObject) };
            return { objectId: remoteObject.objectId };
        }
        return { value: arg };
    }
}
exports.WKExecutionContext = WKExecutionContext;
const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;
const contextDestroyedResult = {
    wasThrown: true,
    result: {
        description: 'Protocol error: Execution context was destroyed, most likely because of a navigation.'
    }
};
function toRemoteObject(handle) {
    return handle._remoteObject;
}
//# sourceMappingURL=wkExecutionContext.js.map