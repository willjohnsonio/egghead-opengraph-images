"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("../helper");
const dom = require("../dom");
const events_1 = require("../events");
const wkExecutionContext_1 = require("./wkExecutionContext");
const wkInterceptableRequest_1 = require("./wkInterceptableRequest");
const wkWorkers_1 = require("./wkWorkers");
const page_1 = require("../page");
const dialog = require("../dialog");
const wkInput_1 = require("./wkInput");
const platform = require("../platform");
const wkAccessibility_1 = require("./wkAccessibility");
const wkProvisionalPage_1 = require("./wkProvisionalPage");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
const BINDING_CALL_MESSAGE = '__playwright_binding_call__';
class WKPage {
    constructor(browserContext, pageProxySession, openerResolver) {
        this._provisionalPage = null;
        this._requestIdToRequest = new Map();
        this._sessionListeners = [];
        this._bootstrapScripts = [];
        this._pageProxySession = pageProxySession;
        this._openerResolver = openerResolver;
        this.rawKeyboard = new wkInput_1.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new wkInput_1.RawMouseImpl(pageProxySession);
        this._contextIdToContext = new Map();
        this._page = new page_1.Page(this, browserContext);
        this._workers = new wkWorkers_1.WKWorkers(this._page);
        this._session = undefined;
        this._page.on(events_1.Events.Page.FrameDetached, frame => this._removeContextsForFrame(frame, false));
    }
    async _initializePageProxySession() {
        const promises = [
            this._pageProxySession.send('Dialog.enable'),
            this._pageProxySession.send('Emulation.setActiveAndFocused', { active: true }),
            this.authenticate(this._page._state.credentials)
        ];
        const contextOptions = this._page.context()._options;
        if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send('Emulation.setJavaScriptEnabled', { enabled: false }));
        if (this._page._state.viewportSize || contextOptions.viewport)
            promises.push(this._updateViewport(true /* updateTouch */));
        await Promise.all(promises);
    }
    _setSession(session) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
    }
    async initialize(session) {
        this._setSession(session);
        await Promise.all([
            this._initializePageProxySession(),
            this._initializeSession(this._session, ({ frameTree }) => this._handleFrameTree(frameTree)),
        ]);
    }
    // This method is called for provisional targets as well. The session passed as the parameter
    // may be different from the current session and may be destroyed without becoming current.
    async _initializeSession(session, resourceTreeHandler) {
        await this._initializeSessionMayThrow(session, resourceTreeHandler).catch(e => {
            if (session.isDisposed())
                return;
            // Swallow initialization errors due to newer target swap in,
            // since we will reinitialize again.
            if (this._session === session)
                throw e;
        });
    }
    async _initializeSessionMayThrow(session, resourceTreeHandler) {
        const [, frameTree] = await Promise.all([
            // Page agent must be enabled before Runtime.
            session.send('Page.enable'),
            session.send('Page.getResourceTree'),
        ]);
        resourceTreeHandler(frameTree);
        const promises = [
            // Resource tree should be received before first execution context.
            session.send('Runtime.enable'),
            session.send('Page.createUserWorld', { name: UTILITY_WORLD_NAME }).catch(_ => { }),
            session.send('Console.enable'),
            session.send('Network.enable'),
            this._workers.initializeSession(session)
        ];
        if (this._page._state.interceptNetwork)
            promises.push(session.send('Network.setInterceptionEnabled', { enabled: true, interceptRequests: true }));
        if (this._page._state.offlineMode)
            promises.push(session.send('Network.setEmulateOfflineState', { offline: true }));
        if (this._page._state.cacheEnabled === false)
            promises.push(session.send('Network.setResourceCachingDisabled', { disabled: true }));
        const contextOptions = this._page.context()._options;
        if (contextOptions.userAgent)
            promises.push(session.send('Page.overrideUserAgent', { value: contextOptions.userAgent }));
        if (this._page._state.mediaType || this._page._state.colorScheme)
            promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme));
        if (this._bootstrapScripts.length) {
            const source = this._bootstrapScripts.join(';');
            promises.push(session.send('Page.setBootstrapScript', { source }));
        }
        if (contextOptions.bypassCSP)
            promises.push(session.send('Page.setBypassCSP', { enabled: true }));
        if (this._page._state.extraHTTPHeaders || contextOptions.locale) {
            const headers = this._page._state.extraHTTPHeaders || {};
            if (contextOptions.locale)
                headers['Accept-Language'] = contextOptions.locale;
            promises.push(session.send('Network.setExtraHTTPHeaders', { headers }));
        }
        if (this._page._state.hasTouch)
            promises.push(session.send('Page.setTouchEmulationEnabled', { enabled: true }));
        if (contextOptions.timezoneId) {
            promises.push(session.send('Page.setTimeZone', { timeZone: contextOptions.timezoneId }).
                catch(e => { throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`); }));
        }
        await Promise.all(promises);
    }
    initializeProvisionalPage(provisionalSession) {
        helper_1.assert(!this._provisionalPage);
        this._provisionalPage = new wkProvisionalPage_1.WKProvisionalPage(provisionalSession, this);
        return this._provisionalPage.initializationPromise;
    }
    onProvisionalLoadCommitted(session) {
        helper_1.assert(this._provisionalPage);
        helper_1.assert(this._provisionalPage._session === session);
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(session);
    }
    onSessionDestroyed(session, crashed) {
        if (this._provisionalPage && this._provisionalPage._session === session) {
            this._provisionalPage.dispose();
            this._provisionalPage = null;
            return;
        }
        if (this._session === session && crashed)
            this.didClose(crashed);
    }
    didClose(crashed) {
        helper_1.helper.removeEventListeners(this._sessionListeners);
        if (crashed)
            this._page._didCrash();
        else
            this._page._didClose();
    }
    dispose() {
        if (this._provisionalPage) {
            this._provisionalPage.dispose();
            this._provisionalPage = null;
        }
        this._page._didDisconnect();
    }
    _addSessionListeners() {
        this._sessionListeners = [
            helper_1.helper.addEventListener(this._session, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(this._session, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(this._session, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(this._session, 'Page.loadEventFired', event => this._onLifecycleEvent(event.frameId, 'load')),
            helper_1.helper.addEventListener(this._session, 'Page.domContentEventFired', event => this._onLifecycleEvent(event.frameId, 'domcontentloaded')),
            helper_1.helper.addEventListener(this._session, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(this._session, 'Console.messageAdded', event => this._onConsoleMessage(event)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Dialog.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(this._session, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(this._session, 'Network.requestWillBeSent', e => this._onRequestWillBeSent(this._session, e)),
            helper_1.helper.addEventListener(this._session, 'Network.requestIntercepted', e => this._onRequestIntercepted(e)),
            helper_1.helper.addEventListener(this._session, 'Network.responseReceived', e => this._onResponseReceived(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFinished', e => this._onLoadingFinished(e)),
            helper_1.helper.addEventListener(this._session, 'Network.loadingFailed', e => this._onLoadingFailed(e)),
        ];
    }
    async _updateState(method, params) {
        await this._forAllSessions(session => session.send(method, params).then());
    }
    async _forAllSessions(callback) {
        const sessions = [
            this._session
        ];
        // If the state changes during provisional load, push it to the provisional page
        // as well to always be in sync with the backend.
        if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
        await Promise.all(sessions.map(session => callback(session).catch(helper_1.debugError)));
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        helper_1.assert(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
            this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
    }
    _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
            if (context.frame === frame) {
                context._delegate._dispose();
                this._contextIdToContext.delete(contextId);
                if (notifyFrame)
                    frame._contextDestroyed(context);
            }
        }
    }
    _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
            return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
            return;
        const delegate = new wkExecutionContext_1.WKExecutionContext(this._session, contextPayload.id);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (contextPayload.type === 'normal')
            frame._contextCreated('main', context);
        else if (contextPayload.type === 'user' && contextPayload.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        if (contextPayload.type === 'normal' && frame === this._page.mainFrame())
            this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
    }
    async navigateFrame(frame, url, referrer) {
        if (this._pageProxySession.isDisposed())
            throw new Error('Target closed');
        const pageProxyId = this._pageProxySession.sessionId;
        const result = await this._pageProxySession.connection.browserSession.send('Browser.navigate', { url, pageProxyId, frameId: frame._id, referrer });
        return { newDocumentId: result.loaderId };
    }
    _onConsoleMessage(event) {
        // Note: do no introduce await in this function, otherwise we lose the ordering.
        // For example, frame.setContent relies on this.
        const { type, level, text, parameters, url, line: lineNumber, column: columnNumber, source } = event.message;
        if (level === 'debug' && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
            const parsedObjectId = JSON.parse(parameters[1].objectId);
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            this._page._onBindingCalled(parameters[2].value, context);
            return;
        }
        if (level === 'error' && source === 'javascript') {
            const error = new Error(text);
            error.stack = 'Error: ' + error.message; // Nullify stack. Stack is supposed to contain error message as the first line.
            this._page.emit(events_1.Events.Page.PageError, error);
            return;
        }
        let derivedType = type || '';
        if (type === 'log')
            derivedType = level;
        else if (type === 'timing')
            derivedType = 'timeEnd';
        const handles = (parameters || []).map(p => {
            let context = null;
            if (p.objectId) {
                const objectId = JSON.parse(p.objectId);
                context = this._contextIdToContext.get(objectId.injectedScriptId);
            }
            else {
                context = this._contextIdToContext.get(this._mainFrameContextId);
            }
            return context._createHandle(p);
        });
        this._page._addConsoleMessage(derivedType, handles, { url, lineNumber: (lineNumber || 1) - 1, columnNumber: (columnNumber || 1) - 1 }, handles.length ? undefined : text);
    }
    _onDialog(event) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(event.type, event.message, async (accept, promptText) => {
            await this._pageProxySession.send('Dialog.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    async _onFileChooserOpened(event) {
        const context = await this._page._frameManager.frame(event.frameId)._mainContext();
        const handle = context._createHandle(event.element).asElement();
        this._page._onFileChooserOpened(handle);
    }
    static async _setEmulateMedia(session, mediaType, colorScheme) {
        const promises = [];
        promises.push(session.send('Page.setEmulatedMedia', { media: mediaType || '' }));
        if (colorScheme !== null) {
            let appearance = '';
            switch (colorScheme) {
                case 'light':
                    appearance = 'Light';
                    break;
                case 'dark':
                    appearance = 'Dark';
                    break;
            }
            promises.push(session.send('Page.setForcedAppearance', { appearance }));
        }
        await Promise.all(promises);
    }
    async setExtraHTTPHeaders(headers) {
        const copy = { ...headers };
        const locale = this._page.context()._options.locale;
        if (locale)
            copy['Accept-Language'] = locale;
        await this._updateState('Network.setExtraHTTPHeaders', { headers: copy });
    }
    async setEmulateMedia(mediaType, colorScheme) {
        await this._forAllSessions(session => WKPage._setEmulateMedia(session, mediaType, colorScheme));
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._updateViewport(false /* updateTouch */);
    }
    async _updateViewport(updateTouch) {
        let viewport = this._page.context()._options.viewport || { width: 0, height: 0 };
        const viewportSize = this._page._state.viewportSize;
        if (viewportSize)
            viewport = { ...viewport, ...viewportSize };
        const promises = [
            this._pageProxySession.send('Emulation.setDeviceMetricsOverride', {
                width: viewport.width,
                height: viewport.height,
                fixedLayout: !!viewport.isMobile,
                deviceScaleFactor: viewport.deviceScaleFactor || 1
            }),
        ];
        if (updateTouch)
            promises.push(this._updateState('Page.setTouchEmulationEnabled', { enabled: !!viewport.isMobile }));
        await Promise.all(promises);
    }
    async setCacheEnabled(enabled) {
        const disabled = !enabled;
        await this._updateState('Network.setResourceCachingDisabled', { disabled });
    }
    async setRequestInterception(enabled) {
        await this._updateState('Network.setInterceptionEnabled', { enabled, interceptRequests: enabled });
    }
    async setOfflineMode(offline) {
        await this._updateState('Network.setEmulateOfflineState', { offline });
    }
    async authenticate(credentials) {
        await this._pageProxySession.send('Emulation.setAuthCredentials', { ...(credentials || { username: '', password: '' }) });
    }
    async setFileChooserIntercepted(enabled) {
        await this._session.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        return await this._openerResolver();
    }
    async reload() {
        await this._session.send('Page.reload');
    }
    goBack() {
        return this._session.send('Page.goBack').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
                return false;
            throw error;
        });
    }
    goForward() {
        return this._session.send('Page.goForward').then(() => true).catch(error => {
            if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
                return false;
            throw error;
        });
    }
    async exposeBinding(name, bindingFunction) {
        const script = `self.${name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${bindingFunction}`;
        this._bootstrapScripts.unshift(script);
        await this._setBootstrapScripts();
        await Promise.all(this._page.frames().map(frame => frame.evaluate(script).catch(helper_1.debugError)));
    }
    async evaluateOnNewDocument(script) {
        this._bootstrapScripts.push(script);
        await this._setBootstrapScripts();
    }
    async _setBootstrapScripts() {
        const source = this._bootstrapScripts.join(';');
        await this._updateState('Page.setBootstrapScript', { source });
    }
    async closePage(runBeforeUnload) {
        this._pageProxySession.send('Target.close', {
            targetId: this._session.sessionId,
            runBeforeUnload
        }).catch(helper_1.debugError);
    }
    getBoundingBoxForScreenshot(handle) {
        return handle.boundingBox();
    }
    canScreenshotOutsideViewport() {
        return false;
    }
    async setBackgroundColor(color) {
        // TODO: line below crashes, sort it out.
        await this._session.send('Page.setDefaultBackgroundColorOverride', { color });
    }
    async takeScreenshot(format, options, viewportSize) {
        const rect = options.clip || { x: 0, y: 0, width: viewportSize.width, height: viewportSize.height };
        const result = await this._session.send('Page.snapshotRect', { ...rect, coordinateSystem: options.fullPage ? 'Page' : 'Viewport' });
        const prefix = 'data:image/png;base64,';
        let buffer = platform.Buffer.from(result.dataURL.substr(prefix.length), 'base64');
        if (format === 'jpeg')
            buffer = platform.pngToJpeg(buffer);
        return buffer;
    }
    async resetViewport(oldSize) {
        await this._pageProxySession.send('Emulation.setDeviceMetricsOverride', { ...oldSize, fixedLayout: false, deviceScaleFactor: 0 });
    }
    async getContentFrame(handle) {
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId
        });
        if (!nodeInfo.contentFrameId)
            return null;
        return this._page._frameManager.frame(nodeInfo.contentFrameId);
    }
    async getOwnerFrame(handle) {
        const remoteObject = toRemoteObject(handle);
        if (!remoteObject.objectId)
            return null;
        const nodeInfo = await this._session.send('DOM.describeNode', {
            objectId: remoteObject.objectId
        });
        return nodeInfo.ownerFrameId || null;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const quads = await this.getContentQuads(handle);
        if (!quads || !quads.length)
            return null;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (const quad of quads) {
            for (const point of quad) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            }
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._session.send('DOM.scrollIntoViewIfNeeded', {
            objectId: toRemoteObject(handle).objectId,
            rect,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                e.message = 'Node is either not visible or not an HTMLElement';
            throw e;
        });
    }
    async getContentQuads(handle) {
        const result = await this._session.send('DOM.getContentQuads', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] }
        ]);
    }
    async layoutViewport() {
        return this._page.evaluate(() => ({ width: innerWidth, height: innerHeight }));
    }
    async setInputFiles(handle, files) {
        const objectId = toRemoteObject(handle).objectId;
        await this._session.send('DOM.setInputFiles', { objectId, files });
    }
    async adoptElementHandle(handle, to) {
        const result = await this._session.send('DOM.resolveNode', {
            objectId: toRemoteObject(handle).objectId,
            executionContextId: to._delegate._contextId
        }).catch(helper_1.debugError);
        if (!result || result.object.subtype === 'null')
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.object);
    }
    async getAccessibilityTree(needle) {
        return wkAccessibility_1.getAccessibilityTree(this._session, needle);
    }
    async getFrameElement(frame) {
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        const context = await parent._utilityContext();
        const handles = await context._$$('iframe');
        const items = await Promise.all(handles.map(async (handle) => {
            const frame = await handle.contentFrame().catch(e => null);
            return { handle, frame };
        }));
        const result = items.find(item => item.frame === frame);
        await Promise.all(items.map(item => item === result ? Promise.resolve() : item.handle.dispose()));
        if (!result)
            throw new Error('Frame has been detached.');
        return result.handle;
    }
    _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith('data:'))
            return;
        let redirectChain = [];
        if (event.redirectResponse) {
            const request = this._requestIdToRequest.get(event.requestId);
            // If we connect late to the target, we could have missed the requestWillBeSent event.
            if (request) {
                this._handleRequestRedirect(request, event.redirectResponse);
                redirectChain = request.request._redirectChain;
            }
        }
        const frame = this._page._frameManager.frame(event.frameId);
        // TODO(einbinder) this will fail if we are an XHR document request
        const isNavigationRequest = event.type === 'Document';
        const documentId = isNavigationRequest ? event.loaderId : undefined;
        const request = new wkInterceptableRequest_1.WKInterceptableRequest(session, !!this._page._state.interceptNetwork, frame, event, redirectChain, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request);
    }
    _handleRequestRedirect(request, responsePayload) {
        const response = request.createResponse(responsePayload);
        request.request._redirectChain.push(request.request);
        response._requestFinished(new Error('Response body is unavailable for redirect responses'));
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.requestFinished(request.request);
    }
    _onRequestIntercepted(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
            request._interceptedCallback();
    }
    _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // FileUpload sends a response without a matching request.
        if (!request)
            return;
        const response = request.createResponse(event.response);
        this._page._frameManager.requestReceivedResponse(response);
    }
    _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        // Under certain conditions we never get the Network.responseReceived
        // event from protocol. @see https://crbug.com/883475
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestFinished(request.request);
    }
    _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        const response = request.request.response();
        if (response)
            response._requestFinished();
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes('cancelled'));
    }
}
exports.WKPage = WKPage;
function toRemoteObject(handle) {
    return handle._remoteObject;
}
//# sourceMappingURL=wkPage.js.map