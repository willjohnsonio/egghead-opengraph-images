/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as frames from '../frames';
import * as dom from '../dom';
import * as network from '../network';
import { WKSession } from './wkConnection';
import { Page, PageDelegate } from '../page';
import { Protocol } from './protocol';
import { BrowserContext } from '../browserContext';
import { RawMouseImpl, RawKeyboardImpl } from './wkInput';
import * as types from '../types';
import * as accessibility from '../accessibility';
import * as platform from '../platform';
export declare class WKPage implements PageDelegate {
    readonly rawMouse: RawMouseImpl;
    readonly rawKeyboard: RawKeyboardImpl;
    _session: WKSession;
    private _provisionalPage;
    readonly _page: Page;
    private readonly _pageProxySession;
    private readonly _openerResolver;
    private readonly _requestIdToRequest;
    private readonly _workers;
    private readonly _contextIdToContext;
    private _mainFrameContextId?;
    private _sessionListeners;
    private readonly _bootstrapScripts;
    constructor(browserContext: BrowserContext, pageProxySession: WKSession, openerResolver: () => Promise<Page | null>);
    private _initializePageProxySession;
    private _setSession;
    initialize(session: WKSession): Promise<void>;
    _initializeSession(session: WKSession, resourceTreeHandler: (r: Protocol.Page.getResourceTreeReturnValue) => void): Promise<void>;
    private _initializeSessionMayThrow;
    initializeProvisionalPage(provisionalSession: WKSession): Promise<void>;
    onProvisionalLoadCommitted(session: WKSession): void;
    onSessionDestroyed(session: WKSession, crashed: boolean): void;
    didClose(crashed: boolean): void;
    dispose(): void;
    private _addSessionListeners;
    private _updateState;
    private _forAllSessions;
    private _onFrameStoppedLoading;
    private _onLifecycleEvent;
    private _handleFrameTree;
    _onFrameAttached(frameId: string, parentFrameId: string | null): frames.Frame;
    private _onFrameNavigated;
    private _onFrameNavigatedWithinDocument;
    private _onFrameDetached;
    private _removeContextsForFrame;
    private _onExecutionContextCreated;
    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;
    private _onConsoleMessage;
    _onDialog(event: Protocol.Dialog.javascriptDialogOpeningPayload): void;
    private _onFileChooserOpened;
    private static _setEmulateMedia;
    setExtraHTTPHeaders(headers: network.Headers): Promise<void>;
    setEmulateMedia(mediaType: types.MediaType | null, colorScheme: types.ColorScheme | null): Promise<void>;
    setViewportSize(viewportSize: types.Size): Promise<void>;
    _updateViewport(updateTouch: boolean): Promise<void>;
    setCacheEnabled(enabled: boolean): Promise<void>;
    setRequestInterception(enabled: boolean): Promise<void>;
    setOfflineMode(offline: boolean): Promise<void>;
    authenticate(credentials: types.Credentials | null): Promise<void>;
    setFileChooserIntercepted(enabled: boolean): Promise<void>;
    opener(): Promise<Page | null>;
    reload(): Promise<void>;
    goBack(): Promise<boolean>;
    goForward(): Promise<boolean>;
    exposeBinding(name: string, bindingFunction: string): Promise<void>;
    evaluateOnNewDocument(script: string): Promise<void>;
    private _setBootstrapScripts;
    closePage(runBeforeUnload: boolean): Promise<void>;
    getBoundingBoxForScreenshot(handle: dom.ElementHandle<Node>): Promise<types.Rect | null>;
    canScreenshotOutsideViewport(): boolean;
    setBackgroundColor(color?: {
        r: number;
        g: number;
        b: number;
        a: number;
    }): Promise<void>;
    takeScreenshot(format: string, options: types.ScreenshotOptions, viewportSize: types.Size): Promise<platform.BufferType>;
    resetViewport(oldSize: types.Size): Promise<void>;
    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;
    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;
    isElementHandle(remoteObject: any): boolean;
    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;
    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<void>;
    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;
    layoutViewport(): Promise<{
        width: number;
        height: number;
    }>;
    setInputFiles(handle: dom.ElementHandle<HTMLInputElement>, files: types.FilePayload[]): Promise<void>;
    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;
    getAccessibilityTree(needle?: dom.ElementHandle): Promise<{
        tree: accessibility.AXNode;
        needle: accessibility.AXNode | null;
    }>;
    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;
    _onRequestWillBeSent(session: WKSession, event: Protocol.Network.requestWillBeSentPayload): void;
    private _handleRequestRedirect;
    _onRequestIntercepted(event: Protocol.Network.requestInterceptedPayload): void;
    _onResponseReceived(event: Protocol.Network.responseReceivedPayload): void;
    _onLoadingFinished(event: Protocol.Network.loadingFinishedPayload): void;
    _onLoadingFailed(event: Protocol.Network.loadingFailedPayload): void;
}
