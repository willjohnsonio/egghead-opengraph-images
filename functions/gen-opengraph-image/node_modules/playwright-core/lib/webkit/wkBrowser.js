"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const browser_1 = require("../browser");
const browserContext_1 = require("../browserContext");
const helper_1 = require("../helper");
const transport_1 = require("../transport");
const events_1 = require("../events");
const wkConnection_1 = require("./wkConnection");
const wkPageProxy_1 = require("./wkPageProxy");
const platform = require("../platform");
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.4 Safari/605.1.15';
class WKBrowser extends platform.EventEmitter {
    constructor(transport) {
        super();
        this._contexts = new Map();
        this._pageProxies = new Map();
        this._connection = new wkConnection_1.WKConnection(transport, this._onDisconnect.bind(this));
        this._browserSession = this._connection.browserSession;
        this._defaultContext = this._createBrowserContext(undefined, {});
        this._eventListeners = [
            helper_1.helper.addEventListener(this._browserSession, 'Browser.pageProxyCreated', this._onPageProxyCreated.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Browser.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._browserSession, 'Browser.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)),
            helper_1.helper.addEventListener(this._browserSession, wkConnection_1.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this)),
        ];
        this._firstPageProxyPromise = new Promise(resolve => this._firstPageProxyCallback = resolve);
    }
    static async connect(transport, slowMo = 0) {
        const browser = new WKBrowser(transport_1.SlowMoTransport.wrap(transport, slowMo));
        return browser;
    }
    _onDisconnect() {
        for (const context of this.contexts())
            context._browserClosed();
        for (const pageProxy of this._pageProxies.values())
            pageProxy.dispose();
        this._pageProxies.clear();
        this.emit(events_1.Events.Browser.Disconnected);
    }
    async newContext(options = {}) {
        const { browserContextId } = await this._browserSession.send('Browser.createContext');
        options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
        const context = this._createBrowserContext(browserContextId, options);
        if (options.ignoreHTTPSErrors)
            await this._browserSession.send('Browser.setIgnoreCertificateErrors', { browserContextId, ignore: true });
        if (options.locale)
            await this._browserSession.send('Browser.setLanguages', { browserContextId, languages: [options.locale] });
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _waitForFirstPageTarget() {
        helper_1.assert(!this._pageProxies.size);
        return this._firstPageProxyPromise;
    }
    _onPageProxyCreated(event) {
        const { pageProxyInfo } = event;
        const pageProxyId = pageProxyInfo.pageProxyId;
        let context = null;
        if (pageProxyInfo.browserContextId) {
            // FIXME: we don't know about the default context id, so assume that all targets from
            // unknown contexts are created in the 'default' context which can in practice be represented
            // by multiple actual contexts in WebKit. Solving this properly will require adding context
            // lifecycle events.
            context = this._contexts.get(pageProxyInfo.browserContextId);
        }
        if (!context)
            context = this._defaultContext;
        const pageProxySession = new wkConnection_1.WKSession(this._connection, pageProxyId, `The page has been closed.`, (message) => {
            this._connection.rawSend({ ...message, pageProxyId });
        });
        const pageProxy = new wkPageProxy_1.WKPageProxy(pageProxySession, context, () => {
            if (!pageProxyInfo.openerId)
                return null;
            const opener = this._pageProxies.get(pageProxyInfo.openerId);
            if (!opener)
                return null;
            return opener;
        });
        this._pageProxies.set(pageProxyId, pageProxy);
        if (pageProxyInfo.openerId) {
            const opener = this._pageProxies.get(pageProxyInfo.openerId);
            if (opener)
                opener.onPopupCreated(pageProxy);
        }
        if (this._firstPageProxyCallback) {
            this._firstPageProxyCallback();
            this._firstPageProxyCallback = undefined;
        }
    }
    _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const pageProxy = this._pageProxies.get(pageProxyId);
        pageProxy.didClose();
        pageProxy.dispose();
        this._pageProxies.delete(pageProxyId);
    }
    _onPageProxyMessageReceived(event) {
        const pageProxy = this._pageProxies.get(event.pageProxyId);
        pageProxy.dispatchMessageToSession(event.message);
    }
    _onProvisionalLoadFailed(event) {
        const pageProxy = this._pageProxies.get(event.pageProxyId);
        pageProxy.handleProvisionalLoadFailed(event);
    }
    isConnected() {
        return !this._connection.isClosed();
    }
    async close() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        const disconnected = new Promise(f => this.once(events_1.Events.Browser.Disconnected, f));
        await Promise.all(this.contexts().map(context => context.close()));
        this._connection.close();
        await disconnected;
    }
    _createBrowserContext(browserContextId, options) {
        browserContext_1.BrowserContext.validateOptions(options);
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const pageProxies = Array.from(this._pageProxies.values()).filter(proxy => proxy._browserContext === context);
                return await Promise.all(pageProxies.map(proxy => proxy.page()));
            },
            existingPages: () => {
                const pages = [];
                for (const pageProxy of this._pageProxies.values()) {
                    if (pageProxy._browserContext !== context)
                        continue;
                    const page = pageProxy.existingPage();
                    if (page)
                        pages.push(page);
                }
                return pages;
            },
            newPage: async () => {
                const { pageProxyId } = await this._browserSession.send('Browser.createPage', { browserContextId });
                const pageProxy = this._pageProxies.get(pageProxyId);
                return await pageProxy.page();
            },
            close: async () => {
                helper_1.assert(browserContextId, 'Non-incognito profiles cannot be closed!');
                await this._browserSession.send('Browser.deleteContext', { browserContextId: browserContextId });
                this._contexts.delete(browserContextId);
            },
            cookies: async () => {
                const { cookies } = await this._browserSession.send('Browser.getAllCookies', { browserContextId });
                return cookies.map((c) => ({
                    ...c,
                    expires: c.expires === 0 ? -1 : c.expires
                }));
            },
            clearCookies: async () => {
                await this._browserSession.send('Browser.deleteAllCookies', { browserContextId });
            },
            setCookies: async (cookies) => {
                const cc = cookies.map(c => ({ ...c, session: c.expires === -1 || c.expires === undefined }));
                await this._browserSession.send('Browser.setCookies', { cookies: cc, browserContextId });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geolocation'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._browserSession.send('Browser.grantPermissions', { origin, browserContextId, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._browserSession.send('Browser.resetPermissions', { browserContextId });
            },
            setGeolocation: async (geolocation) => {
                const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : undefined;
                await this._browserSession.send('Browser.setGeolocationOverride', { browserContextId, geolocation: payload });
            }
        }, options);
        return context;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugFunction = debugFunction;
    }
}
exports.WKBrowser = WKBrowser;
//# sourceMappingURL=wkBrowser.js.map