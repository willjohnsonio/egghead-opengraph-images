"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const wkConnection_1 = require("./wkConnection");
const wkPage_1 = require("./wkPage");
const helper_1 = require("../helper");
const events_1 = require("../events");
const isPovisionalSymbol = Symbol('isPovisional');
class WKPageProxy {
    constructor(pageProxySession, browserContext, openerResolver) {
        this._pagePromise = null;
        this._wkPage = null;
        this._pagePausedOnStart = false;
        this._sessions = new Map();
        this._pageProxySession = pageProxySession;
        this._browserContext = browserContext;
        this._openerResolver = openerResolver;
        this._firstTargetPromise = new Promise(r => this._firstTargetCallback = r);
        this._eventListeners = [
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetCreated', this._onTargetCreated.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.dispatchMessageFromTarget', this._onDispatchMessageFromTarget.bind(this)),
            helper_1.helper.addEventListener(this._pageProxySession, 'Target.didCommitProvisionalTarget', this._onDidCommitProvisionalTarget.bind(this)),
        ];
    }
    didClose() {
        if (this._wkPage)
            this._wkPage.didClose(false);
    }
    dispose() {
        this._pageProxySession.dispose();
        helper_1.helper.removeEventListeners(this._eventListeners);
        for (const session of this._sessions.values())
            session.dispose();
        this._sessions.clear();
        if (this._wkPage)
            this._wkPage.dispose();
    }
    dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
    }
    _isProvisionalCrossProcessLoadInProgress() {
        for (const anySession of this._sessions.values()) {
            if (anySession[isPovisionalSymbol])
                return true;
        }
        return false;
    }
    handleProvisionalLoadFailed(event) {
        if (!this._wkPage)
            return;
        if (!this._isProvisionalCrossProcessLoadInProgress())
            return;
        let errorText = event.error;
        if (errorText.includes('cancelled'))
            errorText += '; maybe frame was detached?';
        this._wkPage._page._frameManager.provisionalLoadFailed(this._wkPage._page.mainFrame(), event.loaderId, errorText);
    }
    async page() {
        if (!this._pagePromise)
            this._pagePromise = this._initializeWKPage();
        return this._pagePromise;
    }
    existingPage() {
        return this._wkPage ? this._wkPage._page : undefined;
    }
    onPopupCreated(popupPageProxy) {
        if (this._wkPage)
            popupPageProxy.page().then(page => this._wkPage._page.emit(events_1.Events.Page.Popup, page));
    }
    async _initializeWKPage() {
        await this._firstTargetPromise;
        let session;
        for (const anySession of this._sessions.values()) {
            if (!anySession[isPovisionalSymbol]) {
                session = anySession;
                break;
            }
        }
        helper_1.assert(session, 'One non-provisional target session must exist');
        this._wkPage = new wkPage_1.WKPage(this._browserContext, this._pageProxySession, async () => {
            const pageProxy = this._openerResolver();
            if (!pageProxy)
                return null;
            return await pageProxy.page();
        });
        await this._wkPage.initialize(session);
        if (this._pagePausedOnStart) {
            this._resumeTarget(session.sessionId);
            this._pagePausedOnStart = false;
        }
        return this._wkPage._page;
    }
    _onTargetCreated(event) {
        const { targetInfo } = event;
        const session = new wkConnection_1.WKSession(this._pageProxySession.connection, targetInfo.targetId, `The ${targetInfo.type} has been closed.`, (message) => {
            this._pageProxySession.send('Target.sendMessageToTarget', {
                message: JSON.stringify(message), targetId: targetInfo.targetId
            }).catch(e => {
                session.dispatchMessage({ id: message.id, error: { message: e.message } });
            });
        });
        helper_1.assert(targetInfo.type === 'page', 'Only page targets are expected in WebKit, received: ' + targetInfo.type);
        this._sessions.set(targetInfo.targetId, session);
        if (this._firstTargetCallback) {
            this._firstTargetCallback();
            this._firstTargetCallback = undefined;
        }
        if (targetInfo.isProvisional) {
            session[isPovisionalSymbol] = true;
            if (this._wkPage) {
                const provisionalPageInitialized = this._wkPage.initializeProvisionalPage(session);
                if (targetInfo.isPaused)
                    provisionalPageInitialized.then(() => this._resumeTarget(targetInfo.targetId));
            }
            else if (targetInfo.isPaused) {
                this._resumeTarget(targetInfo.targetId);
            }
        }
        else if (this._pagePromise) {
            helper_1.assert(!this._pagePausedOnStart);
            // This is the first time page target is created, will resume
            // after finishing intialization.
            this._pagePausedOnStart = !!targetInfo.isPaused;
        }
        else if (targetInfo.isPaused) {
            this._resumeTarget(targetInfo.targetId);
        }
    }
    _resumeTarget(targetId) {
        this._pageProxySession.send('Target.resume', { targetId }).catch(helper_1.debugError);
    }
    _onTargetDestroyed(event) {
        const { targetId, crashed } = event;
        const session = this._sessions.get(targetId);
        helper_1.assert(session, 'Unknown target destroyed: ' + targetId);
        session.dispose();
        this._sessions.delete(targetId);
        if (this._wkPage)
            this._wkPage.onSessionDestroyed(session, crashed);
    }
    _onDispatchMessageFromTarget(event) {
        const { targetId, message } = event;
        const session = this._sessions.get(targetId);
        helper_1.assert(session, 'Unknown target: ' + targetId);
        session.dispatchMessage(JSON.parse(message));
    }
    _onDidCommitProvisionalTarget(event) {
        const { oldTargetId, newTargetId } = event;
        const newSession = this._sessions.get(newTargetId);
        helper_1.assert(newSession, 'Unknown new target: ' + newTargetId);
        const oldSession = this._sessions.get(oldTargetId);
        helper_1.assert(oldSession, 'Unknown old target: ' + oldTargetId);
        // TODO: make some calls like screenshot catch swapped out error and retry.
        oldSession.errorText = 'Target was swapped out.';
        newSession[isPovisionalSymbol] = undefined;
        if (this._wkPage)
            this._wkPage.onProvisionalLoadCommitted(newSession);
    }
}
exports.WKPageProxy = WKPageProxy;
//# sourceMappingURL=wkPageProxy.js.map