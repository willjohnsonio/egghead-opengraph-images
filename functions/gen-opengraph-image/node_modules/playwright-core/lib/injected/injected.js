"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const cssSelectorEngine_1 = require("./cssSelectorEngine");
const xpathSelectorEngine_1 = require("./xpathSelectorEngine");
const textSelectorEngine_1 = require("./textSelectorEngine");
function createAttributeEngine(attribute) {
    const engine = {
        name: attribute,
        create(root, target) {
            const value = target.getAttribute(attribute);
            if (!value)
                return;
            if (root.querySelector(`[${attribute}=${value}]`) === target)
                return value;
        },
        query(root, selector) {
            return root.querySelector(`[${attribute}=${selector}]`) || undefined;
        },
        queryAll(root, selector) {
            return Array.from(root.querySelectorAll(`[${attribute}=${selector}]`));
        }
    };
    return engine;
}
class Injected {
    constructor(customEngines) {
        const defaultEngines = [
            cssSelectorEngine_1.CSSEngine,
            xpathSelectorEngine_1.XPathEngine,
            textSelectorEngine_1.TextEngine,
            createAttributeEngine('id'),
            createAttributeEngine('data-testid'),
            createAttributeEngine('data-test-id'),
            createAttributeEngine('data-test'),
        ];
        this.utils = new utils_1.Utils();
        this.engines = new Map();
        for (const engine of [...defaultEngines, ...customEngines])
            this.engines.set(engine.name, engine);
    }
    querySelector(selector, root) {
        const parsed = this._parseSelector(selector);
        if (!root['querySelector'])
            throw new Error('Node is not queryable.');
        let element = root;
        for (const { engine, selector } of parsed) {
            const next = engine.query(element.shadowRoot || element, selector);
            if (!next)
                return;
            element = next;
        }
        return element;
    }
    querySelectorAll(selector, root) {
        const parsed = this._parseSelector(selector);
        if (!root['querySelectorAll'])
            throw new Error('Node is not queryable.');
        let set = new Set([root]);
        for (const { engine, selector } of parsed) {
            const newSet = new Set();
            for (const prev of set) {
                for (const next of engine.queryAll(prev.shadowRoot || prev, selector)) {
                    if (newSet.has(next))
                        continue;
                    newSet.add(next);
                }
            }
            set = newSet;
        }
        return Array.from(set);
    }
    _parseSelector(selector) {
        let index = 0;
        let quote;
        let start = 0;
        const result = [];
        const append = () => {
            const part = selector.substring(start, index);
            const eqIndex = part.indexOf('=');
            if (eqIndex === -1)
                throw new Error(`Cannot parse selector ${selector}`);
            const name = part.substring(0, eqIndex).trim();
            const body = part.substring(eqIndex + 1);
            const engine = this.engines.get(name.toLowerCase());
            if (!engine)
                throw new Error(`Unknown engine ${name} while parsing selector ${selector}`);
            result.push({ engine, selector: body });
        };
        while (index < selector.length) {
            const c = selector[index];
            if (c === '\\' && index + 1 < selector.length) {
                index += 2;
            }
            else if (c === quote) {
                quote = undefined;
                index++;
            }
            else if (!quote && c === '>' && selector[index + 1] === '>') {
                append();
                index += 2;
                start = index;
            }
            else {
                index++;
            }
        }
        append();
        return result;
    }
    isVisible(element) {
        if (!element.ownerDocument || !element.ownerDocument.defaultView)
            return true;
        const style = element.ownerDocument.defaultView.getComputedStyle(element);
        if (!style || style.visibility === 'hidden')
            return false;
        const rect = element.getBoundingClientRect();
        return !!(rect.top || rect.bottom || rect.width || rect.height);
    }
    pollMutation(selector, predicate, timeout) {
        let timedOut = false;
        if (timeout)
            setTimeout(() => timedOut = true, timeout);
        const element = selector === undefined ? undefined : this.querySelector(selector, document);
        const success = predicate(element);
        if (success)
            return Promise.resolve(success);
        let fulfill;
        const result = new Promise(x => fulfill = x);
        const observer = new MutationObserver(() => {
            if (timedOut) {
                observer.disconnect();
                fulfill();
                return;
            }
            const element = selector === undefined ? undefined : this.querySelector(selector, document);
            const success = predicate(element);
            if (success) {
                observer.disconnect();
                fulfill(success);
            }
        });
        observer.observe(document, {
            childList: true,
            subtree: true,
            attributes: true
        });
        return result;
    }
    pollRaf(selector, predicate, timeout) {
        let timedOut = false;
        if (timeout)
            setTimeout(() => timedOut = true, timeout);
        let fulfill;
        const result = new Promise(x => fulfill = x);
        const onRaf = () => {
            if (timedOut) {
                fulfill();
                return;
            }
            const element = selector === undefined ? undefined : this.querySelector(selector, document);
            const success = predicate(element);
            if (success)
                fulfill(success);
            else
                requestAnimationFrame(onRaf);
        };
        onRaf();
        return result;
    }
    pollInterval(selector, pollInterval, predicate, timeout) {
        let timedOut = false;
        if (timeout)
            setTimeout(() => timedOut = true, timeout);
        let fulfill;
        const result = new Promise(x => fulfill = x);
        const onTimeout = () => {
            if (timedOut) {
                fulfill();
                return;
            }
            const element = selector === undefined ? undefined : this.querySelector(selector, document);
            const success = predicate(element);
            if (success)
                fulfill(success);
            else
                setTimeout(onTimeout, pollInterval);
        };
        onTimeout();
        return result;
    }
}
exports.default = Injected;
//# sourceMappingURL=injected.js.map