"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const dom = require("./dom");
const helper_1 = require("./helper");
const errors_1 = require("./errors");
const events_1 = require("./events");
const platform = require("./platform");
const kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle0', 'networkidle2']);
class FrameManager {
    constructor(page) {
        this._frames = new Map();
        this._lifecycleWatchers = new Set();
        this._consoleMessageTags = new Map();
        this._page = page;
        this._mainFrame = undefined;
    }
    mainFrame() {
        return this._mainFrame;
    }
    frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
            frames.push(frame);
            for (const subframe of frame.childFrames())
                collect(subframe);
        }
    }
    frame(frameId) {
        return this._frames.get(frameId) || null;
    }
    frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
            if (this._mainFrame) {
                // Update frame id to retain frame identity on cross-process navigation.
                this._frames.delete(this._mainFrame._id);
                this._mainFrame._id = frameId;
            }
            else {
                helper_1.assert(!this._frames.has(frameId));
                this._mainFrame = new Frame(this._page, frameId, parentFrame);
            }
            this._frames.set(frameId, this._mainFrame);
            return this._mainFrame;
        }
        else {
            helper_1.assert(!this._frames.has(frameId));
            const frame = new Frame(this._page, frameId, parentFrame);
            this._frames.set(frameId, frame);
            this._page.emit(events_1.Events.Page.FrameAttached, frame);
            return frame;
        }
    }
    frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._url = url;
        frame._name = name;
        frame._lastDocumentId = documentId;
        for (const watcher of frame._documentWatchers)
            watcher(documentId);
        this.clearFrameLifecycle(frame);
        if (!initial)
            this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._url = url;
        for (const watcher of frame._sameDocumentNavigationWatchers)
            watcher();
        this._page.emit(events_1.Events.Page.FrameNavigated, frame);
    }
    frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
            this._removeFramesRecursively(frame);
    }
    frameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        const hasDOMContentLoaded = frame._firedLifecycleEvents.has('domcontentloaded');
        const hasLoad = frame._firedLifecycleEvents.has('load');
        frame._firedLifecycleEvents.add('domcontentloaded');
        frame._firedLifecycleEvents.add('load');
        for (const watcher of this._lifecycleWatchers)
            watcher();
        if (frame === this.mainFrame() && !hasDOMContentLoaded)
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
        if (frame === this.mainFrame() && !hasLoad)
            this._page.emit(events_1.Events.Page.Load);
    }
    frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (!frame)
            return;
        frame._firedLifecycleEvents.add(event);
        for (const watcher of this._lifecycleWatchers)
            watcher();
        if (frame === this._mainFrame && event === 'load')
            this._page.emit(events_1.Events.Page.Load);
        if (frame === this._mainFrame && event === 'domcontentloaded')
            this._page.emit(events_1.Events.Page.DOMContentLoaded);
    }
    clearFrameLifecycle(frame) {
        frame._firedLifecycleEvents.clear();
        // Keep the current navigation request if any.
        frame._inflightRequests = new Set(Array.from(frame._inflightRequests).filter(request => request._documentId === frame._lastDocumentId));
        this._stopNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 0)
            this._startNetworkIdleTimer(frame, 'networkidle0');
        this._stopNetworkIdleTimer(frame, 'networkidle2');
        if (frame._inflightRequests.size <= 2)
            this._startNetworkIdleTimer(frame, 'networkidle2');
    }
    requestStarted(request) {
        this._inflightRequestStarted(request);
        const frame = request.frame();
        if (frame) {
            for (const watcher of frame._requestWatchers)
                watcher(request);
        }
        if (!request._isFavicon)
            this._page._requestStarted(request);
    }
    requestReceivedResponse(response) {
        if (!response.request()._isFavicon)
            this._page.emit(events_1.Events.Page.Response, response);
    }
    requestFinished(request) {
        this._inflightRequestFinished(request);
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFinished, request);
    }
    requestFailed(request, canceled) {
        this._inflightRequestFinished(request);
        const frame = request.frame();
        if (request._documentId && frame) {
            const isCurrentDocument = frame._lastDocumentId === request._documentId;
            if (!isCurrentDocument) {
                let errorText = request.failure().errorText;
                if (canceled)
                    errorText += '; maybe frame was detached?';
                for (const watcher of frame._documentWatchers)
                    watcher(request._documentId, new Error(errorText));
            }
        }
        if (!request._isFavicon)
            this._page.emit(events_1.Events.Page.RequestFailed, request);
    }
    provisionalLoadFailed(frame, documentId, error) {
        for (const watcher of frame._documentWatchers)
            watcher(documentId, new Error(error));
    }
    _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        frame._onDetached();
        this._frames.delete(frame._id);
        this._page.emit(events_1.Events.Page.FrameDetached, frame);
    }
    _inflightRequestFinished(request) {
        const frame = request.frame();
        if (!frame || request._isFavicon)
            return;
        if (!frame._inflightRequests.has(request))
            return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
            this._startNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 2)
            this._startNetworkIdleTimer(frame, 'networkidle2');
    }
    _inflightRequestStarted(request) {
        const frame = request.frame();
        if (!frame || request._isFavicon)
            return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
            this._stopNetworkIdleTimer(frame, 'networkidle0');
        if (frame._inflightRequests.size === 3)
            this._stopNetworkIdleTimer(frame, 'networkidle2');
    }
    _startNetworkIdleTimer(frame, event) {
        helper_1.assert(!frame._networkIdleTimers.has(event));
        if (frame._firedLifecycleEvents.has(event))
            return;
        frame._networkIdleTimers.set(event, setTimeout(() => {
            this.frameLifecycleEvent(frame._id, event);
        }, 500));
    }
    _stopNetworkIdleTimer(frame, event) {
        const timeoutId = frame._networkIdleTimers.get(event);
        if (timeoutId)
            clearTimeout(timeoutId);
        frame._networkIdleTimers.delete(event);
    }
    interceptConsoleMessage(message) {
        if (message.type() !== 'debug')
            return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
            return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
    }
}
exports.FrameManager = FrameManager;
class Frame {
    constructor(page, id, parentFrame) {
        this._lastDocumentId = '';
        this._requestWatchers = new Set();
        this._documentWatchers = new Set();
        this._sameDocumentNavigationWatchers = new Set();
        this._url = '';
        this._detached = false;
        this._contextData = new Map();
        this._childFrames = new Set();
        this._name = '';
        this._inflightRequests = new Set();
        this._networkIdleTimers = new Map();
        this._setContentCounter = 0;
        this._detachedCallback = () => { };
        this.evaluateHandle = async (pageFunction, ...args) => {
            const context = await this._mainContext();
            return context.evaluateHandle(pageFunction, ...args);
        };
        this.evaluate = async (pageFunction, ...args) => {
            const context = await this._mainContext();
            return context.evaluate(pageFunction, ...args);
        };
        this.$eval = async (selector, pageFunction, ...args) => {
            const context = await this._mainContext();
            const elementHandle = await context._$(selector);
            if (!elementHandle)
                throw new Error(`Error: failed to find element matching selector "${selector}"`);
            const result = await elementHandle.evaluate(pageFunction, ...args);
            await elementHandle.dispose();
            return result;
        };
        this.$$eval = async (selector, pageFunction, ...args) => {
            const context = await this._mainContext();
            const arrayHandle = await context._$array(selector);
            const result = await arrayHandle.evaluate(pageFunction, ...args);
            await arrayHandle.dispose();
            return result;
        };
        this._id = id;
        this._firedLifecycleEvents = new Set();
        this._page = page;
        this._parentFrame = parentFrame;
        this._detachedPromise = new Promise(x => this._detachedCallback = x);
        this._contextData.set('main', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._contextData.set('utility', { contextPromise: new Promise(() => { }), contextResolveCallback: () => { }, context: null, rerunnableTasks: new Set() });
        this._setContext('main', null);
        this._setContext('utility', null);
        if (this._parentFrame)
            this._parentFrame._childFrames.add(this);
    }
    async goto(url, options = {}) {
        const headers = (this._page._state.extraHTTPHeaders || {});
        let referer = headers['referer'] || headers['Referer'];
        if (options.referer !== undefined) {
            if (referer !== undefined && referer !== options.referer)
                throw new Error('"referer" is already specified as extra HTTP header');
            referer = options.referer;
        }
        url = helper_1.helper.completeUserURL(url);
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const disposer = new Disposer();
        const timeoutPromise = disposer.add(createTimeoutPromise(timeout));
        const frameDestroyedPromise = this._createFrameDestroyedPromise();
        const sameDocumentPromise = disposer.add(this._waitForSameDocumentNavigation());
        const requestWatcher = disposer.add(this._trackDocumentRequests());
        let navigateResult;
        const navigate = async () => {
            try {
                navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
            }
            catch (error) {
                return error;
            }
        };
        throwIfError(await Promise.race([
            navigate(),
            timeoutPromise,
            frameDestroyedPromise,
        ]));
        const promises = [timeoutPromise, frameDestroyedPromise];
        if (navigateResult.newDocumentId)
            promises.push(disposer.add(this._waitForSpecificDocument(navigateResult.newDocumentId)));
        else
            promises.push(sameDocumentPromise);
        throwIfError(await Promise.race(promises));
        const request = (navigateResult && navigateResult.newDocumentId) ? requestWatcher.get(navigateResult.newDocumentId) : null;
        const waitForLifecyclePromise = disposer.add(this._waitForLifecycle(options.waitUntil));
        throwIfError(await Promise.race([timeoutPromise, frameDestroyedPromise, waitForLifecyclePromise]));
        disposer.dispose();
        return request ? request._finalRequest._waitForResponse() : null;
        function throwIfError(error) {
            if (!error)
                return;
            disposer.dispose();
            const message = `While navigating to ${url}: ${error.message}`;
            if (error instanceof errors_1.TimeoutError)
                throw new errors_1.TimeoutError(message);
            throw new Error(message);
        }
    }
    async waitForNavigation(options = {}) {
        const disposer = new Disposer();
        const requestWatcher = disposer.add(this._trackDocumentRequests());
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const failurePromise = Promise.race([
            this._createFrameDestroyedPromise(),
            disposer.add(createTimeoutPromise(timeout)),
        ]);
        let documentId = null;
        let error = await Promise.race([
            failurePromise,
            disposer.add(this._waitForNewDocument(options.url)).then(result => {
                if (result.error)
                    return result.error;
                documentId = result.documentId;
            }),
            disposer.add(this._waitForSameDocumentNavigation(options.url)),
        ]);
        const request = requestWatcher.get(documentId);
        if (!error) {
            error = await Promise.race([
                failurePromise,
                disposer.add(this._waitForLifecycle(options.waitUntil)),
            ]);
        }
        disposer.dispose();
        if (error)
            throw error;
        return request ? request._finalRequest._waitForResponse() : null;
    }
    async waitForLoadState(options = {}) {
        const { timeout = this._page._timeoutSettings.navigationTimeout() } = options;
        const disposer = new Disposer();
        const error = await Promise.race([
            this._createFrameDestroyedPromise(),
            disposer.add(createTimeoutPromise(timeout)),
            disposer.add(this._waitForLifecycle(options.waitUntil)),
        ]);
        disposer.dispose();
        if (error)
            throw error;
    }
    _waitForSpecificDocument(expectedDocumentId) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = (documentId, error) => {
            if (documentId !== expectedDocumentId)
                return resolve(new Error('Navigation interrupted by another one'));
            resolve(error);
        };
        const dispose = () => this._documentWatchers.delete(watch);
        this._documentWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForNewDocument(url) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = (documentId, error) => {
            if (!error && !platform.urlMatches(this.url(), url))
                return;
            resolve({ error, documentId });
        };
        const dispose = () => this._documentWatchers.delete(watch);
        this._documentWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForSameDocumentNavigation(url) {
        let resolve;
        const promise = new Promise(x => resolve = x);
        const watch = () => {
            if (platform.urlMatches(this.url(), url))
                resolve();
        };
        const dispose = () => this._sameDocumentNavigationWatchers.delete(watch);
        this._sameDocumentNavigationWatchers.add(watch);
        return { value: promise, dispose };
    }
    _waitForLifecycle(waitUntil = 'load') {
        let resolve;
        const expectedLifecycle = typeof waitUntil === 'string' ? [waitUntil] : waitUntil;
        for (const event of expectedLifecycle) {
            if (!kLifecycleEvents.has(event))
                throw new Error(`Unsupported waitUntil option ${String(event)}`);
        }
        const checkLifecycleComplete = () => {
            if (!checkLifecycleRecursively(this))
                return;
            resolve();
        };
        const promise = new Promise(x => resolve = x);
        const dispose = () => this._page._frameManager._lifecycleWatchers.delete(checkLifecycleComplete);
        this._page._frameManager._lifecycleWatchers.add(checkLifecycleComplete);
        checkLifecycleComplete();
        return { value: promise, dispose };
        function checkLifecycleRecursively(frame) {
            for (const event of expectedLifecycle) {
                if (!frame._firedLifecycleEvents.has(event))
                    return false;
            }
            for (const child of frame.childFrames()) {
                if (!checkLifecycleRecursively(child))
                    return false;
            }
            return true;
        }
    }
    _trackDocumentRequests() {
        const requestMap = new Map();
        const dispose = () => {
            this._requestWatchers.delete(onRequest);
        };
        const onRequest = (request) => {
            if (!request._documentId || request.redirectChain().length)
                return;
            requestMap.set(request._documentId, request);
        };
        this._requestWatchers.add(onRequest);
        return { dispose, value: requestMap };
    }
    _createFrameDestroyedPromise() {
        return Promise.race([
            this._page._disconnectedPromise.then(() => new Error('Navigation failed because browser has disconnected!')),
            this._detachedPromise.then(() => new Error('Navigating frame was detached!')),
        ]);
    }
    async frameElement() {
        return this._page._delegate.getFrameElement(this);
    }
    _context(contextType) {
        if (this._detached)
            throw new Error(`Execution Context is not available in detached frame "${this.url()}" (are you trying to evaluate?)`);
        return this._contextData.get(contextType).contextPromise;
    }
    _mainContext() {
        return this._context('main');
    }
    _utilityContext() {
        return this._context('utility');
    }
    async $(selector) {
        const utilityContext = await this._utilityContext();
        const mainContext = await this._mainContext();
        const handle = await utilityContext._$(selector);
        if (handle && handle._context !== mainContext) {
            const adopted = this._page._delegate.adoptElementHandle(handle, mainContext);
            await handle.dispose();
            return adopted;
        }
        return handle;
    }
    async waitForSelector(selector, options) {
        const { timeout = this._page._timeoutSettings.timeout(), visibility = 'any' } = (options || {});
        const handle = await this._waitForSelectorInUtilityContext(selector, visibility, timeout);
        const mainContext = await this._mainContext();
        if (handle && handle._context !== mainContext) {
            const adopted = this._page._delegate.adoptElementHandle(handle, mainContext);
            await handle.dispose();
            return adopted;
        }
        return handle;
    }
    async $wait(selector, options) {
        return this.waitForSelector(selector, options);
    }
    async $$(selector) {
        const context = await this._mainContext();
        return context._$$(selector);
    }
    async content() {
        const context = await this._utilityContext();
        return context.evaluate(() => {
            let retVal = '';
            if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
                retVal += document.documentElement.outerHTML;
            return retVal;
        });
    }
    async setContent(html, options) {
        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
        const context = await this._utilityContext();
        const lifecyclePromise = new Promise(resolve => {
            this._page._frameManager._consoleMessageTags.set(tag, () => {
                // Clear lifecycle right after document.open() - see 'tag' below.
                this._page._frameManager.clearFrameLifecycle(this);
                resolve(this.waitForLoadState(options));
            });
        });
        const contentPromise = context.evaluate((html, tag) => {
            window.stop();
            document.open();
            console.debug(tag); // eslint-disable-line no-console
            document.write(html);
            document.close();
        }, html, tag);
        await Promise.all([contentPromise, lifecyclePromise]);
    }
    name() {
        return this._name || '';
    }
    url() {
        return this._url;
    }
    parentFrame() {
        return this._parentFrame;
    }
    childFrames() {
        return Array.from(this._childFrames);
    }
    isDetached() {
        return this._detached;
    }
    async addScriptTag(options) {
        const { url = null, path = null, content = null, type = '' } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();
            if (path !== null) {
                let contents = await platform.readFileAsync(path, 'utf8');
                contents += '//# sourceURL=' + path.replace(/\n/g, '');
                return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();
            }
            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();
        });
        async function addScriptUrl(url, type) {
            const script = document.createElement('script');
            script.src = url;
            if (type)
                script.type = type;
            const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = rej;
            });
            document.head.appendChild(script);
            await promise;
            return script;
        }
        function addScriptContent(content, type = 'text/javascript') {
            const script = document.createElement('script');
            script.type = type;
            script.text = content;
            let error = null;
            script.onerror = e => error = e;
            document.head.appendChild(script);
            if (error)
                throw error;
            return script;
        }
    }
    async addStyleTag(options) {
        const { url = null, path = null, content = null } = options;
        if (!url && !path && !content)
            throw new Error('Provide an object with a `url`, `path` or `content` property');
        const context = await this._mainContext();
        return this._raceWithCSPError(async () => {
            if (url !== null)
                return (await context.evaluateHandle(addStyleUrl, url)).asElement();
            if (path !== null) {
                let contents = await platform.readFileAsync(path, 'utf8');
                contents += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
                return (await context.evaluateHandle(addStyleContent, contents)).asElement();
            }
            return (await context.evaluateHandle(addStyleContent, content)).asElement();
        });
        async function addStyleUrl(url) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = url;
            const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
            });
            document.head.appendChild(link);
            await promise;
            return link;
        }
        async function addStyleContent(content) {
            const style = document.createElement('style');
            style.type = 'text/css';
            style.appendChild(document.createTextNode(content));
            const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
            });
            document.head.appendChild(style);
            await promise;
            return style;
        }
    }
    async _raceWithCSPError(func) {
        const listeners = [];
        let result;
        let error;
        let cspMessage;
        const actionPromise = new Promise(async (resolve) => {
            try {
                result = await func();
            }
            catch (e) {
                error = e;
            }
            resolve();
        });
        const errorPromise = new Promise(resolve => {
            listeners.push(helper_1.helper.addEventListener(this._page, events_1.Events.Page.Console, (message) => {
                if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
                    cspMessage = message;
                    resolve();
                }
            }));
        });
        await Promise.race([actionPromise, errorPromise]);
        helper_1.helper.removeEventListeners(listeners);
        if (cspMessage)
            throw new Error(cspMessage.text());
        if (error)
            throw error;
        return result;
    }
    async click(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.click(options);
        await handle.dispose();
    }
    async dblclick(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.dblclick(options);
        await handle.dispose();
    }
    async tripleclick(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.tripleclick(options);
        await handle.dispose();
    }
    async fill(selector, value, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.fill(value);
        await handle.dispose();
    }
    async focus(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.focus();
        await handle.dispose();
    }
    async hover(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.hover(options);
        await handle.dispose();
    }
    async select(selector, value, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        const values = value === undefined ? [] : Array.isArray(value) ? value : [value];
        const result = await handle.select(...values);
        await handle.dispose();
        return result;
    }
    async type(selector, text, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.type(text, options);
        await handle.dispose();
    }
    async check(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.check();
        await handle.dispose();
    }
    async uncheck(selector, options) {
        const handle = await this._optionallyWaitForSelectorInUtilityContext(selector, options);
        await handle.uncheck();
        await handle.dispose();
    }
    async waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        if (helper_1.helper.isString(selectorOrFunctionOrTimeout))
            return this.waitForSelector(selectorOrFunctionOrTimeout, options);
        if (helper_1.helper.isNumber(selectorOrFunctionOrTimeout))
            return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === 'function')
            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error('Unsupported target type: ' + (typeof selectorOrFunctionOrTimeout)));
    }
    async _optionallyWaitForSelectorInUtilityContext(selector, options) {
        const { timeout = this._page._timeoutSettings.timeout(), waitFor = 'visible' } = (options || {});
        let handle;
        if (waitFor !== 'nowait') {
            const maybeHandle = await this._waitForSelectorInUtilityContext(selector, waitFor, timeout);
            if (!maybeHandle)
                throw new Error('No node found for selector: ' + selectorToString(selector, waitFor));
            handle = maybeHandle;
        }
        else {
            const context = await this._context('utility');
            const maybeHandle = await context._$(selector);
            helper_1.assert(maybeHandle, 'No node found for selector: ' + selector);
            handle = maybeHandle;
        }
        return handle;
    }
    async _waitForSelectorInUtilityContext(selector, waitFor, timeout) {
        let visibility = 'any';
        if (waitFor === 'visible' || waitFor === 'hidden' || waitFor === 'any')
            visibility = waitFor;
        else
            throw new Error(`Unsupported waitFor option "${waitFor}"`);
        const task = dom.waitForSelectorTask(selector, visibility, timeout);
        const result = await this._scheduleRerunnableTask(task, 'utility', timeout, `selector "${selectorToString(selector, visibility)}"`);
        if (!result.asElement()) {
            await result.dispose();
            return null;
        }
        return result.asElement();
    }
    async waitForFunction(pageFunction, options, ...args) {
        options = { timeout: this._page._timeoutSettings.timeout(), ...(options || {}) };
        const task = dom.waitForFunctionTask(undefined, pageFunction, options, ...args);
        return this._scheduleRerunnableTask(task, 'main', options.timeout);
    }
    async title() {
        const context = await this._utilityContext();
        return context.evaluate(() => document.title);
    }
    _onDetached() {
        this._detached = true;
        this._detachedCallback();
        for (const data of this._contextData.values()) {
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
        }
        if (this._parentFrame)
            this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
    }
    _scheduleRerunnableTask(task, contextType, timeout, title) {
        const data = this._contextData.get(contextType);
        const rerunnableTask = new RerunnableTask(data, task, timeout, title);
        data.rerunnableTasks.add(rerunnableTask);
        if (data.context)
            rerunnableTask.rerun(data.context);
        return rerunnableTask.promise;
    }
    _setContext(contextType, context) {
        const data = this._contextData.get(contextType);
        data.context = context;
        if (context) {
            data.contextResolveCallback.call(null, context);
            for (const rerunnableTask of data.rerunnableTasks)
                rerunnableTask.rerun(context);
        }
        else {
            data.contextPromise = new Promise(fulfill => {
                data.contextResolveCallback = fulfill;
            });
        }
    }
    _contextCreated(contextType, context) {
        const data = this._contextData.get(contextType);
        // In case of multiple sessions to the same target, there's a race between
        // connections so we might end up creating multiple isolated worlds.
        // We can use either.
        if (data.context)
            this._setContext(contextType, null);
        this._setContext(contextType, context);
    }
    _contextDestroyed(context) {
        for (const [contextType, data] of this._contextData) {
            if (data.context === context)
                this._setContext(contextType, null);
        }
    }
}
exports.Frame = Frame;
class RerunnableTask {
    constructor(data, task, timeout, title) {
        this._resolve = () => { };
        this._reject = () => { };
        this._terminated = false;
        this._contextData = data;
        this._task = task;
        this._runCount = 0;
        this.promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        // Since page navigation requires us to re-install the pageScript, we should track
        // timeout on our end.
        if (timeout) {
            const timeoutError = new errors_1.TimeoutError(`waiting for ${title || 'function'} failed: timeout ${timeout}ms exceeded`);
            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);
        }
    }
    terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._doCleanup();
    }
    async rerun(context) {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        try {
            success = await this._task(context);
        }
        catch (e) {
            error = e;
        }
        if (this._terminated || runCount !== this._runCount) {
            if (success)
                await success.dispose();
            return;
        }
        // Ignore timeouts in pageScript - we track timeouts ourselves.
        // If execution context has been already destroyed, `context.evaluate` will
        // throw an error - ignore this predicate run altogether.
        if (!error && await context.evaluate(s => !s, success).catch(e => true)) {
            await success.dispose();
            return;
        }
        // When the page is navigated, the promise is rejected.
        // We will try again in the new execution context.
        if (error && error.message.includes('Execution context was destroyed'))
            return;
        // We could have tried to evaluate in a context which was already
        // destroyed.
        if (error && error.message.includes('Cannot find context with specified id'))
            return;
        if (error)
            this._reject(error);
        else
            this._resolve(success);
        this._doCleanup();
    }
    _doCleanup() {
        if (this._timeoutTimer)
            clearTimeout(this._timeoutTimer);
        this._contextData.rerunnableTasks.delete(this);
    }
}
class Disposer {
    constructor() {
        this._disposes = [];
    }
    add({ value, dispose }) {
        this._disposes.push(dispose);
        return value;
    }
    dispose() {
        for (const dispose of this._disposes)
            dispose();
        this._disposes = [];
    }
}
function createTimeoutPromise(timeout) {
    if (!timeout)
        return { value: new Promise(() => { }), dispose: () => void 0 };
    let timer;
    const errorMessage = 'Navigation timeout of ' + timeout + ' ms exceeded';
    const promise = new Promise(fulfill => timer = setTimeout(fulfill, timeout))
        .then(() => new errors_1.TimeoutError(errorMessage));
    const dispose = () => {
        clearTimeout(timer);
    };
    return {
        value: promise,
        dispose
    };
}
function selectorToString(selector, visibility) {
    let label;
    switch (visibility) {
        case 'visible':
            label = '[visible] ';
            break;
        case 'hidden':
            label = '[hidden] ';
            break;
        case 'any':
        case undefined:
            label = '';
            break;
    }
    return `${label}${selector}`;
}
//# sourceMappingURL=frames.js.map