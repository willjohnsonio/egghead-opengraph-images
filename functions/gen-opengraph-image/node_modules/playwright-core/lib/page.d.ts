/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as dom from './dom';
import * as frames from './frames';
import * as input from './input';
import * as js from './javascript';
import * as network from './network';
import { Screenshotter } from './screenshotter';
import { TimeoutSettings } from './timeoutSettings';
import * as types from './types';
import { BrowserContext } from './browserContext';
import { ConsoleMessageLocation } from './console';
import * as accessibility from './accessibility';
import * as platform from './platform';
export interface PageDelegate {
    readonly rawMouse: input.RawMouse;
    readonly rawKeyboard: input.RawKeyboard;
    opener(): Promise<Page | null>;
    reload(): Promise<void>;
    goBack(): Promise<boolean>;
    goForward(): Promise<boolean>;
    exposeBinding(name: string, bindingFunction: string): Promise<void>;
    evaluateOnNewDocument(source: string): Promise<void>;
    closePage(runBeforeUnload: boolean): Promise<void>;
    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;
    setExtraHTTPHeaders(extraHTTPHeaders: network.Headers): Promise<void>;
    setViewportSize(viewportSize: types.Size): Promise<void>;
    setEmulateMedia(mediaType: types.MediaType | null, colorScheme: types.ColorScheme | null): Promise<void>;
    setCacheEnabled(enabled: boolean): Promise<void>;
    setRequestInterception(enabled: boolean): Promise<void>;
    setOfflineMode(enabled: boolean): Promise<void>;
    authenticate(credentials: types.Credentials | null): Promise<void>;
    setFileChooserIntercepted(enabled: boolean): Promise<void>;
    getBoundingBoxForScreenshot(handle: dom.ElementHandle<Node>): Promise<types.Rect | null>;
    canScreenshotOutsideViewport(): boolean;
    setBackgroundColor(color?: {
        r: number;
        g: number;
        b: number;
        a: number;
    }): Promise<void>;
    takeScreenshot(format: string, options: types.ScreenshotOptions, viewportSize: types.Size): Promise<platform.BufferType>;
    resetViewport(oldSize: types.Size): Promise<void>;
    isElementHandle(remoteObject: any): boolean;
    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;
    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;
    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;
    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;
    layoutViewport(): Promise<{
        width: number;
        height: number;
    }>;
    setInputFiles(handle: dom.ElementHandle<HTMLInputElement>, files: types.FilePayload[]): Promise<void>;
    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;
    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;
    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<void>;
    getAccessibilityTree(needle?: dom.ElementHandle): Promise<{
        tree: accessibility.AXNode;
        needle: accessibility.AXNode | null;
    }>;
    pdf?: (options?: types.PDFOptions) => Promise<platform.BufferType>;
    coverage?: () => any;
}
declare type PageState = {
    viewportSize: types.Size | null;
    mediaType: types.MediaType | null;
    colorScheme: types.ColorScheme | null;
    extraHTTPHeaders: network.Headers | null;
    cacheEnabled: boolean | null;
    interceptNetwork: boolean | null;
    offlineMode: boolean | null;
    credentials: types.Credentials | null;
    hasTouch: boolean | null;
};
export declare type FileChooser = {
    element: dom.ElementHandle;
    multiple: boolean;
};
export declare class Page extends platform.EventEmitter {
    private _closed;
    private _closedCallback;
    private _closedPromise;
    private _disconnected;
    private _disconnectedCallback;
    readonly _disconnectedPromise: Promise<Error>;
    private _browserContext;
    readonly keyboard: input.Keyboard;
    readonly mouse: input.Mouse;
    readonly _timeoutSettings: TimeoutSettings;
    readonly _delegate: PageDelegate;
    readonly _state: PageState;
    private _pageBindings;
    readonly _screenshotter: Screenshotter;
    readonly _frameManager: frames.FrameManager;
    readonly accessibility: accessibility.Accessibility;
    private _workers;
    readonly pdf: ((options?: types.PDFOptions) => Promise<platform.BufferType>) | undefined;
    readonly coverage: any;
    readonly _requestHandlers: {
        url: types.URLMatch;
        handler: (request: network.Request) => void;
    }[];
    _ownedContext: BrowserContext | undefined;
    constructor(delegate: PageDelegate, browserContext: BrowserContext);
    _didClose(): void;
    _didCrash(): void;
    _didDisconnect(): void;
    _onFileChooserOpened(handle: dom.ElementHandle): Promise<void>;
    context(): BrowserContext;
    opener(): Promise<Page | null>;
    mainFrame(): frames.Frame;
    frames(): frames.Frame[];
    setDefaultNavigationTimeout(timeout: number): void;
    setDefaultTimeout(timeout: number): void;
    $(selector: string): Promise<dom.ElementHandle<Element> | null>;
    waitForSelector(selector: string, options?: types.TimeoutOptions & {
        visibility?: types.Visibility;
    }): Promise<dom.ElementHandle<Element> | null>;
    $wait(selector: string, options?: types.TimeoutOptions & {
        visibility?: types.Visibility;
    }): Promise<dom.ElementHandle<Element> | null>;
    evaluateHandle: types.EvaluateHandle;
    $eval: types.$Eval;
    $$eval: types.$$Eval;
    $$(selector: string): Promise<dom.ElementHandle<Element>[]>;
    addScriptTag(options: {
        url?: string;
        path?: string;
        content?: string;
        type?: string;
    }): Promise<dom.ElementHandle>;
    addStyleTag(options: {
        url?: string;
        path?: string;
        content?: string;
    }): Promise<dom.ElementHandle>;
    exposeFunction(name: string, playwrightFunction: Function): Promise<void>;
    setExtraHTTPHeaders(headers: network.Headers): Promise<void>;
    _onBindingCalled(payload: string, context: js.ExecutionContext): Promise<void>;
    _addConsoleMessage(type: string, args: js.JSHandle[], location: ConsoleMessageLocation, text?: string): void;
    url(): string;
    content(): Promise<string>;
    setContent(html: string, options?: frames.NavigateOptions): Promise<void>;
    goto(url: string, options?: frames.GotoOptions): Promise<network.Response | null>;
    reload(options?: frames.NavigateOptions): Promise<network.Response | null>;
    waitForNavigation(options?: frames.WaitForNavigationOptions): Promise<network.Response | null>;
    waitForLoadState(options?: frames.NavigateOptions): Promise<void>;
    waitForEvent(event: string, optionsOrPredicate?: Function | (types.TimeoutOptions & {
        predicate?: Function;
    })): Promise<any>;
    waitForRequest(urlOrPredicate: string | RegExp | ((r: network.Request) => boolean), options?: types.TimeoutOptions): Promise<network.Request>;
    waitForResponse(urlOrPredicate: string | RegExp | ((r: network.Response) => boolean), options?: types.TimeoutOptions): Promise<network.Response>;
    goBack(options?: frames.NavigateOptions): Promise<network.Response | null>;
    goForward(options?: frames.NavigateOptions): Promise<network.Response | null>;
    emulateMedia(options: {
        media?: types.MediaType;
        colorScheme?: types.ColorScheme;
    }): Promise<void>;
    setViewportSize(viewportSize: types.Size): Promise<void>;
    viewportSize(): types.Size | null;
    evaluate: types.Evaluate;
    evaluateOnNewDocument(pageFunction: Function | string, ...args: any[]): Promise<void>;
    setCacheEnabled(enabled?: boolean): Promise<void>;
    route(url: types.URLMatch, handler: (request: network.Request) => void): Promise<void>;
    _requestStarted(request: network.Request): void;
    setOfflineMode(enabled: boolean): Promise<void>;
    authenticate(credentials: types.Credentials | null): Promise<void>;
    screenshot(options?: types.ScreenshotOptions): Promise<platform.BufferType>;
    title(): Promise<string>;
    close(options?: {
        runBeforeUnload: (boolean | undefined);
    }): Promise<void>;
    isClosed(): boolean;
    click(selector: string, options?: frames.WaitForOptions & input.ClickOptions): Promise<void>;
    dblclick(selector: string, options?: frames.WaitForOptions & input.MultiClickOptions): Promise<void>;
    tripleclick(selector: string, options?: frames.WaitForOptions & input.MultiClickOptions): Promise<void>;
    fill(selector: string, value: string, options?: frames.WaitForOptions): Promise<void>;
    focus(selector: string, options?: frames.WaitForOptions): Promise<void>;
    hover(selector: string, options?: frames.WaitForOptions & input.PointerActionOptions): Promise<void>;
    select(selector: string, value: string | dom.ElementHandle | types.SelectOption | string[] | dom.ElementHandle[] | types.SelectOption[] | undefined, options?: frames.WaitForOptions): Promise<string[]>;
    type(selector: string, text: string, options?: frames.WaitForOptions & {
        delay?: number;
    }): Promise<void>;
    check(selector: string, options?: frames.WaitForOptions): Promise<void>;
    uncheck(selector: string, options?: frames.WaitForOptions): Promise<void>;
    waitFor(selectorOrFunctionOrTimeout: (string | number | Function), options?: types.WaitForFunctionOptions & {
        visibility?: types.Visibility;
    }, ...args: any[]): Promise<js.JSHandle | null>;
    waitForFunction(pageFunction: Function | string, options?: types.WaitForFunctionOptions, ...args: any[]): Promise<js.JSHandle>;
    workers(): Worker[];
    _addWorker(workerId: string, worker: Worker): void;
    _removeWorker(workerId: string): void;
    _clearWorkers(): void;
    on(event: string | symbol, listener: platform.Listener): this;
    removeListener(event: string | symbol, listener: platform.Listener): this;
}
export declare class Worker {
    private _url;
    private _executionContextPromise;
    private _executionContextCallback;
    _existingExecutionContext: js.ExecutionContext | null;
    constructor(url: string);
    _createExecutionContext(delegate: js.ExecutionContextDelegate): void;
    url(): string;
    evaluate: types.Evaluate;
    evaluateHandle: types.EvaluateHandle;
}
export {};
