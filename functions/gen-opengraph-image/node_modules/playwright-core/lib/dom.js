"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js = require("./javascript");
const injectedSource = require("./generated/injectedSource");
const helper_1 = require("./helper");
const platform = require("./platform");
const selectors_1 = require("./selectors");
class FrameExecutionContext extends js.ExecutionContext {
    constructor(delegate, frame) {
        super(delegate);
        this._injectedGeneration = -1;
        this.frame = frame;
    }
    async _evaluate(returnByValue, pageFunction, ...args) {
        const needsAdoption = (value) => {
            return typeof value === 'object' && value instanceof ElementHandle && value._context !== this;
        };
        if (!args.some(needsAdoption)) {
            // Only go through asynchronous calls if required.
            return this._delegate.evaluate(this, returnByValue, pageFunction, ...args);
        }
        const toDispose = [];
        const adopted = await Promise.all(args.map(async (arg) => {
            if (!needsAdoption(arg))
                return arg;
            const adopted = this.frame._page._delegate.adoptElementHandle(arg, this);
            toDispose.push(adopted);
            return adopted;
        }));
        let result;
        try {
            result = await this._delegate.evaluate(this, returnByValue, pageFunction, ...adopted);
        }
        finally {
            await Promise.all(toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose())));
        }
        return result;
    }
    _createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
            return new ElementHandle(this, remoteObject);
        return super._createHandle(remoteObject);
    }
    _injected() {
        const selectors = selectors_1.Selectors._instance();
        if (this._injectedPromise && selectors._generation !== this._injectedGeneration) {
            this._injectedPromise.then(handle => handle.dispose());
            this._injectedPromise = undefined;
        }
        if (!this._injectedPromise) {
            const source = `
        new (${injectedSource.source})([
          ${selectors._sources.join(',\n')}
        ])
      `;
            this._injectedPromise = this.evaluateHandle(source);
            this._injectedGeneration = selectors._generation;
        }
        return this._injectedPromise;
    }
    async _$(selector, scope) {
        const handle = await this.evaluateHandle((injected, selector, scope) => injected.querySelector(selector, scope || document), await this._injected(), normalizeSelector(selector), scope);
        if (!handle.asElement())
            await handle.dispose();
        return handle.asElement();
    }
    async _$array(selector, scope) {
        const arrayHandle = await this.evaluateHandle((injected, selector, scope) => injected.querySelectorAll(selector, scope || document), await this._injected(), normalizeSelector(selector), scope);
        return arrayHandle;
    }
    async _$$(selector, scope) {
        const arrayHandle = await this._$array(selector, scope);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                result.push(elementHandle);
            else
                await property.dispose();
        }
        return result;
    }
}
exports.FrameExecutionContext = FrameExecutionContext;
class ElementHandle extends js.JSHandle {
    constructor(context, remoteObject) {
        super(context, remoteObject);
        this._evaluateInUtility = async (pageFunction, ...args) => {
            const utility = await this._context.frame._utilityContext();
            return utility.evaluate(pageFunction, this, ...args);
        };
        this.$eval = async (selector, pageFunction, ...args) => {
            const elementHandle = await this._context._$(selector, this);
            if (!elementHandle)
                throw new Error(`Error: failed to find element matching selector "${selector}"`);
            const result = await elementHandle.evaluate(pageFunction, ...args);
            await elementHandle.dispose();
            return result;
        };
        this.$$eval = async (selector, pageFunction, ...args) => {
            const arrayHandle = await this._context._$array(selector, this);
            const result = await arrayHandle.evaluate(pageFunction, ...args);
            await arrayHandle.dispose();
            return result;
        };
        this._context = context;
        this._page = context.frame._page;
    }
    asElement() {
        return this;
    }
    async ownerFrame() {
        const frameId = await this._page._delegate.getOwnerFrame(this);
        if (!frameId)
            return null;
        const pages = this._page.context()._existingPages();
        for (const page of pages) {
            const frame = page._frameManager.frame(frameId);
            if (frame)
                return frame;
        }
        return null;
    }
    async contentFrame() {
        const isFrameElement = await this._evaluateInUtility(node => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'));
        if (!isFrameElement)
            return null;
        return this._page._delegate.getContentFrame(this);
    }
    async _scrollRectIntoViewIfNeeded(rect) {
        await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
    }
    async scrollIntoViewIfNeeded() {
        await this._scrollRectIntoViewIfNeeded();
    }
    async _clickablePoint() {
        const intersectQuadWithViewport = (quad) => {
            return quad.map(point => ({
                x: Math.min(Math.max(point.x, 0), metrics.width),
                y: Math.min(Math.max(point.y, 0), metrics.height),
            }));
        };
        const computeQuadArea = (quad) => {
            // Compute sum of all directed areas of adjacent triangles
            // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
                const p1 = quad[i];
                const p2 = quad[(i + 1) % quad.length];
                area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
        };
        const [quads, metrics] = await Promise.all([
            this._page._delegate.getContentQuads(this),
            this._page._delegate.layoutViewport(),
        ]);
        if (!quads || !quads.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 1);
        if (!filtered.length)
            throw new Error('Node is either not visible or not an HTMLElement');
        // Return the middle point of the first quad.
        const result = { x: 0, y: 0 };
        for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
        }
        return result;
    }
    async _relativePoint(relativePoint) {
        const [box, border] = await Promise.all([
            this.boundingBox(),
            this._evaluateInUtility((node) => {
                if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)
                    return { x: 0, y: 0 };
                const style = node.ownerDocument.defaultView.getComputedStyle(node);
                return { x: parseInt(style.borderLeftWidth || '', 10), y: parseInt(style.borderTopWidth || '', 10) };
            }).catch(helper_1.debugError),
        ]);
        const point = { x: relativePoint.x, y: relativePoint.y };
        if (box) {
            point.x += box.x;
            point.y += box.y;
        }
        if (border) {
            // Make point relative to the padding box to align with offsetX/offsetY.
            point.x += border.x;
            point.y += border.y;
        }
        return point;
    }
    async _performPointerAction(action, options) {
        const relativePoint = options ? options.relativePoint : undefined;
        await this._scrollRectIntoViewIfNeeded(relativePoint ? { x: relativePoint.x, y: relativePoint.y, width: 0, height: 0 } : undefined);
        const point = relativePoint ? await this._relativePoint(relativePoint) : await this._clickablePoint();
        let restoreModifiers;
        if (options && options.modifiers)
            restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
        await action(point);
        if (restoreModifiers)
            await this._page.keyboard._ensureModifiers(restoreModifiers);
    }
    hover(options) {
        return this._performPointerAction(point => this._page.mouse.move(point.x, point.y), options);
    }
    click(options) {
        return this._performPointerAction(point => this._page.mouse.click(point.x, point.y, options), options);
    }
    dblclick(options) {
        return this._performPointerAction(point => this._page.mouse.dblclick(point.x, point.y, options), options);
    }
    tripleclick(options) {
        return this._performPointerAction(point => this._page.mouse.tripleclick(point.x, point.y, options), options);
    }
    async select(...values) {
        const options = values.map(value => typeof value === 'object' ? value : { value });
        for (const option of options) {
            if (option instanceof ElementHandle)
                continue;
            if (option.value !== undefined)
                helper_1.assert(helper_1.helper.isString(option.value), 'Values must be strings. Found value "' + option.value + '" of type "' + (typeof option.value) + '"');
            if (option.label !== undefined)
                helper_1.assert(helper_1.helper.isString(option.label), 'Labels must be strings. Found label "' + option.label + '" of type "' + (typeof option.label) + '"');
            if (option.index !== undefined)
                helper_1.assert(helper_1.helper.isNumber(option.index), 'Indices must be numbers. Found index "' + option.index + '" of type "' + (typeof option.index) + '"');
        }
        return this._evaluateInUtility((node, ...optionsToSelect) => {
            if (node.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const element = node;
            const options = Array.from(element.options);
            element.value = undefined;
            for (let index = 0; index < options.length; index++) {
                const option = options[index];
                option.selected = optionsToSelect.some(optionToSelect => {
                    if (optionToSelect instanceof Node)
                        return option === optionToSelect;
                    let matches = true;
                    if (optionToSelect.value !== undefined)
                        matches = matches && optionToSelect.value === option.value;
                    if (optionToSelect.label !== undefined)
                        matches = matches && optionToSelect.label === option.label;
                    if (optionToSelect.index !== undefined)
                        matches = matches && optionToSelect.index === index;
                    return matches;
                });
                if (option.selected && !element.multiple)
                    break;
            }
            element.dispatchEvent(new Event('input', { 'bubbles': true }));
            element.dispatchEvent(new Event('change', { 'bubbles': true }));
            return options.filter(option => option.selected).map(option => option.value);
        }, ...options);
    }
    async fill(value) {
        helper_1.assert(helper_1.helper.isString(value), 'Value must be string. Found value "' + value + '" of type "' + (typeof value) + '"');
        const error = await this._evaluateInUtility((node, value) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                return 'Node is not of type HTMLElement';
            const element = node;
            if (!element.isConnected)
                return 'Element is not attached to the DOM';
            if (!element.ownerDocument || !element.ownerDocument.defaultView)
                return 'Element does not belong to a window';
            const style = element.ownerDocument.defaultView.getComputedStyle(element);
            if (!style || style.visibility === 'hidden')
                return 'Element is hidden';
            if (!element.offsetParent && element.tagName !== 'BODY')
                return 'Element is not visible';
            if (element.nodeName.toLowerCase() === 'input') {
                const input = element;
                const type = input.getAttribute('type') || '';
                const kTextInputTypes = new Set(['', 'email', 'number', 'password', 'search', 'tel', 'text', 'url']);
                if (!kTextInputTypes.has(type.toLowerCase()))
                    return 'Cannot fill input of type "' + type + '".';
                if (type.toLowerCase() === 'number') {
                    value = value.trim();
                    if (!value || isNaN(Number(value)))
                        return 'Cannot type text into input[type=number].';
                }
                if (input.disabled)
                    return 'Cannot fill a disabled input.';
                if (input.readOnly)
                    return 'Cannot fill a readonly input.';
                input.select();
                input.focus();
            }
            else if (element.nodeName.toLowerCase() === 'textarea') {
                const textarea = element;
                if (textarea.disabled)
                    return 'Cannot fill a disabled textarea.';
                if (textarea.readOnly)
                    return 'Cannot fill a readonly textarea.';
                textarea.selectionStart = 0;
                textarea.selectionEnd = textarea.value.length;
                textarea.focus();
            }
            else if (element.isContentEditable) {
                const range = element.ownerDocument.createRange();
                range.selectNodeContents(element);
                const selection = element.ownerDocument.defaultView.getSelection();
                if (!selection)
                    return 'Element belongs to invisible iframe.';
                selection.removeAllRanges();
                selection.addRange(range);
                element.focus();
            }
            else {
                return 'Element is not an <input>, <textarea> or [contenteditable] element.';
            }
            return false;
        }, value);
        if (error)
            throw new Error(error);
        if (value)
            await this._page.keyboard.sendCharacters(value);
        else
            await this._page.keyboard.press('Delete');
    }
    async setInputFiles(...files) {
        const multiple = await this._evaluateInUtility((node) => {
            if (node.nodeType !== Node.ELEMENT_NODE || node.tagName !== 'INPUT')
                throw new Error('Node is not an HTMLInputElement');
            const input = node;
            return input.multiple;
        });
        helper_1.assert(multiple || files.length <= 1, 'Non-multiple file input can only accept single file!');
        const filePayloads = await Promise.all(files.map(async (item) => {
            if (typeof item === 'string') {
                const file = {
                    name: platform.basename(item),
                    type: platform.getMimeType(item),
                    data: await platform.readFileAsync(item, 'base64')
                };
                return file;
            }
            return item;
        }));
        await this._page._delegate.setInputFiles(this, filePayloads);
    }
    async focus() {
        const errorMessage = await this._evaluateInUtility((element) => {
            if (!element['focus'])
                return 'Node is not an HTML or SVG element.';
            element.focus();
            return false;
        });
        if (errorMessage)
            throw new Error(errorMessage);
    }
    async type(text, options) {
        await this.focus();
        await this._page.keyboard.type(text, options);
    }
    async press(key, options) {
        await this.focus();
        await this._page.keyboard.press(key, options);
    }
    async check() {
        await this._setChecked(true);
    }
    async uncheck() {
        await this._setChecked(false);
    }
    async _setChecked(state) {
        const isCheckboxChecked = async () => {
            return this._evaluateInUtility((node) => {
                if (node.nodeType !== Node.ELEMENT_NODE)
                    throw new Error('Not a checkbox or radio button');
                let element = node;
                if (element.getAttribute('role') === 'checkbox')
                    return element.getAttribute('aria-checked') === 'true';
                if (element.nodeName === 'LABEL') {
                    const forId = element.getAttribute('for');
                    if (forId && element.ownerDocument)
                        element = element.ownerDocument.querySelector(`input[id="${forId}"]`) || undefined;
                    else
                        element = element.querySelector('input[type=checkbox],input[type=radio]') || undefined;
                }
                if (element && element.nodeName === 'INPUT') {
                    const type = element.getAttribute('type');
                    if (type && (type.toLowerCase() === 'checkbox' || type.toLowerCase() === 'radio'))
                        return element.checked;
                }
                throw new Error('Not a checkbox');
            });
        };
        if (await isCheckboxChecked() === state)
            return;
        await this.click();
        if (await isCheckboxChecked() !== state)
            throw new Error('Unable to click checkbox');
    }
    async boundingBox() {
        return this._page._delegate.getBoundingBox(this);
    }
    async screenshot(options) {
        return this._page._screenshotter.screenshotElement(this, options);
    }
    $(selector) {
        return this._context._$(selector, this);
    }
    $$(selector) {
        return this._context._$$(selector, this);
    }
    visibleRatio() {
        return this._evaluateInUtility(async (node) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
                throw new Error('Node is not of type HTMLElement');
            const element = node;
            const visibleRatio = await new Promise(resolve => {
                const observer = new IntersectionObserver(entries => {
                    resolve(entries[0].intersectionRatio);
                    observer.disconnect();
                });
                observer.observe(element);
                // Firefox doesn't call IntersectionObserver callback unless
                // there are rafs.
                requestAnimationFrame(() => { });
            });
            return visibleRatio;
        });
    }
}
exports.ElementHandle = ElementHandle;
function normalizeSelector(selector) {
    const eqIndex = selector.indexOf('=');
    if (eqIndex !== -1 && selector.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-]+$/))
        return selector;
    // If selector starts with '//' or '//' prefixed with multiple opening
    // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
    if (/^\(*\/\//.test(selector))
        return 'xpath=' + selector;
    if (selector.startsWith('"'))
        return 'text=' + selector;
    return 'css=' + selector;
}
function waitForFunctionTask(selector, pageFunction, options, ...args) {
    const { polling = 'raf' } = options;
    if (helper_1.helper.isString(polling))
        helper_1.assert(polling === 'raf' || polling === 'mutation', 'Unknown polling option: ' + polling);
    else if (helper_1.helper.isNumber(polling))
        helper_1.assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);
    else
        throw new Error('Unknown polling options: ' + polling);
    const predicateBody = helper_1.helper.isString(pageFunction) ? 'return (' + pageFunction + ')' : 'return (' + pageFunction + ')(...args)';
    if (selector !== undefined)
        selector = normalizeSelector(selector);
    return async (context) => context.evaluateHandle((injected, selector, predicateBody, polling, timeout, ...args) => {
        const innerPredicate = new Function('...args', predicateBody);
        if (polling === 'raf')
            return injected.pollRaf(selector, predicate, timeout);
        if (polling === 'mutation')
            return injected.pollMutation(selector, predicate, timeout);
        return injected.pollInterval(selector, polling, predicate, timeout);
        function predicate(element) {
            if (selector === undefined)
                return innerPredicate(...args);
            return innerPredicate(element, ...args);
        }
    }, await context._injected(), selector, predicateBody, polling, options.timeout || 0, ...args);
}
exports.waitForFunctionTask = waitForFunctionTask;
function waitForSelectorTask(selector, visibility, timeout) {
    return async (context) => {
        selector = normalizeSelector(selector);
        return context.evaluateHandle((injected, selector, visibility, timeout) => {
            if (visibility !== 'any')
                return injected.pollRaf(selector, predicate, timeout);
            return injected.pollMutation(selector, predicate, timeout);
            function predicate(element) {
                if (!element)
                    return visibility === 'hidden';
                if (visibility === 'any')
                    return element;
                return injected.isVisible(element) === (visibility === 'visible') ? element : false;
            }
        }, await context._injected(), selector, visibility, timeout);
    };
}
exports.waitForSelectorTask = waitForSelectorTask;
exports.setFileInputFunction = async (element, payloads) => {
    const files = await Promise.all(payloads.map(async (file) => {
        const result = await fetch(`data:${file.type};base64,${file.data}`);
        return new File([await result.blob()], file.name, { type: file.type });
    }));
    const dt = new DataTransfer();
    for (const file of files)
        dt.items.add(file);
    element.files = dt.files;
    element.dispatchEvent(new Event('input', { 'bubbles': true }));
};
//# sourceMappingURL=dom.js.map