"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const dom = require("../dom");
const helper_1 = require("../helper");
const crConnection_1 = require("./crConnection");
const crExecutionContext_1 = require("./crExecutionContext");
const crNetworkManager_1 = require("./crNetworkManager");
const page_1 = require("../page");
const events_1 = require("../events");
const crProtocolHelper_1 = require("./crProtocolHelper");
const dialog = require("../dialog");
const crInput_1 = require("./crInput");
const crAccessibility_1 = require("./crAccessibility");
const crCoverage_1 = require("./crCoverage");
const crPdf_1 = require("./crPdf");
const console_1 = require("../console");
const platform = require("../platform");
const crTarget_1 = require("./crTarget");
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
class CRPage {
    constructor(client, browser, browserContext) {
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client = client;
        this._browser = browser;
        this.rawKeyboard = new crInput_1.RawKeyboardImpl(client);
        this.rawMouse = new crInput_1.RawMouseImpl(client);
        this._pdf = new crPdf_1.CRPDF(client);
        this._coverage = new crCoverage_1.CRCoverage(client);
        this._page = new page_1.Page(this, browserContext);
        this._networkManager = new crNetworkManager_1.CRNetworkManager(client, this._page);
        this._eventListeners = [
            helper_1.helper.addEventListener(client, 'Inspector.targetCrashed', event => this._onTargetCrashed()),
            helper_1.helper.addEventListener(client, 'Log.entryAdded', event => this._onLogEntryAdded(event)),
            helper_1.helper.addEventListener(client, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)),
            helper_1.helper.addEventListener(client, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)),
            helper_1.helper.addEventListener(client, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)),
            helper_1.helper.addEventListener(client, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)),
            helper_1.helper.addEventListener(client, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)),
            helper_1.helper.addEventListener(client, 'Page.javascriptDialogOpening', event => this._onDialog(event)),
            helper_1.helper.addEventListener(client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)),
            helper_1.helper.addEventListener(client, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
            helper_1.helper.addEventListener(client, 'Runtime.bindingCalled', event => this._onBindingCalled(event)),
            helper_1.helper.addEventListener(client, 'Runtime.consoleAPICalled', event => this._onConsoleAPI(event)),
            helper_1.helper.addEventListener(client, 'Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId)),
            helper_1.helper.addEventListener(client, 'Runtime.executionContextsCleared', event => this._onExecutionContextsCleared()),
            helper_1.helper.addEventListener(client, 'Target.attachedToTarget', event => this._onAttachedToTarget(event)),
            helper_1.helper.addEventListener(client, 'Target.detachedFromTarget', event => this._onDetachedFromTarget(event)),
        ];
    }
    async initialize() {
        const [, { frameTree }] = await Promise.all([
            this._client.send('Page.enable'),
            this._client.send('Page.getFrameTree'),
        ]);
        this._handleFrameTree(frameTree);
        const promises = [
            this._client.send('Log.enable', {}),
            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
            this._client.send('Runtime.enable', {}).then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
            this._networkManager.initialize(),
            this._client.send('Target.setAutoAttach', { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }),
            this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }),
        ];
        const options = this._page.context()._options;
        if (options.bypassCSP)
            promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
        if (options.ignoreHTTPSErrors)
            promises.push(this._client.send('Security.setIgnoreCertificateErrors', { ignore: true }));
        if (options.viewport)
            promises.push(this._updateViewport(true /* updateTouch */));
        if (options.javaScriptEnabled === false)
            promises.push(this._client.send('Emulation.setScriptExecutionDisabled', { value: true }));
        if (options.userAgent || options.locale)
            promises.push(this._client.send('Emulation.setUserAgentOverride', { userAgent: options.userAgent || '', acceptLanguage: options.locale }));
        if (options.timezoneId)
            promises.push(emulateTimezone(this._client, options.timezoneId));
        if (options.geolocation)
            promises.push(this._client.send('Emulation.setGeolocationOverride', options.geolocation));
        await Promise.all(promises);
    }
    didClose() {
        helper_1.helper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
    }
    async navigateFrame(frame, url, referrer) {
        const response = await this._client.send('Page.navigate', { url, referrer, frameId: frame._id });
        if (response.errorText)
            throw new Error(`${response.errorText} at ${url}`);
        return { newDocumentId: response.loaderId };
    }
    _onLifecycleEvent(event) {
        if (event.name === 'load')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');
        else if (event.name === 'DOMContentLoaded')
            this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
    }
    _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
    }
    _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
            return;
        for (const child of frameTree.childFrames)
            this._handleFrameTree(child);
    }
    page() {
        return this._page;
    }
    _onFrameAttached(frameId, parentFrameId) {
        this._page._frameManager.frameAttached(frameId, parentFrameId);
    }
    _onFrameNavigated(framePayload, initial) {
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);
    }
    async _ensureIsolatedWorld(name) {
        if (this._isolatedWorlds.has(name))
            return;
        this._isolatedWorlds.add(name);
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `//# sourceURL=${crExecutionContext_1.EVALUATION_SCRIPT_URL}`,
            worldName: name,
        });
        await Promise.all(this._page.frames().map(frame => this._client.send('Page.createIsolatedWorld', {
            frameId: frame._id,
            grantUniveralAccess: true,
            worldName: name,
        }).catch(helper_1.debugError))); // frames might be removed before we send this
    }
    _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
    }
    _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
    }
    _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame)
            return;
        if (contextPayload.auxData && contextPayload.auxData.type === 'isolated')
            this._isolatedWorlds.add(contextPayload.name);
        const delegate = new crExecutionContext_1.CRExecutionContext(this._client, contextPayload);
        const context = new dom.FrameExecutionContext(delegate, frame);
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
            frame._contextCreated('main', context);
        else if (contextPayload.name === UTILITY_WORLD_NAME)
            frame._contextCreated('utility', context);
        this._contextIdToContext.set(contextPayload.id, context);
    }
    _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
            return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
    }
    _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
            this._onExecutionContextDestroyed(contextId);
    }
    _onAttachedToTarget(event) {
        const session = crConnection_1.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type !== 'worker') {
            // Ideally, detaching should resume any target, but there is a bug in the backend.
            session.send('Runtime.runIfWaitingForDebugger').catch(helper_1.debugError).then(() => {
                this._client.send('Target.detachFromTarget', { sessionId: event.sessionId }).catch(helper_1.debugError);
            });
            return;
        }
        const url = event.targetInfo.url;
        const worker = new page_1.Worker(url);
        this._page._addWorker(event.sessionId, worker);
        session.once('Runtime.executionContextCreated', async (event) => {
            worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
        });
        Promise.all([
            session.send('Runtime.enable'),
            session.send('Network.enable'),
            session.send('Runtime.runIfWaitingForDebugger'),
        ]).catch(helper_1.debugError); // This might fail if the target is closed before we initialize.
        session.on('Runtime.consoleAPICalled', event => {
            const args = event.args.map(o => worker._existingExecutionContext._createHandle(o));
            this._page._addConsoleMessage(event.type, args, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
        });
        session.on('Runtime.exceptionThrown', exception => this._page.emit(events_1.Events.Page.PageError, crProtocolHelper_1.exceptionToError(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session);
    }
    _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
    }
    async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Playwright clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/GoogleChrome/puppeteer/issues/3865
            return;
        }
        const context = this._contextIdToContext.get(event.executionContextId);
        const values = event.args.map(arg => context._createHandle(arg));
        this._page._addConsoleMessage(event.type, values, crProtocolHelper_1.toConsoleMessageLocation(event.stackTrace));
    }
    async exposeBinding(name, bindingFunction) {
        await this._client.send('Runtime.addBinding', { name: name });
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: bindingFunction });
        await Promise.all(this._page.frames().map(frame => frame.evaluate(bindingFunction).catch(helper_1.debugError)));
    }
    _onBindingCalled(event) {
        const context = this._contextIdToContext.get(event.executionContextId);
        this._page._onBindingCalled(event.payload, context);
    }
    _onDialog(event) {
        this._page.emit(events_1.Events.Page.Dialog, new dialog.Dialog(event.type, event.message, async (accept, promptText) => {
            await this._client.send('Page.handleJavaScriptDialog', { accept, promptText });
        }, event.defaultPrompt));
    }
    _handleException(exceptionDetails) {
        this._page.emit(events_1.Events.Page.PageError, crProtocolHelper_1.exceptionToError(exceptionDetails));
    }
    _onTargetCrashed() {
        this._page._didCrash();
    }
    _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
            args.map(arg => crProtocolHelper_1.releaseObject(this._client, arg));
        if (source !== 'worker')
            this._page.emit(events_1.Events.Page.Console, new console_1.ConsoleMessage(level, text, [], { url, lineNumber }));
    }
    async _onFileChooserOpened(event) {
        const frame = this._page._frameManager.frame(event.frameId);
        const utilityContext = await frame._utilityContext();
        const handle = await this.adoptBackendNodeId(event.backendNodeId, utilityContext);
        this._page._onFileChooserOpened(handle);
    }
    async setExtraHTTPHeaders(headers) {
        await this._client.send('Network.setExtraHTTPHeaders', { headers });
    }
    async setViewportSize(viewportSize) {
        helper_1.assert(this._page._state.viewportSize === viewportSize);
        await this._updateViewport(false /* updateTouch */);
    }
    async _updateViewport(updateTouch) {
        let viewport = this._page.context()._options.viewport || { width: 0, height: 0 };
        const viewportSize = this._page._state.viewportSize;
        if (viewportSize)
            viewport = { ...viewport, ...viewportSize };
        const isLandscape = viewport.width > viewport.height;
        const promises = [
            this._client.send('Emulation.setDeviceMetricsOverride', {
                mobile: !!viewport.isMobile,
                width: viewport.width,
                height: viewport.height,
                deviceScaleFactor: viewport.deviceScaleFactor || 1,
                screenOrientation: isLandscape ? { angle: 90, type: 'landscapePrimary' } : { angle: 0, type: 'portraitPrimary' },
            }),
        ];
        if (updateTouch)
            promises.push(this._client.send('Emulation.setTouchEmulationEnabled', { enabled: !!viewport.isMobile }));
        await Promise.all(promises);
    }
    async setEmulateMedia(mediaType, colorScheme) {
        const features = colorScheme ? [{ name: 'prefers-color-scheme', value: colorScheme }] : [];
        await this._client.send('Emulation.setEmulatedMedia', { media: mediaType || '', features });
    }
    setCacheEnabled(enabled) {
        return this._networkManager.setCacheEnabled(enabled);
    }
    async setRequestInterception(enabled) {
        await this._networkManager.setRequestInterception(enabled);
    }
    async setOfflineMode(value) {
        await this._networkManager.setOfflineMode(value);
    }
    async authenticate(credentials) {
        await this._networkManager.authenticate(credentials);
    }
    async setFileChooserIntercepted(enabled) {
        await this._client.send('Page.setInterceptFileChooserDialog', { enabled }).catch(e => { }); // target can be closed.
    }
    async opener() {
        const openerTarget = crTarget_1.CRTarget.fromPage(this._page).opener();
        if (!openerTarget)
            return null;
        return await openerTarget.page();
    }
    async reload() {
        await this._client.send('Page.reload');
    }
    async _go(delta) {
        const history = await this._client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
            return false;
        await this._client.send('Page.navigateToHistoryEntry', { entryId: entry.id });
        return true;
    }
    goBack() {
        return this._go(-1);
    }
    goForward() {
        return this._go(+1);
    }
    async evaluateOnNewDocument(source) {
        await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source });
    }
    async closePage(runBeforeUnload) {
        if (runBeforeUnload)
            await this._client.send('Page.close');
        else
            await this._browser._closePage(this._page);
    }
    async getBoundingBoxForScreenshot(handle) {
        const rect = await handle.boundingBox();
        if (!rect)
            return rect;
        const { layoutViewport: { pageX, pageY } } = await this._client.send('Page.getLayoutMetrics');
        rect.x += pageX;
        rect.y += pageY;
        return rect;
    }
    canScreenshotOutsideViewport() {
        return false;
    }
    async setBackgroundColor(color) {
        await this._client.send('Emulation.setDefaultBackgroundColorOverride', { color });
    }
    async takeScreenshot(format, options, viewportSize) {
        await this._client.send('Page.bringToFront', {});
        const clip = options.clip ? { ...options.clip, scale: 1 } : undefined;
        const result = await this._client.send('Page.captureScreenshot', { format, quality: options.quality, clip });
        return platform.Buffer.from(result.data, 'base64');
    }
    async resetViewport() {
        await this._client.send('Emulation.setDeviceMetricsOverride', { mobile: false, width: 0, height: 0, deviceScaleFactor: 0 });
    }
    async getContentFrame(handle) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId
        });
        if (!nodeInfo || typeof nodeInfo.node.frameId !== 'string')
            return null;
        return this._page._frameManager.frame(nodeInfo.node.frameId);
    }
    async getOwnerFrame(handle) {
        // document.documentElement has frameId of the owner frame.
        const documentElement = await handle.evaluateHandle(node => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
                return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
        });
        if (!documentElement)
            return null;
        const remoteObject = toRemoteObject(documentElement);
        if (!remoteObject.objectId)
            return null;
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: remoteObject.objectId
        });
        const frameId = nodeInfo && typeof nodeInfo.node.frameId === 'string' ?
            nodeInfo.node.frameId : null;
        await documentElement.dispose();
        return frameId;
    }
    isElementHandle(remoteObject) {
        return remoteObject.subtype === 'node';
    }
    async getBoundingBox(handle) {
        const result = await this._client.send('DOM.getBoxModel', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x, y, width, height };
    }
    async scrollRectIntoViewIfNeeded(handle, rect) {
        await this._client.send('DOM.scrollIntoViewIfNeeded', {
            objectId: toRemoteObject(handle).objectId,
            rect,
        }).catch(e => {
            if (e instanceof Error && e.message.includes('Node does not have a layout object'))
                e.message = 'Node is either not visible or not an HTMLElement';
            throw e;
        });
    }
    async getContentQuads(handle) {
        const result = await this._client.send('DOM.getContentQuads', {
            objectId: toRemoteObject(handle).objectId
        }).catch(helper_1.debugError);
        if (!result)
            return null;
        return result.quads.map(quad => [
            { x: quad[0], y: quad[1] },
            { x: quad[2], y: quad[3] },
            { x: quad[4], y: quad[5] },
            { x: quad[6], y: quad[7] }
        ]);
    }
    async layoutViewport() {
        const layoutMetrics = await this._client.send('Page.getLayoutMetrics');
        return { width: layoutMetrics.layoutViewport.clientWidth, height: layoutMetrics.layoutViewport.clientHeight };
    }
    async setInputFiles(handle, files) {
        await handle.evaluate(dom.setFileInputFunction, files);
    }
    async adoptElementHandle(handle, to) {
        const nodeInfo = await this._client.send('DOM.describeNode', {
            objectId: toRemoteObject(handle).objectId,
        });
        return this.adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
    }
    async adoptBackendNodeId(backendNodeId, to) {
        const result = await this._client.send('DOM.resolveNode', {
            backendNodeId,
            executionContextId: to._delegate._contextId,
        }).catch(helper_1.debugError);
        if (!result || result.object.subtype === 'null')
            throw new Error('Unable to adopt element handle from a different document');
        return to._createHandle(result.object).asElement();
    }
    async getAccessibilityTree(needle) {
        return crAccessibility_1.getAccessibilityTree(this._client, needle);
    }
    async pdf(options) {
        return this._pdf.generate(options);
    }
    coverage() {
        return this._coverage;
    }
    async getFrameElement(frame) {
        const { backendNodeId } = await this._client.send('DOM.getFrameOwner', { frameId: frame._id }).catch(e => {
            if (e instanceof Error && e.message.includes('Frame with the given id was not found.'))
                e.message = 'Frame has been detached.';
            throw e;
        });
        const parent = frame.parentFrame();
        if (!parent)
            throw new Error('Frame has been detached.');
        return this.adoptBackendNodeId(backendNodeId, await parent._mainContext());
    }
}
exports.CRPage = CRPage;
function toRemoteObject(handle) {
    return handle._remoteObject;
}
async function emulateTimezone(session, timezoneId) {
    try {
        await session.send('Emulation.setTimezoneOverride', { timezoneId: timezoneId });
    }
    catch (exception) {
        if (exception.message.includes('Invalid timezone'))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
        throw exception;
    }
}
//# sourceMappingURL=crPage.js.map