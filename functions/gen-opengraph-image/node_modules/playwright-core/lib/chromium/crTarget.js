"use strict";
/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crConnection_1 = require("./crConnection");
const events_1 = require("../events");
const page_1 = require("../page");
const helper_1 = require("../helper");
const crPage_1 = require("./crPage");
const crExecutionContext_1 = require("./crExecutionContext");
const targetSymbol = Symbol('target');
class CRTarget {
    constructor(browser, targetInfo, browserContext, sessionFactory) {
        this._pagePromise = null;
        this._crPage = null;
        this._workerPromise = null;
        this._initializedCallback = () => { };
        this._targetInfo = targetInfo;
        this._browser = browser;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._initializedPromise = new Promise(fulfill => this._initializedCallback = fulfill).then(async (success) => {
            if (!success)
                return false;
            const opener = this.opener();
            if (!opener || !opener._pagePromise || this.type() !== 'page')
                return true;
            const openerPage = await opener._pagePromise;
            if (!openerPage.listenerCount(events_1.Events.Page.Popup))
                return true;
            const popupPage = await this.page();
            openerPage.emit(events_1.Events.Page.Popup, popupPage);
            return true;
        });
        this._isInitialized = this._targetInfo.type !== 'page' || this._targetInfo.url !== '';
        if (this._isInitialized)
            this._initializedCallback(true);
    }
    static fromPage(page) {
        return page[targetSymbol];
    }
    _didClose() {
        if (this._crPage)
            this._crPage.didClose();
    }
    async page() {
        if ((this._targetInfo.type === 'page' || this._targetInfo.type === 'background_page') && !this._pagePromise) {
            this._pagePromise = this._sessionFactory().then(async (client) => {
                this._crPage = new crPage_1.CRPage(client, this._browser, this._browserContext);
                const page = this._crPage.page();
                page[targetSymbol] = this;
                client.once(crConnection_1.CRSessionEvents.Disconnected, () => page._didDisconnect());
                await this._crPage.initialize();
                return page;
            });
        }
        return this._pagePromise;
    }
    async _worker() {
        if (this._targetInfo.type !== 'service_worker' && this._targetInfo.type !== 'shared_worker')
            return null;
        if (!this._workerPromise) {
            // TODO(einbinder): Make workers send their console logs.
            this._workerPromise = this._sessionFactory().then(session => {
                const worker = new page_1.Worker(this._targetInfo.url);
                session.once('Runtime.executionContextCreated', async (event) => {
                    worker._createExecutionContext(new crExecutionContext_1.CRExecutionContext(session, event.context));
                });
                // This might fail if the target is closed before we recieve all execution contexts.
                session.send('Runtime.enable', {}).catch(helper_1.debugError);
                return worker;
            });
        }
        return this._workerPromise;
    }
    url() {
        return this._targetInfo.url;
    }
    type() {
        const type = this._targetInfo.type;
        if (type === 'page' || type === 'background_page' || type === 'service_worker' || type === 'shared_worker' || type === 'browser')
            return type;
        return 'other';
    }
    context() {
        return this._browserContext;
    }
    opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
            return null;
        return this._browser._targets.get(openerId);
    }
    createCDPSession() {
        return this._sessionFactory();
    }
    _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized && (this._targetInfo.type !== 'page' || this._targetInfo.url !== '')) {
            this._isInitialized = true;
            this._initializedCallback(true);
            return;
        }
    }
}
exports.CRTarget = CRTarget;
//# sourceMappingURL=crTarget.js.map