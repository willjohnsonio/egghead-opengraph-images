"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("./events");
const events_2 = require("../events");
const helper_1 = require("../helper");
const browserContext_1 = require("../browserContext");
const crConnection_1 = require("./crConnection");
const crTarget_1 = require("./crTarget");
const browser_1 = require("../browser");
const platform = require("../platform");
const crProtocolHelper_1 = require("./crProtocolHelper");
const transport_1 = require("../transport");
class CRBrowser extends platform.EventEmitter {
    constructor(connection) {
        super();
        this._contexts = new Map();
        this._targets = new Map();
        this._tracingRecording = false;
        this._tracingPath = '';
        this._connection = connection;
        this._client = connection.rootSession;
        this._defaultContext = this._createBrowserContext(null, {});
        this._connection.on(crConnection_1.ConnectionEvents.Disconnected, () => {
            for (const context of this.contexts())
                context._browserClosed();
            this.emit(events_2.Events.Browser.Disconnected);
        });
        this._client.on('Target.targetCreated', this._targetCreated.bind(this));
        this._client.on('Target.targetDestroyed', this._targetDestroyed.bind(this));
        this._client.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));
    }
    static async connect(transport, slowMo) {
        const connection = new crConnection_1.CRConnection(transport_1.SlowMoTransport.wrap(transport, slowMo));
        const browser = new CRBrowser(connection);
        await connection.rootSession.send('Target.setDiscoverTargets', { discover: true });
        return browser;
    }
    _createBrowserContext(contextId, options) {
        const context = new browserContext_1.BrowserContext({
            pages: async () => {
                const targets = this._allTargets().filter(target => target.context() === context && target.type() === 'page');
                const pages = await Promise.all(targets.map(target => target.page()));
                return pages.filter(page => !!page);
            },
            existingPages: () => {
                const pages = [];
                for (const target of this._allTargets()) {
                    if (target.context() === context && target._crPage)
                        pages.push(target._crPage.page());
                }
                return pages;
            },
            newPage: async () => {
                const { targetId } = await this._client.send('Target.createTarget', { url: 'about:blank', browserContextId: contextId || undefined });
                const target = this._targets.get(targetId);
                helper_1.assert(await target._initializedPromise, 'Failed to create target for page');
                const page = await target.page();
                return page;
            },
            close: async () => {
                helper_1.assert(contextId, 'Non-incognito profiles cannot be closed!');
                await this._client.send('Target.disposeBrowserContext', { browserContextId: contextId });
                this._contexts.delete(contextId);
            },
            cookies: async () => {
                const { cookies } = await this._client.send('Storage.getCookies', { browserContextId: contextId || undefined });
                return cookies.map(c => {
                    const copy = { sameSite: 'None', ...c };
                    delete copy.size;
                    delete copy.priority;
                    return copy;
                });
            },
            clearCookies: async () => {
                await this._client.send('Storage.clearCookies', { browserContextId: contextId || undefined });
            },
            setCookies: async (cookies) => {
                await this._client.send('Storage.setCookies', { cookies, browserContextId: contextId || undefined });
            },
            setPermissions: async (origin, permissions) => {
                const webPermissionToProtocol = new Map([
                    ['geolocation', 'geolocation'],
                    ['midi', 'midi'],
                    ['notifications', 'notifications'],
                    ['camera', 'videoCapture'],
                    ['microphone', 'audioCapture'],
                    ['background-sync', 'backgroundSync'],
                    ['ambient-light-sensor', 'sensors'],
                    ['accelerometer', 'sensors'],
                    ['gyroscope', 'sensors'],
                    ['magnetometer', 'sensors'],
                    ['accessibility-events', 'accessibilityEvents'],
                    ['clipboard-read', 'clipboardReadWrite'],
                    ['clipboard-write', 'clipboardSanitizedWrite'],
                    ['payment-handler', 'paymentHandler'],
                    // chrome-specific permissions we have.
                    ['midi-sysex', 'midiSysex'],
                ]);
                const filtered = permissions.map(permission => {
                    const protocolPermission = webPermissionToProtocol.get(permission);
                    if (!protocolPermission)
                        throw new Error('Unknown permission: ' + permission);
                    return protocolPermission;
                });
                await this._client.send('Browser.grantPermissions', { origin, browserContextId: contextId || undefined, permissions: filtered });
            },
            clearPermissions: async () => {
                await this._client.send('Browser.resetPermissions', { browserContextId: contextId || undefined });
            },
            setGeolocation: async (geolocation) => {
                for (const page of await context.pages())
                    await page._delegate._client.send('Emulation.setGeolocationOverride', geolocation || {});
            }
        }, options);
        return context;
    }
    async newContext(options = {}) {
        browserContext_1.BrowserContext.validateOptions(options);
        const { browserContextId } = await this._client.send('Target.createBrowserContext');
        const context = this._createBrowserContext(browserContextId, options);
        await context._initialize();
        this._contexts.set(browserContextId, context);
        return context;
    }
    contexts() {
        return Array.from(this._contexts.values());
    }
    async newPage(options) {
        return browser_1.createPageInNewContext(this, options);
    }
    async _targetCreated(event) {
        const targetInfo = event.targetInfo;
        const { browserContextId } = targetInfo;
        const context = (browserContextId && this._contexts.has(browserContextId)) ? this._contexts.get(browserContextId) : this._defaultContext;
        const target = new crTarget_1.CRTarget(this, targetInfo, context, () => this._connection.createSession(targetInfo));
        helper_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');
        this._targets.set(event.targetInfo.targetId, target);
        if (target._isInitialized || await target._initializedPromise)
            this.emit(events_1.Events.CRBrowser.TargetCreated, target);
    }
    async _targetDestroyed(event) {
        const target = this._targets.get(event.targetId);
        target._initializedCallback(false);
        this._targets.delete(event.targetId);
        target._didClose();
        if (await target._initializedPromise)
            this.emit(events_1.Events.CRBrowser.TargetDestroyed, target);
    }
    _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        helper_1.assert(target, 'target should exist before targetInfoChanged');
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url())
            this.emit(events_1.Events.CRBrowser.TargetChanged, target);
    }
    async _closePage(page) {
        await this._client.send('Target.closeTarget', { targetId: crTarget_1.CRTarget.fromPage(page)._targetId });
    }
    _allTargets() {
        return Array.from(this._targets.values()).filter(target => target._isInitialized);
    }
    async waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const existingTarget = this._allTargets().find(predicate);
        if (existingTarget)
            return existingTarget;
        let resolve;
        const targetPromise = new Promise(x => resolve = x);
        this.on(events_1.Events.CRBrowser.TargetCreated, check);
        this.on(events_1.Events.CRBrowser.TargetChanged, check);
        try {
            if (!timeout)
                return await targetPromise;
            return await helper_1.helper.waitWithTimeout(targetPromise, 'target', timeout);
        }
        finally {
            this.removeListener(events_1.Events.CRBrowser.TargetCreated, check);
            this.removeListener(events_1.Events.CRBrowser.TargetChanged, check);
        }
        function check(target) {
            if (predicate(target))
                resolve(target);
        }
    }
    async close() {
        const disconnected = new Promise(f => this._connection.once(crConnection_1.ConnectionEvents.Disconnected, f));
        await Promise.all(this.contexts().map(context => context.close()));
        this._connection.close();
        await disconnected;
    }
    browserTarget() {
        return [...this._targets.values()].find(t => t.type() === 'browser');
    }
    serviceWorker(target) {
        return target._worker();
    }
    async startTracing(page, options = {}) {
        helper_1.assert(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');
        this._tracingClient = page ? page._delegate._client : this._client;
        const defaultCategories = [
            '-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame', 'toplevel',
            'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'
        ];
        const { path = null, screenshots = false, categories = defaultCategories, } = options;
        if (screenshots)
            categories.push('disabled-by-default-devtools.screenshot');
        this._tracingPath = path;
        this._tracingRecording = true;
        await this._tracingClient.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            categories: categories.join(',')
        });
    }
    async stopTracing() {
        helper_1.assert(this._tracingClient, 'Tracing was not started.');
        let fulfill;
        const contentPromise = new Promise(x => fulfill = x);
        this._tracingClient.once('Tracing.tracingComplete', event => {
            crProtocolHelper_1.readProtocolStream(this._tracingClient, event.stream, this._tracingPath).then(fulfill);
        });
        await this._tracingClient.send('Tracing.end');
        this._tracingRecording = false;
        return contentPromise;
    }
    targets(context) {
        const targets = this._allTargets();
        return context ? targets.filter(t => t.context() === context) : targets;
    }
    pageTarget(page) {
        return crTarget_1.CRTarget.fromPage(page);
    }
    isConnected() {
        return !this._connection._closed;
    }
    _setDebugFunction(debugFunction) {
        this._connection._debugProtocol = debugFunction;
    }
}
exports.CRBrowser = CRBrowser;
//# sourceMappingURL=crBrowser.js.map