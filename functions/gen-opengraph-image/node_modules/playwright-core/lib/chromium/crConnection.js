"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const platform = require("../platform");
const helper_1 = require("../helper");
exports.ConnectionEvents = {
    Disconnected: Symbol('ConnectionEvents.Disconnected')
};
// CRPlaywright uses this special id to issue Browser.close command which we
// should ignore.
exports.kBrowserCloseMessageId = -9999;
class CRConnection extends platform.EventEmitter {
    constructor(transport) {
        super();
        this._lastId = 0;
        this._sessions = new Map();
        this._closed = false;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, 'browser', '');
        this._sessions.set('', this.rootSession);
        this._debugProtocol = platform.debug('pw:protocol');
    }
    static fromSession(session) {
        return session._connection;
    }
    session(sessionId) {
        return this._sessions.get(sessionId) || null;
    }
    _rawSend(sessionId, message) {
        const id = ++this._lastId;
        message.id = id;
        if (sessionId)
            message.sessionId = sessionId;
        const data = JSON.stringify(message);
        this._debugProtocol('SEND ► ' + data);
        this._transport.send(data);
        return id;
    }
    async _onMessage(message) {
        this._debugProtocol('◀ RECV ' + message);
        const object = JSON.parse(message);
        if (object.id === exports.kBrowserCloseMessageId)
            return;
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new CRSession(this, object.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
                session._onClosed();
                this._sessions.delete(object.params.sessionId);
            }
        }
        const session = this._sessions.get(object.sessionId || '');
        if (session)
            session._onMessage(object);
    }
    _onClose() {
        this._closed = true;
        this._transport.onmessage = undefined;
        this._transport.onclose = undefined;
        for (const session of this._sessions.values())
            session._onClosed();
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(exports.ConnectionEvents.Disconnected));
    }
    close() {
        if (!this._closed)
            this._transport.close();
    }
    async createSession(targetInfo) {
        const { sessionId } = await this.rootSession.send('Target.attachToTarget', { targetId: targetInfo.targetId, flatten: true });
        return this._sessions.get(sessionId);
    }
    async createBrowserSession() {
        const { sessionId } = await this.rootSession.send('Target.attachToBrowserTarget');
        return this._sessions.get(sessionId);
    }
}
exports.CRConnection = CRConnection;
exports.CRSessionEvents = {
    Disconnected: Symbol('Events.CDPSession.Disconnected')
};
class CRSession extends platform.EventEmitter {
    constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
    }
    send(method, params) {
        if (!this._connection)
            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        const id = this._connection._rawSend(this._sessionId, { method, params });
        return new Promise((resolve, reject) => {
            this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
    }
    _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
            const callback = this._callbacks.get(object.id);
            this._callbacks.delete(object.id);
            if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
            else
                callback.resolve(object.result);
        }
        else {
            helper_1.assert(!object.id);
            Promise.resolve().then(() => this.emit(object.method, object.params));
        }
    }
    async detach() {
        if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        await this._connection.rootSession.send('Target.detachFromTarget', { sessionId: this._sessionId });
    }
    _onClosed() {
        for (const callback of this._callbacks.values())
            callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(exports.CRSessionEvents.Disconnected));
    }
}
exports.CRSession = CRSession;
function createProtocolError(error, method, object) {
    let message = `Protocol error (${method}): ${object.error.message}`;
    if ('data' in object.error)
        message += ` ${object.error.data}`;
    return rewriteError(error, message);
}
function rewriteError(error, message) {
    error.message = message;
    return error;
}
//# sourceMappingURL=crConnection.js.map