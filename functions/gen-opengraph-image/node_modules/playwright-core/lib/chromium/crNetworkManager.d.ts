/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { CRSession } from './crConnection';
import { Page } from '../page';
import { RegisteredListener } from '../helper';
import { Protocol } from './protocol';
import * as network from '../network';
import * as frames from '../frames';
import * as platform from '../platform';
import { Credentials } from '../types';
export declare class CRNetworkManager {
    private _client;
    private _page;
    private _requestIdToRequest;
    private _requestIdToRequestWillBeSentEvent;
    private _offline;
    private _credentials;
    private _attemptedAuthentications;
    private _userRequestInterceptionEnabled;
    private _protocolRequestInterceptionEnabled;
    private _userCacheDisabled;
    private _requestIdToInterceptionId;
    private _eventListeners;
    constructor(client: CRSession, page: Page);
    instrumentNetworkEvents(session: CRSession): RegisteredListener[];
    initialize(): Promise<void>;
    dispose(): void;
    authenticate(credentials: Credentials | null): Promise<void>;
    setOfflineMode(value: boolean): Promise<void>;
    setCacheEnabled(enabled: boolean): Promise<void>;
    setRequestInterception(value: boolean): Promise<void>;
    _updateProtocolRequestInterception(): Promise<void>;
    _updateProtocolCacheDisabled(): Promise<void>;
    _onRequestWillBeSent(event: Protocol.Network.requestWillBeSentPayload): void;
    _onAuthRequired(event: Protocol.Fetch.authRequiredPayload): void;
    _onRequestPaused(event: Protocol.Fetch.requestPausedPayload): void;
    _onRequest(event: Protocol.Network.requestWillBeSentPayload, interceptionId: string | null): void;
    _createResponse(request: InterceptableRequest, responsePayload: Protocol.Network.Response): network.Response;
    _handleRequestRedirect(request: InterceptableRequest, responsePayload: Protocol.Network.Response): void;
    _onResponseReceived(event: Protocol.Network.responseReceivedPayload): void;
    _onLoadingFinished(event: Protocol.Network.loadingFinishedPayload): void;
    _onLoadingFailed(event: Protocol.Network.loadingFailedPayload): void;
}
declare class InterceptableRequest implements network.RequestDelegate {
    readonly request: network.Request;
    _requestId: string;
    _interceptionId: string | null;
    _documentId: string | undefined;
    private _client;
    constructor(client: CRSession, frame: frames.Frame | null, interceptionId: string | null, documentId: string | undefined, allowInterception: boolean, event: Protocol.Network.requestWillBeSentPayload, redirectChain: network.Request[]);
    continue(overrides?: {
        method?: string;
        headers?: network.Headers;
        postData?: string;
    }): Promise<void>;
    fulfill(response: {
        status: number;
        headers: network.Headers;
        contentType: string;
        body: (string | platform.BufferType);
    }): Promise<void>;
    abort(errorCode?: string): Promise<void>;
}
export {};
