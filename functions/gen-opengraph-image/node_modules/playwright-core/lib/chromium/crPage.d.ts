/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as dom from '../dom';
import * as frames from '../frames';
import * as network from '../network';
import { CRSession } from './crConnection';
import { CRNetworkManager } from './crNetworkManager';
import { Page } from '../page';
import { Protocol } from './protocol';
import { PageDelegate } from '../page';
import { RawMouseImpl, RawKeyboardImpl } from './crInput';
import { CRCoverage } from './crCoverage';
import { CRBrowser } from './crBrowser';
import { BrowserContext } from '../browserContext';
import * as types from '../types';
import * as platform from '../platform';
export declare class CRPage implements PageDelegate {
    _client: CRSession;
    private readonly _page;
    readonly _networkManager: CRNetworkManager;
    private _contextIdToContext;
    private _isolatedWorlds;
    private _eventListeners;
    rawMouse: RawMouseImpl;
    rawKeyboard: RawKeyboardImpl;
    private _browser;
    private _pdf;
    private _coverage;
    constructor(client: CRSession, browser: CRBrowser, browserContext: BrowserContext);
    initialize(): Promise<void>;
    didClose(): void;
    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;
    _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload): void;
    _onFrameStoppedLoading(frameId: string): void;
    _handleFrameTree(frameTree: Protocol.Page.FrameTree): void;
    page(): Page;
    _onFrameAttached(frameId: string, parentFrameId: string | null): void;
    _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean): void;
    _ensureIsolatedWorld(name: string): Promise<void>;
    _onFrameNavigatedWithinDocument(frameId: string, url: string): void;
    _onFrameDetached(frameId: string): void;
    _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription): void;
    _onExecutionContextDestroyed(executionContextId: number): void;
    _onExecutionContextsCleared(): void;
    _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload): void;
    _onDetachedFromTarget(event: Protocol.Target.detachedFromTargetPayload): void;
    _onConsoleAPI(event: Protocol.Runtime.consoleAPICalledPayload): Promise<void>;
    exposeBinding(name: string, bindingFunction: string): Promise<void>;
    _onBindingCalled(event: Protocol.Runtime.bindingCalledPayload): void;
    _onDialog(event: Protocol.Page.javascriptDialogOpeningPayload): void;
    _handleException(exceptionDetails: Protocol.Runtime.ExceptionDetails): void;
    _onTargetCrashed(): void;
    _onLogEntryAdded(event: Protocol.Log.entryAddedPayload): void;
    _onFileChooserOpened(event: Protocol.Page.fileChooserOpenedPayload): Promise<void>;
    setExtraHTTPHeaders(headers: network.Headers): Promise<void>;
    setViewportSize(viewportSize: types.Size): Promise<void>;
    _updateViewport(updateTouch: boolean): Promise<void>;
    setEmulateMedia(mediaType: types.MediaType | null, colorScheme: types.ColorScheme | null): Promise<void>;
    setCacheEnabled(enabled: boolean): Promise<void>;
    setRequestInterception(enabled: boolean): Promise<void>;
    setOfflineMode(value: boolean): Promise<void>;
    authenticate(credentials: types.Credentials | null): Promise<void>;
    setFileChooserIntercepted(enabled: boolean): Promise<void>;
    opener(): Promise<Page | null>;
    reload(): Promise<void>;
    private _go;
    goBack(): Promise<boolean>;
    goForward(): Promise<boolean>;
    evaluateOnNewDocument(source: string): Promise<void>;
    closePage(runBeforeUnload: boolean): Promise<void>;
    getBoundingBoxForScreenshot(handle: dom.ElementHandle<Node>): Promise<types.Rect | null>;
    canScreenshotOutsideViewport(): boolean;
    setBackgroundColor(color?: {
        r: number;
        g: number;
        b: number;
        a: number;
    }): Promise<void>;
    takeScreenshot(format: 'png' | 'jpeg', options: types.ScreenshotOptions, viewportSize: types.Size): Promise<platform.BufferType>;
    resetViewport(): Promise<void>;
    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;
    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;
    isElementHandle(remoteObject: any): boolean;
    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;
    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<void>;
    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;
    layoutViewport(): Promise<{
        width: number;
        height: number;
    }>;
    setInputFiles(handle: dom.ElementHandle<HTMLInputElement>, files: types.FilePayload[]): Promise<void>;
    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;
    adoptBackendNodeId(backendNodeId: Protocol.DOM.BackendNodeId, to: dom.FrameExecutionContext): Promise<dom.ElementHandle>;
    getAccessibilityTree(needle?: dom.ElementHandle): Promise<{
        tree: import("../accessibility").AXNode;
        needle: import("../accessibility").AXNode | null;
    }>;
    pdf(options?: types.PDFOptions): Promise<platform.BufferType>;
    coverage(): CRCoverage;
    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;
}
