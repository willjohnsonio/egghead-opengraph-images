/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as platform from '../platform';
import { ConnectionTransport } from '../transport';
import { Protocol } from './protocol';
export declare const ConnectionEvents: {
    Disconnected: symbol;
};
export declare const kBrowserCloseMessageId = -9999;
export declare class CRConnection extends platform.EventEmitter {
    private _lastId;
    private _transport;
    private _sessions;
    readonly rootSession: CRSession;
    _closed: boolean;
    _debugProtocol: (message: string) => void;
    constructor(transport: ConnectionTransport);
    static fromSession(session: CRSession): CRConnection;
    session(sessionId: string): CRSession | null;
    _rawSend(sessionId: string, message: any): number;
    _onMessage(message: string): Promise<void>;
    _onClose(): void;
    close(): void;
    createSession(targetInfo: Protocol.Target.TargetInfo): Promise<CRSession>;
    createBrowserSession(): Promise<CRSession>;
}
export declare const CRSessionEvents: {
    Disconnected: symbol;
};
export declare class CRSession extends platform.EventEmitter {
    _connection: CRConnection | null;
    private _callbacks;
    private _targetType;
    private _sessionId;
    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;
    constructor(connection: CRConnection, targetType: string, sessionId: string);
    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;
    _onMessage(object: {
        id?: number;
        method: string;
        params: any;
        error: {
            message: string;
            data: any;
        };
        result?: any;
    }): void;
    detach(): Promise<void>;
    _onClosed(): void;
}
