/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as frames from './frames';
import * as platform from './platform';
export declare type NetworkCookie = {
    name: string;
    value: string;
    domain: string;
    path: string;
    expires: number;
    httpOnly: boolean;
    secure: boolean;
    session: boolean;
    sameSite: 'Strict' | 'Lax' | 'None';
};
export declare type SetNetworkCookieParam = {
    name: string;
    value: string;
    url?: string;
    domain?: string;
    path?: string;
    expires?: number;
    httpOnly?: boolean;
    secure?: boolean;
    sameSite?: 'Strict' | 'Lax' | 'None';
};
export declare function filterCookies(cookies: NetworkCookie[], urls: string[]): NetworkCookie[];
export declare function rewriteCookies(cookies: SetNetworkCookieParam[]): SetNetworkCookieParam[];
export declare type Headers = {
    [key: string]: string;
};
export declare class Request {
    private _delegate;
    private _response;
    _redirectChain: Request[];
    _finalRequest: Request;
    readonly _documentId?: string;
    readonly _isFavicon: boolean;
    private _failureText;
    private _url;
    private _resourceType;
    private _method;
    private _postData;
    private _headers;
    private _frame;
    private _waitForResponsePromise;
    private _waitForResponsePromiseCallback;
    private _waitForFinishedPromise;
    private _waitForFinishedPromiseCallback;
    private _interceptionHandled;
    constructor(delegate: RequestDelegate | null, frame: frames.Frame | null, redirectChain: Request[], documentId: string | undefined, url: string, resourceType: string, method: string, postData: string | undefined, headers: Headers);
    _setFailureText(failureText: string): void;
    url(): string;
    resourceType(): string;
    method(): string;
    postData(): string | undefined;
    headers(): {
        [key: string]: string;
    };
    response(): Response | null;
    _waitForFinished(): Promise<Response | null>;
    _waitForResponse(): Promise<Response>;
    _setResponse(response: Response): void;
    frame(): frames.Frame | null;
    isNavigationRequest(): boolean;
    redirectChain(): Request[];
    failure(): {
        errorText: string;
    } | null;
    abort(errorCode?: string): Promise<void>;
    fulfill(response: {
        status: number;
        headers: Headers;
        contentType: string;
        body: (string | platform.BufferType);
    }): Promise<void>;
    continue(overrides?: {
        method?: string;
        headers?: Headers;
        postData?: string;
    }): Promise<void>;
    _isIntercepted(): boolean;
}
declare type GetResponseBodyCallback = () => Promise<platform.BufferType>;
export declare class Response {
    private _request;
    private _contentPromise;
    _finishedPromise: Promise<Error | null>;
    private _finishedPromiseCallback;
    private _status;
    private _statusText;
    private _url;
    private _headers;
    private _getResponseBodyCallback;
    constructor(request: Request, status: number, statusText: string, headers: Headers, getResponseBodyCallback: GetResponseBodyCallback);
    _requestFinished(error?: Error): void;
    url(): string;
    ok(): boolean;
    status(): number;
    statusText(): string;
    headers(): object;
    buffer(): Promise<platform.BufferType>;
    text(): Promise<string>;
    json(): Promise<object>;
    request(): Request;
    frame(): frames.Frame | null;
}
export interface RequestDelegate {
    abort(errorCode: string): Promise<void>;
    fulfill(response: {
        status: number;
        headers: Headers;
        contentType: string;
        body: (string | platform.BufferType);
    }): Promise<void>;
    continue(overrides: {
        method?: string;
        headers?: Headers;
        postData?: string;
    }): Promise<void>;
}
export declare const STATUS_TEXTS: {
    [status: string]: string;
};
export {};
