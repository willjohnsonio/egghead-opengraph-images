"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Note: this is the only file outside of src/server which can import external dependencies.
// All dependencies must be listed in web.webpack.config.js to avoid bundling them.
const nodeEvents = require("events");
const nodeFS = require("fs");
const nodePath = require("path");
const nodeDebug = require("debug");
const nodeBuffer = require("buffer");
const jpeg = require("jpeg-js");
const png = require("pngjs");
const http = require("http");
const https = require("https");
const NodeWebSocket = require("ws");
const helper_1 = require("./helper");
exports.isNode = typeof process === 'object' && !!process && typeof process.versions === 'object' && !!process.versions && !!process.versions.node;
function promisify(nodeFunction) {
    helper_1.assert(exports.isNode);
    function promisified(...args) {
        return new Promise((resolve, reject) => {
            function callback(err, ...result) {
                if (err)
                    return reject(err);
                if (result.length === 1)
                    return resolve(result[0]);
                return resolve(result);
            }
            nodeFunction.call(null, ...args, callback);
        });
    }
    return promisified;
}
exports.promisify = promisify;
exports.EventEmitter = exports.isNode ? nodeEvents.EventEmitter : (class EventEmitterImpl {
    constructor() {
        this._listeners = new Map();
    }
    on(event, listener) {
        let set = this._listeners.get(event);
        if (!set) {
            set = new Set();
            this._listeners.set(event, set);
        }
        set.add(listener);
        return this;
    }
    addListener(event, listener) {
        return this.on(event, listener);
    }
    once(event, listener) {
        const wrapped = (...args) => {
            this.removeListener(event, wrapped);
            listener(...args);
        };
        return this.addListener(event, wrapped);
    }
    removeListener(event, listener) {
        const set = this._listeners.get(event);
        if (set)
            set.delete(listener);
        return this;
    }
    emit(event, ...args) {
        const set = this._listeners.get(event);
        if (!set || !set.size)
            return true;
        const dispatch = !this._deliveryQueue;
        if (!this._deliveryQueue)
            this._deliveryQueue = [];
        for (const listener of set)
            this._deliveryQueue.push({ listener, args });
        if (!dispatch)
            return true;
        for (let index = 0; index < this._deliveryQueue.length; index++) {
            const { listener, args } = this._deliveryQueue[index];
            listener(...args);
        }
        this._deliveryQueue = undefined;
        return true;
    }
    listenerCount(event) {
        const set = this._listeners.get(event);
        return set ? set.size : 0;
    }
});
exports.debug = exports.isNode ? nodeDebug : (function debug(namespace) {
    return () => { };
});
exports.Buffer = exports.isNode ? nodeBuffer.Buffer : (class BufferImpl {
    constructor(data, encoding = 'utf8') {
        if (data instanceof ArrayBuffer) {
            this.data = data;
        }
        else {
            if (encoding === 'base64') {
                const binary = atob(data);
                this.data = new ArrayBuffer(binary.length * 2);
                const view = new Uint16Array(this.data);
                for (let i = 0; i < binary.length; i++)
                    view[i] = binary.charCodeAt(i);
            }
            else if (encoding === 'utf8') {
                const encoder = new TextEncoder();
                this.data = encoder.encode(data).buffer;
            }
            else {
                throw new Error('Unsupported encoding "' + encoding + '"');
            }
        }
    }
    static from(data, encoding = 'utf8') {
        return new BufferImpl(data, encoding);
    }
    static byteLength(buffer, encoding = 'utf8') {
        if (helper_1.helper.isString(buffer))
            buffer = new BufferImpl(buffer, encoding);
        return buffer.data.byteLength;
    }
    static concat(buffers) {
        if (!buffers.length)
            return new BufferImpl(new ArrayBuffer(0));
        if (buffers.length === 1)
            return buffers[0];
        const view = new Uint8Array(buffers.reduce((a, b) => a + b.data.byteLength, 0));
        let offset = 0;
        for (const buffer of buffers) {
            view.set(new Uint8Array(buffer.data), offset);
            offset += buffer.data.byteLength;
        }
        return new BufferImpl(view.buffer);
    }
    toString(encoding = 'utf8') {
        if (encoding === 'base64') {
            const binary = String.fromCharCode(...new Uint16Array(this.data));
            return btoa(binary);
        }
        const decoder = new TextDecoder(encoding, { fatal: true });
        return decoder.decode(this.data);
    }
});
function assertFileAccess() {
    helper_1.assert(exports.isNode, 'Working with filesystem using "path" is only supported in Node.js');
}
async function readFileAsync(file, encoding) {
    assertFileAccess();
    return await promisify(nodeFS.readFile)(file, encoding);
}
exports.readFileAsync = readFileAsync;
async function writeFileAsync(file, data) {
    assertFileAccess();
    return await promisify(nodeFS.writeFile)(file, data);
}
exports.writeFileAsync = writeFileAsync;
function basename(file) {
    assertFileAccess();
    return nodePath.basename(file);
}
exports.basename = basename;
async function openFdAsync(file, flags) {
    assertFileAccess();
    return await promisify(nodeFS.open)(file, flags);
}
exports.openFdAsync = openFdAsync;
async function writeFdAsync(fd, buffer) {
    assertFileAccess();
    return await promisify(nodeFS.write)(fd, buffer);
}
exports.writeFdAsync = writeFdAsync;
async function closeFdAsync(fd) {
    assertFileAccess();
    return await promisify(nodeFS.close)(fd);
}
exports.closeFdAsync = closeFdAsync;
function getMimeType(file) {
    const extension = file.substring(file.lastIndexOf('.') + 1);
    return extensionToMime[extension] || 'application/octet-stream';
}
exports.getMimeType = getMimeType;
function urlMatches(urlString, match) {
    if (match === undefined || match === '')
        return true;
    if (helper_1.helper.isString(match))
        match = helper_1.helper.globToRegex(match);
    if (match instanceof RegExp)
        return match.test(urlString);
    if (typeof match === 'string' && match === urlString)
        return true;
    const url = new URL(urlString);
    if (typeof match === 'string')
        return url.pathname === match;
    helper_1.assert(typeof match === 'function', 'url parameter should be string, RegExp or function');
    return match(url);
}
exports.urlMatches = urlMatches;
function pngToJpeg(buffer) {
    helper_1.assert(exports.isNode, 'Converting from png to jpeg is only supported in Node.js');
    return jpeg.encode(png.PNG.sync.read(buffer)).data;
}
exports.pngToJpeg = pngToJpeg;
function nodeFetch(url) {
    let resolve;
    let reject = () => { };
    const promise = new Promise((res, rej) => { resolve = res; reject = rej; });
    const endpointURL = new URL(url);
    const protocol = endpointURL.protocol === 'https:' ? https : http;
    const request = protocol.request(endpointURL, res => {
        let data = '';
        if (res.statusCode !== 200) {
            // Consume response data to free up memory.
            res.resume();
            reject(new Error('HTTP ' + res.statusCode));
            return;
        }
        res.setEncoding('utf8');
        res.on('data', chunk => data += chunk);
        res.on('end', () => resolve(data));
    });
    request.on('error', reject);
    request.end();
    return promise;
}
function fetchUrl(url) {
    if (exports.isNode)
        return nodeFetch(url);
    return fetch(url).then(response => {
        if (!response.ok)
            throw new Error('HTTP ' + response.status + ' ' + response.statusText);
        return response.text();
    });
}
exports.fetchUrl = fetchUrl;
// See https://joel.tools/microtasks/
function makeWaitForNextTask() {
    helper_1.assert(exports.isNode, 'Waitng for the next task is only supported in nodejs');
    if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
    // Unlike Node 11, Node 10 and less have a bug with Task and MicroTask execution order:
    // - https://github.com/nodejs/node/issues/22257
    //
    // So we can't simply run setImmediate to dispatch code in a following task.
    // However, we can run setImmediate from-inside setImmediate to make sure we're getting
    // in the following task.
    let spinning = false;
    const callbacks = [];
    const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
            spinning = false;
            return;
        }
        setImmediate(loop);
        // Make sure to call callback() as the last thing since it's
        // untrusted code that might throw.
        callback();
    };
    return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
            spinning = true;
            setImmediate(loop);
        }
    };
}
exports.makeWaitForNextTask = makeWaitForNextTask;
class WebSocketTransport {
    constructor(url) {
        this._ws = (exports.isNode ? new NodeWebSocket(url, [], {
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
        }) : new WebSocket(url));
        this._connectPromise = new Promise(fulfill => {
            this._ws.addEventListener('open', () => fulfill(null));
            this._ws.addEventListener('error', event => fulfill(new Error('WebSocket error: ' + event.message)));
        });
        // The 'ws' module in node sometimes sends us multiple messages in a single task.
        // In Web, all IO callbacks (e.g. WebSocket callbacks)
        // are dispatched into separate tasks, so there's no need
        // to do anything extra.
        const messageWrap = exports.isNode ? makeWaitForNextTask() : cb => cb();
        this._ws.addEventListener('message', event => {
            messageWrap(() => {
                if (this.onmessage)
                    this.onmessage.call(null, event.data);
            });
        });
        this._ws.addEventListener('close', event => {
            if (this.onclose)
                this.onclose.call(null);
        });
        // Silently ignore all errors - we don't know what to do with them.
        this._ws.addEventListener('error', () => { });
    }
    async send(message) {
        const error = await this._connectPromise;
        if (error)
            throw error;
        this._ws.send(message);
    }
    close() {
        this._ws.close();
    }
}
exports.WebSocketTransport = WebSocketTransport;
const extensionToMime = {
    'ai': 'application/postscript',
    'apng': 'image/apng',
    'appcache': 'text/cache-manifest',
    'au': 'audio/basic',
    'bmp': 'image/bmp',
    'cer': 'application/pkix-cert',
    'cgm': 'image/cgm',
    'coffee': 'text/coffeescript',
    'conf': 'text/plain',
    'crl': 'application/pkix-crl',
    'css': 'text/css',
    'csv': 'text/csv',
    'def': 'text/plain',
    'doc': 'application/msword',
    'dot': 'application/msword',
    'drle': 'image/dicom-rle',
    'dtd': 'application/xml-dtd',
    'ear': 'application/java-archive',
    'emf': 'image/emf',
    'eps': 'application/postscript',
    'exr': 'image/aces',
    'fits': 'image/fits',
    'g3': 'image/g3fax',
    'gbr': 'application/rpki-ghostbusters',
    'gif': 'image/gif',
    'glb': 'model/gltf-binary',
    'gltf': 'model/gltf+json',
    'gz': 'application/gzip',
    'h261': 'video/h261',
    'h263': 'video/h263',
    'h264': 'video/h264',
    'heic': 'image/heic',
    'heics': 'image/heic-sequence',
    'heif': 'image/heif',
    'heifs': 'image/heif-sequence',
    'htm': 'text/html',
    'html': 'text/html',
    'ics': 'text/calendar',
    'ief': 'image/ief',
    'ifb': 'text/calendar',
    'iges': 'model/iges',
    'igs': 'model/iges',
    'in': 'text/plain',
    'ini': 'text/plain',
    'jade': 'text/jade',
    'jar': 'application/java-archive',
    'jls': 'image/jls',
    'jp2': 'image/jp2',
    'jpe': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'jpf': 'image/jpx',
    'jpg': 'image/jpeg',
    'jpg2': 'image/jp2',
    'jpgm': 'video/jpm',
    'jpgv': 'video/jpeg',
    'jpm': 'image/jpm',
    'jpx': 'image/jpx',
    'js': 'application/javascript',
    'json': 'application/json',
    'json5': 'application/json5',
    'jsx': 'text/jsx',
    'jxr': 'image/jxr',
    'kar': 'audio/midi',
    'ktx': 'image/ktx',
    'less': 'text/less',
    'list': 'text/plain',
    'litcoffee': 'text/coffeescript',
    'log': 'text/plain',
    'm1v': 'video/mpeg',
    'm21': 'application/mp21',
    'm2a': 'audio/mpeg',
    'm2v': 'video/mpeg',
    'm3a': 'audio/mpeg',
    'm4a': 'audio/mp4',
    'm4p': 'application/mp4',
    'man': 'text/troff',
    'manifest': 'text/cache-manifest',
    'markdown': 'text/markdown',
    'mathml': 'application/mathml+xml',
    'md': 'text/markdown',
    'mdx': 'text/mdx',
    'me': 'text/troff',
    'mesh': 'model/mesh',
    'mft': 'application/rpki-manifest',
    'mid': 'audio/midi',
    'midi': 'audio/midi',
    'mj2': 'video/mj2',
    'mjp2': 'video/mj2',
    'mjs': 'application/javascript',
    'mml': 'text/mathml',
    'mov': 'video/quicktime',
    'mp2': 'audio/mpeg',
    'mp21': 'application/mp21',
    'mp2a': 'audio/mpeg',
    'mp3': 'audio/mpeg',
    'mp4': 'video/mp4',
    'mp4a': 'audio/mp4',
    'mp4s': 'application/mp4',
    'mp4v': 'video/mp4',
    'mpe': 'video/mpeg',
    'mpeg': 'video/mpeg',
    'mpg': 'video/mpeg',
    'mpg4': 'video/mp4',
    'mpga': 'audio/mpeg',
    'mrc': 'application/marc',
    'ms': 'text/troff',
    'msh': 'model/mesh',
    'n3': 'text/n3',
    'oga': 'audio/ogg',
    'ogg': 'audio/ogg',
    'ogv': 'video/ogg',
    'ogx': 'application/ogg',
    'otf': 'font/otf',
    'p10': 'application/pkcs10',
    'p7c': 'application/pkcs7-mime',
    'p7m': 'application/pkcs7-mime',
    'p7s': 'application/pkcs7-signature',
    'p8': 'application/pkcs8',
    'pdf': 'application/pdf',
    'pki': 'application/pkixcmp',
    'pkipath': 'application/pkix-pkipath',
    'png': 'image/png',
    'ps': 'application/postscript',
    'pskcxml': 'application/pskc+xml',
    'qt': 'video/quicktime',
    'rmi': 'audio/midi',
    'rng': 'application/xml',
    'roa': 'application/rpki-roa',
    'roff': 'text/troff',
    'rsd': 'application/rsd+xml',
    'rss': 'application/rss+xml',
    'rtf': 'application/rtf',
    'rtx': 'text/richtext',
    's3m': 'audio/s3m',
    'sgi': 'image/sgi',
    'sgm': 'text/sgml',
    'sgml': 'text/sgml',
    'shex': 'text/shex',
    'shtml': 'text/html',
    'sil': 'audio/silk',
    'silo': 'model/mesh',
    'slim': 'text/slim',
    'slm': 'text/slim',
    'snd': 'audio/basic',
    'spx': 'audio/ogg',
    'stl': 'model/stl',
    'styl': 'text/stylus',
    'stylus': 'text/stylus',
    'svg': 'image/svg+xml',
    'svgz': 'image/svg+xml',
    't': 'text/troff',
    't38': 'image/t38',
    'text': 'text/plain',
    'tfx': 'image/tiff-fx',
    'tif': 'image/tiff',
    'tiff': 'image/tiff',
    'tr': 'text/troff',
    'ts': 'video/mp2t',
    'tsv': 'text/tab-separated-values',
    'ttc': 'font/collection',
    'ttf': 'font/ttf',
    'ttl': 'text/turtle',
    'txt': 'text/plain',
    'uri': 'text/uri-list',
    'uris': 'text/uri-list',
    'urls': 'text/uri-list',
    'vcard': 'text/vcard',
    'vrml': 'model/vrml',
    'vtt': 'text/vtt',
    'war': 'application/java-archive',
    'wasm': 'application/wasm',
    'wav': 'audio/wav',
    'weba': 'audio/webm',
    'webm': 'video/webm',
    'webmanifest': 'application/manifest+json',
    'webp': 'image/webp',
    'wmf': 'image/wmf',
    'woff': 'font/woff',
    'woff2': 'font/woff2',
    'wrl': 'model/vrml',
    'x3d': 'model/x3d+xml',
    'x3db': 'model/x3d+fastinfoset',
    'x3dbz': 'model/x3d+binary',
    'x3dv': 'model/x3d-vrml',
    'x3dvz': 'model/x3d+vrml',
    'x3dz': 'model/x3d+xml',
    'xaml': 'application/xaml+xml',
    'xht': 'application/xhtml+xml',
    'xhtml': 'application/xhtml+xml',
    'xm': 'audio/xm',
    'xml': 'text/xml',
    'xsd': 'application/xml',
    'xsl': 'application/xml',
    'xslt': 'application/xslt+xml',
    'yaml': 'text/yaml',
    'yml': 'text/yaml',
    'zip': 'application/zip'
};
//# sourceMappingURL=platform.js.map